% !TeX root = RJwrapper.tex
% !TEX spellcheck = en_US

\title{movieROC: Visualizing the Decision Rules Underlying Binary Classification}
\author{by Sonia P\'erez-Fern\'andez, Pablo Mart\'inez-Camblor and Norberto Corral-Blanco}

\maketitle

\abstract{
The receiver operating characteristic (ROC) curve is a graphical tool commonly used to depict the binary classification accuracy of a continuous marker in terms of its sensitivity and specificity. The standard ROC curve assumes a monotone relationship between the marker and the response, inducing classification subsets of the form $(c,\infty)$ with $c \in \mathbb R$.
However, in non-standard cases, the involved classification regions are not so clear, highlighting the importance of tracking the decision rules.
This paper introduces the R package movieROC, which provides visualization tools for understanding the ability of markers to identify a characteristic of interest, complementing the ROC curve representation. This tool accommodates multivariate scenarios and generalizations involving different decision rules.
The main contribution of this package is the visualization of the underlying classification regions, with the associated gain in interpretability. Adding the time (videos) as a third dimension, this package facilitates the visualization of binary classification in multivariate problems. It constitutes a good tool to generate graphical material for presentations.
}

\section{Introduction} \label{introduction}

The use of data to detect a characteristic of interest is a cornerstone of many disciplines such as medicine (to diagnose a pathology or to predict a patient outcome), finance (to detect fraud) or machine learning (to evaluate a classification algorithm), among others. Continuous markers are surrogate measures for the characteristic under study, or predictors of a potential subsequent event. They are measured in subjects, some of them with the characteristic (\dfn{positive}), and some without it (\dfn{negative}). \linebreak 
In addition to reliability and feasibility, a good marker must have two relevant properties: interpretability and accuracy \citep{Mayeux2004}. High binary classification \dfn{accuracy} can be achieved if there exists a strong relationship between the marker and the \dfn{response}. The latter is assessed by a \dfn{gold standard} for the presence or absence of the characteristic of interest. \dfn{Interpretability} refers to the \dfn{decision rules} or \dfn{subsets} considered in the classification process. This piece of research seeks to elucidate both desirable properties for a marker by the implementation of a graphical tool in R language. We propose a novel approach involving the generation of videos as a solution to effectively capture the classification procedure for univariate and multivariate markers. Graphical analysis plays a pivotal role in data exploration, interpretation, and communication. Its burgeoning potential is underscored by the fast pace of technological advances, which empower the creation of insightful graphical representations.

A usual practice when the binary classification accuracy of a marker is of interest involves the representation of the \dfn{Receiver Operating Characteristic (ROC) curve}, summarized by the \dfn{Area Under the Curve} (\dfn{AUC}) \citep{Hanley1982}. The resulting plot reflects the trade-off between the sensitivity and the complementary of the specificity. \dfn{Sensitivity} and \dfn{specificity} are probabilities of correctly classifying subjects, either positive or negative, respectively. Mathematically, let $\xi$ and $\chi$ be the random variables modeling the marker values in the positive and the negative population, respectively, with $F_\xi(\cdot)$ and $F_\chi(\cdot)$ their associated cumulative distribution functions. Assuming that the expected value of the marker is larger in the positive than in the negative population, the standard ROC curve is based on \dfn{classification subsets} of the form $s = (c, \infty)$, where $c$ is the so-called \dfn{cut-off value or threshold} in the support of the marker $X$, $\mathcal{S}(X)$. One subject is classified as a positive if its marker value is within this region, and as a negative otherwise. This type of subsets has two important advantages: first, their interpretability is clear; second, for each specificity $1-t \in [0,1]$, the corresponding $s_t = (c_t, \infty)$ is univocally defined by $c_t = F_\chi^{-1}(1-t)$ for absolutely continuous markers. 


When differences in marker distribution between the negative and the positive population are only in location but not in shape, then $F_\chi(\cdot) < F_\xi(\cdot)$, and the classification is direct by using these decision rules. However, when this is not the case, the standard ROC curve may cross the main diagonal, resulting in an \dfn{improper} curve \citep{Dorfman1997}. This may be due to three different scenarios:
\begin{itemize}
\item[i)] the behavior of the marker in the two studied populations is different but it is not possible to determine the decision rules. Notice that the binary classification problem goes further than distinction between the two populations: the classification subsets should be highly likely in one population and highly unlikely in the other one \citep{Camblor2018a};
\item[ii)] there exists a relationship between the marker and the response with a potential classification use, but this is not monotone;
\item[iii)] there is no relationship between the marker and the response at all (main diagonal ROC curve).
\end{itemize}

In the second case, we have to define classification subsets different from standard $s_t=(c_t,\infty)$.
Therefore, the use of the marker becomes more complex. With the aim of accommodating scenarios where both higher and lower values of the marker are associated with a higher risk of having the characteristic, \citet{Camblor2017a} proposed the so-called \dfn{generalized ROC (gROC) curve}. This curve tracks the highest sensitivity for every specificity in the unit interval resulting from subsets of the form $s_t=(-\infty, x_t^L] \cup (x_t^U, \infty)$ with $x_t^L \leq x_t^U \in \mathcal{S}(X)$.

Despite final decisions are based on the underlying classification subsets, they are typically not depicted.
This omission is not a shortcoming in standard cases, as for each specificity $1-t \in [0,1]$, there is only one rule of the form $s_t = (c_t, \infty)$ which such specificity. Particularly, $s_t$ is univocally defined by $c_t = 1 - F_\chi^{-1}(1-t)$; and the same applies if we fix a sensitivity. Nevertheless, if the gROC curve is taken, there are infinite subsets of the form $s_t=(-\infty, x_t^L] \cup (x_t^U, \infty)$ resulting in $\P(\chi \in s_t) = t$. 
This loss of univocity underlines the importance of reporting (numerically and/or graphically) the decision rules actually proposed for classifying. This gap is covered in the presented package.

An alternative approach to assess the classification performance of a marker involves considering a transformation of it. This transformation $h(\cdot)$ aims to capture differences in distribution between the two populations in the ROC sense. Once $h(\cdot)$ is identified, the standard ROC curve for $h(X)$ is represented, resulting in the \dfn{efficient ROC (eROC) curve} \citep{Kauppi2016}. Arguing as before, for a fixed specificity, the classification subsets $s_t=(c_t, \infty)$ in the transformed space are univocally defined, where a subject is classified as positive if $h(x) \in s_t$ and negative otherwise (with $x$ representing its marker value). However, they may have any shape in the original space, depending on the monotonicity of the functional transformation $h(\cdot)$ \citep{Camblor2019a}. Emphasizing the importance of tracking the decision rules underlying the eROC curve, this monitoring process enables an assessment of whether the improved accuracy of the marker justifies the potential loss in interpretability.

The ROC curve is defined for classification accuracy evaluation of univariate markers. To deal with multivariate markers, the usual practice is to consider a transformation $\boldsymbol{h}(\cdot)$ to reduce it to a univariate one, and then to construct the standard ROC curve. Same considerations as before apply when a functional transformation is taken. In the proposed R library, we consider methods from the literature to define and estimate $\boldsymbol{h}(\cdot)$ in the multivariate case \citep{Kang2016, Meisner2021}.


Focusing on the classification subsets underlying the decision rules, the \CRANpkg{movieROC} package incorporates methods to visualize the construction process of ROC curves by presenting the classification accuracy of these subsets. 
For univariate markers, the library includes both the classical (standard ROC curve) and the generalized (gROC curve) approach. Besides it enables the display of decision rules for various transformations of the marker, seeking to maximize performance allowing for flexibility in the final shape of the subsets (eROC curve). For multidimensional markers, the proposed tool visualizes the evolution of decision subsets when different objective functions are employed for optimization, even imposing restrictions on the underlying regions. In this case, displaying the decision rules associated with every specificity in a single static image is no longer feasible. Therefore, \dfn{dynamic representations} (videos) are implemented, drawing on time as an extra dimension to capture the variation in specificity. 

Much software available in R could be discussed here covering diverse topics related to ROC curves: 
the \CRANpkg{pROC} package is a main reference including tools to visualize, estimate and compare ROC curves \citep{pROC2011}; 
\CRANpkg{ROCnReg} explicitly considers covariate information to estimate the covariate-specific and the covariate-adjusted ROC curves \citep{ROCnReg2021}; 
\pkg{smoothROCtime} implements smooth estimation of time-dependent ROC curves based on the bivariate kernel density estimator for $(X, \textit{time-to-event})$ \citep{DiazCoto2020};
\CRANpkg{OptimalCutpoints} includes point and interval estimation methods for optimal thresholds \citep{OptimalCutpoints2014};
and \CRANpkg{nsROC} performs non-standard analysis such as gROC estimation \citep{nsROC2018}; among others.

\medskip

This paper introduces and elucidates the diverse functionalities of the newly developed \CRANpkg{movieROC} package, aimed at facilitating the visualization and comprehension of the decision rules underlying the binary classification process, encompassing various generalizations. Despite the availability of numerous R packages implementing related analyses, we have identified the main gaps covered in this library: tracking the decision rules underlying the ROC curve, including multivariate markers and non-standard scenarios (i.e. non-monotonous). The rest of the paper is structured as follows. In Section~\ref{section:functionality}, we introduce the main R functions and objects implemented, and briefly explain the dataset employed throughout this manuscript to demonstrate the utility of the R library. Section~\ref{section:regularroc} is devoted to reconsidering the definition of the standard ROC curve from the perspective of classification subsets, including an extension to multivariate scenarios. Sections~\ref{section:groc} and \ref{section:efficientroc} revisit the gROC curve and the eROC curve, respectively, covering various methods to capture the potential classification accuracy of the marker under study. 
Each of these sections begins with a state-of-the-art overview, followed by the main syntax of the corresponding R functions. In addition, examples of implementation using the dataset presented in Section \ref{subsection:dataset} are provided. Finally, the paper concludes with a concise summary and computational details regarding the implemented tool. 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Main functions of the movieROC package and illustrative dataset}\label{section:functionality}

Sections~\ref{subsec:functionality} and \ref{subsec:functions} provide a detailed description of the main objectives of the implemented R functions. To reflect the practical usage of the developed R package, we employ a real dataset throughout this manuscript, which is introduced in Section~\ref{subsection:dataset}.



\subsection{Functionality of the movieROC package} \label{subsec:functionality}

A graphical tool was developed to showcase static and dynamic graphics displaying the classification subsets derived from maximizing diagnostic accuracy under certain assumptions, ensuring the preservation of the interpretability. The R package facilitates the construction of the ROC curve across various specificities, providing visualizations of the resulting classification regions. The proposed tool comprises multiple R functions that generate objects with distinct class attributes (see function names where red arrows depart from and red nodes in Figure~\ref{figure:functionality}, respectively). Once the object of interest is created, different methods may be used, in order to plot the underlying regions (\code{plot\_regions()}, \code{plot\_funregions()}), to track the resulting ROC curve (\code{plot\_buildROC()}, \code{plot()}), to \code{predict} decision rules for a particular specificity, and to \code{print} relevant information, among others. The main function of the package, \code{movieROC()}, produces videos to exhibit the classification procedure.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{figures/movieROC_mainFunctions.pdf}
  \includegraphics[width=.8\textwidth]{figures/movieROC_extraFunctions.pdf}
  \caption{R functions of the \CRANpkg{movieROC} package. The blue nodes include the names of the R functions and the red nodes indicate the different R objects that can be created and worked with. The red arrows depart from those R functions engaged in creating R objects and the black arrows indicate which R functions can be applied to which R objects. The grey dashed arrows show internal dependencies.}
  \label{figure:functionality}
\end{figure}

It includes algorithms to visualize the regions that underlie the binary classification problem, considering different approaches:
\begin{itemize}
\item make the classification subsets flexible in order to cover non-standard scenarios, by considering two cut-off values (\code{gROC()} function); explained in Section~\ref{section:groc};
\item transform the marker by a proper function $h(\cdot)$ (\code{hROC()} function); introduced in Section~\ref{section:efficientroc};
\item when dealing with multivariate markers, consider a functional transformation with some fixed or dynamic parameters resulting from different methods available in the literature (\code{multiROC()} function); covered in Section~\ref{section:multiroc}.
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Class methods for \pkg{movieROC} objects} \label{subsec:functions}

By using the \code{gROC()}, the \code{multiROC()} or the \code{hROC()} function, the user obtains an R object of class `\code{groc}', `\code{multiroc}' or `\code{hroc}', respectively. These will be called \CRANpkg{movieROC} objects. Once the object of interest is created, the implemented package includes many functions (methods) to pass to it. Some of them are generic methods (\code{print()}, \code{plot()} and \code{predict()}), commonly used in R language over different objects according to their class attributes. The rest of the functions are specific for this library and therefore only applicable to \CRANpkg{movieROC} objects. Table~\ref{table:funcmovieROC} summarizes all these functions and provides their target and main syntax (with default input parameters).

\begin{table}[H]
 \renewcommand{\arraystretch}{1.5}
{\footnotesize
\begin{tabular}{@{}p{2cm}|p{11.6cm}@{}}
\toprule
\multicolumn{2}{c}{Generic functions}\\
\hline
\centering \code{print()} & Print some relevant information.\\
\centering \code{plot()} & Plot the ROC curve estimate.\\
\centering \code{predict()} & Print the classification subsets corresponding to a particular false-positive rate (\code{FPR}) introduced by the user. For a `\code{groc}' object, the use may specify a cut-off value \code{C} (for the standard ROC curve) or two cut-off values \code{XL} and \code{XU} (for the gROC curve).\\
\bottomrule
\end{tabular}
\begin{tabular}{@{}p{2.3cm}|p{11.3cm}@{}}
\toprule
\multicolumn{2}{c}{Specific functions}\\
\hline
\centering \code{plot\_regions()} & Applicable to a `\code{groc}' or a `\code{hroc}' object. \par \vspace{1mm}
Plot two graphics in the same figure: left, classification subsets for each false-positive rate (grey color by default); right, $90^\circ$ rotated ROC curve. \par \vspace{1mm}
\textsc{Main syntax:} \par \hspace{3mm}
\code{plot\_regions(obj, plot.roc = TRUE, plot.auc = FALSE, FPR = 0.15, ...)} \par \vspace{1mm}
If the input parameter \code{FPR} is specified, the corresponding classification region reporting such false-positive rate and the point in the ROC curve are highlighted in blue color.\\

\centering \code{plot\_funregions()} & Applicable to a `\code{groc}' or a `\code{hroc}' object. \par \vspace{1mm}
Plot the transforming function and the classification subsets reporting the false-positive rate(s) indicated in the input parameter(s) \code{FPR} and \code{FPR2}. \par \vspace{1mm}
\textsc{Main syntax:} \par \hspace{3mm} 
\code{plot\_funregions(obj, FPR = 0.15, FPR2 = NULL, plot.subsets = TRUE, ...)}\\

\centering \code{plot\_buildROC()} & Applicable to a `\code{groc}' or a `\code{multiroc}' object. \par \vspace{2mm}
- For a `\code{groc}' object: \par \vspace{1mm}
Plot four (if input \code{reduce} is FALSE) or two (if \code{reduce} is TRUE, only those on the top) graphics in the same figure: top-left, density function estimates for the marker in both populations with the areas corresponding to FPR and TPR colored (blue and red, respectively) for the optional input parameter \code{FPR}, \code{C} or \code{XL, XU}; top-right, the empirical ROC curve estimate; bottom-left, boxplots in both groups; bottom-right, classification subsets for every FPR (grey color). \par \vspace{1mm}
\textsc{Main syntax:} \par \hspace{3mm} 
\code{plot\_buildROC(obj, FPR = 0.15, C, XL, XU, h = c(1,1), histogram = FALSE, breaks = 15,} \linebreak  \hspace*{2.3cm} \code{reduce = TRUE, build.process = FALSE, completeROC = FALSE,  ...)} \par \vspace{1mm}
If \code{build.process} is FALSE, the whole ROC curve is displayed; otherwise, if \code{completeROC} is TRUE, the portion of the ROC curve until the fixed FPR is highlighted in black and the rest is shown in gray, while if \code{completeROC} is FALSE, only the first portion of the curve is displayed.\par \vspace{2mm}
- For a `\code{multiroc}' object: \par \vspace{1mm}
Plot two graphics in the same figure: right, the ROC curve highlighting the point and the threshold for the resulting univariate marker; left, scatterplot with the marker values in both positive (red color) and negative (blue color) subjects
\begin{itemize}
\item for $p=2$: over the original/feature bivariate space;
\item for $p>2$: projected over two selected components of the marker (if \code{display.method = "OV"} with components selection in \code{displayOV}, \code{c(1,2)} by default) or the first two principal components from PCA (if \code{display.method = "PCA"}, default);
\end{itemize}
and the classification subset (gold color) reporting the \code{FPR} selected by the user (\code{FPR} $\neq$ \code{NULL}). \par \vspace{1mm}
\textsc{Main syntax:}
\begin{itemize}
\item for $p=2$: 
\item[] \code{plot\_buildROC(obj, FPR = 0.15, build.process = FALSE, completeROC = TRUE,  ...)}
\item for $p>2$: 
\item[] \code{plot\_buildROC(obj, FPR = 0.15, display.method = c("PCA","OV"), displayOV = } \linebreak  \hspace*{2cm} \code{c(1,2), build.process = FALSE, completeROC = TRUE,  ...)}
\end{itemize}
If \code{build.process} is FALSE, the whole ROC curve is displayed; otherwise, if \code{completeROC} is TRUE, the portion of the ROC curve until the fixed FPR is highlighted in black and the rest is shown in gray, while if \code{completeROC} is FALSE, only the first portion of the curve is shown.\\

\centering \code{movieROC()} & Applicable to a `\code{groc}' or a `\code{multiroc}' object. \par \vspace{2mm}
Save a video as a GIF illustrating the construction of the ROC curve. \par \vspace{1mm}
- For a `\code{groc}' object: \par \vspace{1mm}
\textsc{Main syntax:} \par \hspace{3mm}
\code{movieROC(obj, fpr=NULL, h=c(1,1), histogram = FALSE, breaks = 15, reduce = TRUE,} \linebreak  \hspace*{1.6cm} \code{completeROC = FALSE, videobar = TRUE, file = "animation1.gif", ...)} \par \vspace{1mm}
For each element in vector \code{fpr} (optional input parameter), the function executed is \code{plot\_buildROC(obj, FPR = fpr[i], build.process = TRUE, ...)}. The vector of false-positive rates illustrated in the video is \code{NULL} by default: if length of output parameter \code{t} for \code{gROC()} function is lower than 150, such vector is taken as \code{fpr}; otherwise, an equally-space vector of length 100 covering the range of the marker values is considered. 
\end{tabular}
}
\end{table}


\begin{table}[h!]
 \renewcommand{\arraystretch}{1.5}
{\footnotesize
\begin{tabular}{@{}p{2.3cm}|p{11.3cm}@{}}
\phantom{\centering \code{plot\_buildROC()}} & 
- For a `\code{multiroc}' object: \par \vspace{1mm}
\textsc{Main syntax:}
\begin{itemize}
\item for $p=2$: 
\item[] \code{movieROC(obj, fpr = NULL, file = "animation1.gif", save = TRUE, border = TRUE,} \par \hspace*{1.2cm} \code{completeROC = FALSE, ...)};
\item for $p>2$: 
\item[] \code{movieROC(obj, fpr = NULL, display.method = c("PCA","OV"), displayOV = c(1,2),} \par 
\hspace*{1.2cm} \code{file = "animation1.gif", save = TRUE, border = TRUE, } \par 
\hspace*{1.2cm} \code{completeROC = FALSE, ...)}. 
\end{itemize}
The video is \code{save}d by default as a GIF with the name indicated in argument \code{file} (extension \code{.gif} should be added). A \code{border} for the classification subsets is drawn by default.\par \vspace*{1mm}
For each element in vector \code{fpr} (optional input parameter), the function executed is
\begin{itemize}
\item for $p=2$: 
\item[] \code{plot\_buildROC(obj, FPR = fpr[i], build.process = TRUE, completeROC, ...)};
\item for $p>2$: 
\item[] \code{plot\_buildROC(obj, FPR = fpr[i], build.process = TRUE, display.method,} \par  \hspace*{1.9cm} \code{displayOV, completeROC, ...)}
\end{itemize}

Same considerations about the input \code{fpr} as those for \code{movieROC()} over a `\code{groc}' object.\\
\bottomrule
\end{tabular}
}
\caption{Methods for a \CRANpkg{movieROC} object: `\code{groc}', `\code{multiroc}' or `\code{hroc}' object (output of the \code{gROC()}, \code{multiROC()} or \code{hROC()} function, respectively). The main input parameters are displayed.\label{table:funcmovieROC}}
\end{table}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Illustrative dataset} \label{subsection:dataset}

In order to illustrate the functionality of our R package, we consider the \code{HCC} data. This dataset is derived from gene expression arrays of tumor and adjacent non-tumor tissues of 62 Taiwanese cases of hepatocellular carcinoma (HCC). The goal of the original study \citep{Shen2012} was to identify, with a genome-wide approach, additional genes hypermethylated in HCC that could be used for more accurate analysis of plasma DNA for early diagnosis, by using Illumina methylation arrays (Illumina, Inc., San Diego, CA) that screen 27,578 autosomal CpG sites. The complete dataset was deposited in NCBI’s Gene Expression Omnibus (GEO) and it is available through series accession number GSE37988 (\url{www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE37988}). It is included in the presented package (\code{HCC} dataset), selecting 948 genes with complete information.

The following code loads the R package and the \code{HCC} dataset (see the \href{https://cran.r-project.org/web/packages/movieROC/vignettes/movieROC_vignette.pdf}{vignette} for main structure).
\begin{example}
R> library(movieROC)
R> data(HCC)
\end{example}

We selected the genes 20202438, 18384097, and 03515901. On the one hand, we chose the gene 03515901 as an example of a monotone relationship between the marker and the response, reporting a good ROC curve. On the other hand, relative gene expression intensities of the genes 20202438 and 18384097 tend to be more extreme in tissues with tumor than in those without it. These are non-standard cases, so if we limit ourselves to detect ``appropriate'' genes on the basis of the standard ROC curve, they would not be chosen. However, extending the decision rules by means of the gROC curve, those genes may be considered as potential biomarkers (locations) to differ between the two groups. The R code estimating and displaying the density probability function for gene expression intensities of the selected genes in each group (Figure~\ref{fig:densities}) is included in the \href{https://cran.r-project.org/web/packages/movieROC/vignettes/movieROC_vignette.pdf}{vignette}.


\begin{figure}[h!] 
\includegraphics[width=\textwidth,trim={0 4mm 0 2mm},clip]{figures/Histogram_3genes.pdf}
  \caption{Density histograms and kernel density estimations (lighter) for gene expression intensities of the genes 20202438, 18384097 and 03515901 in negative (non-tumor) and positive (tumor) tissues.}
  \label{fig:densities}
\end{figure}



\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Regular ROC curve} \label{section:regularroc}

Assuming that there exists a monotone relationship between the marker and the response, the \dfn{regular, right-sided} or \dfn{standard ROC curve} associated with the marker $X$ considers classification subsets of the form $s_t=(c_t,\infty)$. 
For each specificity $1-t=\P(\chi \notin s_t) \in [0,1]$, also called \dfn{true-negative rate}, there exists only one subset $s_t$ reporting such specificity and thus a particular sensitivity, also called \dfn{true-positive rate}, $\P(\xi \in s_t)$. 
This results in a simple correspondence between each point of the ROC curve $\mathcal{R}_r(t) = 1-F_\xi \big(F_\chi^{-1}(1-t)\big)$ and its associated classification region $s_t \in \mathcal{I}_r(t)$, where
$$\mathcal{I}_r(t) = \Big\{ s_t = (c_t, \infty) \mbox{ : } c_t \in \mathcal{S}(X) \mbox{ , } \P(\chi \in s_t) = t \Big\}$$
is the \dfn{right-sided family of eligible classification subsets}. The definition of this family captures the shape of the decision rules and the target specificity.

If higher values of the marker are associated with a higher probability of not having the characteristic (see gene 03515901 in Figure~\ref{fig:densities}), the ROC curve would be defined by the \dfn{left-sided family of eligible classification subsets} \citep{Camblor2017a}, $\mathcal{I}_l(t)$, similarly to $\mathcal{I}_r(t)$ but with the form $s_t = (\infty, c_t]$.
%$$\mathcal{I}_l(t) = \Big\{ s_t = (\infty, c_t] \mbox{ : } c_t \in \mathcal{S}(X) \mbox{ , } \P(\chi \in s_t) = t \Big\},$$
It results in $\mathcal{R}_l(t) = F_\xi \big(F_\chi^{-1}(t) \big)$, $t\in[0,1]$, and the decision rules are also univocally defined in this case.

\medskip

The ROC curve and related problems were widely studied in the literature; interested reader is referred to the monographs of \citet{Zhou2002}, \citet{Pepe2003a}, and \citet{Nakas2023}, as well as the review by \citet{Inacio2021}.
By definition, the ROC curve is confined within the unit square, with optimal performance achieved when it approaches the left-upper corner (AUC closer to 1). Conversely, proximity to the main diagonal (AUC closer to 0.5) means diminished discriminatory ability, resembling a random classifier.

\medskip

In practice, let $(\xi_1, \xi_2, \dots, \xi_n)$  and $(\chi_1, \chi_2, \dots, \chi_m)$ be two independent and identically distributed (i.i.d.) samples from the positive and the negative population, respectively. Different estimation procedures are implemented in the \CRANpkg{movieROC} package, such as the empirical estimator \citep{Hsieh1996} (by default in the \code{gROC()} function), accompanied by its summary indices: the AUC and the Youden index \citep{Youden1950}. Alternatively, semiparametric approaches based on kernel density estimation for the involved distributions may be considered \citep{Zou1997}. The \code{plot\_densityROC()} function provides plots for both right- and left-sided ROC curved estimated by this method. On the other hand, assuming that the marker follows a gaussian distribution in both populations, that is, $\xi \sim \mathcal{N}(\mu_\xi, \sigma_\xi)$ and $\chi \sim \mathcal{N}(\mu_\chi, \sigma_\chi)$, parametric approaches propose plug-in estimators by estimating the unknown parameters while using the known distributions \citep{Hanley1988}. This parametric estimation is included in the \code{gROC\_param()} function, which works similarly to \code{gROC()}.

\medskip

\textsc{Main syntax:} \par \hspace{3mm}
\code{gROC(X, D, side = "right", ...)} \hspace{8mm} \code{gROC\_param(X, D, side = "right", ...)}

\medskip

\noindent Table 1 in the \href{https://cran.r-project.org/web/packages/movieROC/vignettes/movieROC_vignette.pdf}{vignette} provides the main input and output parameters of these R functions, which estimate the regular ROC curve (right-sided of left-sided with \code{side = "right"} or \code{"left"}, respectively) and associated decision rules. Its output is an R object of class `\code{groc}`, to which the functions listed in Table~\ref{table:funcmovieROC} above can be applied. Most of them are visualization tools, but the user may also \code{print()} summary information and \code{predict()} classification regions for a particular specificity.

\medskip

Figure~\ref{fig:roccurves} graphically represents the empirical estimation of the standard (gray line) and generalized (black line) ROC curves for each gene in Figure~\ref{fig:densities}. To construct the standard ROC curve for the first two genes (20202438 and 18384097), the right-sided ROC curve is considered; and the left-sided curve for the third one (03515901). As expected following the discussion about Figure~\ref{fig:densities}, the standard and gROC curves are similar for the third gene because there exists a monotone relationship between the marker and the response. However, these curves differ for the first two genes due to the lack of monotonicity in those scenarios. The empirical gROC curve estimator is explained in detail in Section~\ref{section:groc}.

\noindent Next chunk of code generates the figure, providing as example of the use of \code{gROC()} function, \code{plot()} and how to get access to the AUC.

\begin{example}
R> for(gene in c("20202438", "18384097", "03515901")){
+   roc <- gROC(X = HCC[,paste0("cg",gene)], D = HCC$tumor, 
+               side = ifelse(gene == "03515901", "left", "right"))
+   plot(roc, col = "gray50", main = paste("Gene", gene), lwd = 3)
+   groc <- gROC(X = HCC[,paste0("cg",gene)], D = HCC$tumor, side = "both")
+   plot(groc, new = FALSE, lwd = 3)
+   legend("bottomright", paste(c("AUC =", "gAUC ="), format(c(roc$auc, groc$auc), 
+          digits = 3)), col = c("gray50", "black"), lwd = 3, bty = "n", inset = .01)}
\end{example}

\begin{figure}[h!]
  \centering
  \includegraphics[width=.95\textwidth,trim={0 3mm 0 5mm},clip]{figures/ROCcurves_3genes.pdf}
  \caption{Standard ROC curve (in gray) and gROC curve (in black) empirical estimation for the capacity of genes 20202438, 18384097 and 03515901 to differ between tumor and non-tumor group.}
  \label{fig:roccurves}
\end{figure}


The following code snippet estimates the standard ROC curve for gene 20202438, prints its basic information, and predicts the classification region and sensitivity resulting in a specificity of 0.9. It provides an illustrative example of utilizing the \code{print()} and \code{predict()} functions.


\begin{example}
R> roc_selg1 <- gROC(X = HCC$cg20202438, D = HCC$tumor, side = "right")
R> roc_selg1
\end{example}
\vspace*{-3mm}
{\color{darkgray!80}
\begin{example}
Data was encoded with nontumor (controls) and tumor (cases).
It is assumed that larger values of the marker indicate larger confidence that a 
 given subject is a case.
There are 62 controls and 62 cases.
The specificity and sensitivity reported by the Youden index are 0.855 and 0.403, 
 respectively, corresponding to the following classification subset: (0.799, Inf).
The area under the right-sided ROC curve (AUC) is 0.547.
\end{example}
}

\begin{example}
R> predict(roc_selg1, FPR = .1)
\end{example}
\vspace*{-3mm}
{\color{darkgray!80}
\begin{example}
$ClassSubsets			$Specificity		$Sensitivity
[1] 0.8063487   Inf		[1] 0.9032258		[1] 0.3064516
\end{example}
}

\medskip

%Figure~\ref{fig:classproc_roc} was generated by \code{plot\_densityROC()} and \code{plot\_buildROC()} functions as follows. These R functions compute the kernel density estimation and the empirical ROC curve estimate, respectively. The second graphic can be seen as a snapshot from the videos generated by the \code{movieROC()} function.

%\begin{figure}[h!]
%  \centering
%  \includegraphics[width=.45\textwidth]{figures/plot_densityROC_gene20202438.pdf} \hspace*{4mm}
%  \includegraphics[width=.46\textwidth,trim={0 4mm 0 0mm},clip]{figures/plotbuildROC_gene20202438.pdf}
%  \caption{Classification procedure until cut-off value 0.77 for the gene 20202438 by using the \code{plot\_densityROC()} (left) and the \code{plot\_buildROC()} (right) function.}
%  \label{fig:classproc_roc}
%\end{figure}

%\begin{example}
%R> plot_densityROC(roc_selg1, C = .77, build.process = TRUE)
%R> plot_buildROC(roc_selg1, C = .77, build.process = TRUE, reduce = FALSE)
%\end{example}


\noindent The following line of code displays the whole construction of the empirical standard ROC curve for gene 20202438. The video is saved by default as a GIF with the name provided.
\begin{example}
R> movieROC(roc_selg1, reduce = FALSE, file = "StandardROC_gene20202438.gif")
\end{example}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Multivariate ROC curve} \label{section:multiroc}

In practice, many cases may benefit from combining information from different markers to enhance classification accuracy. Rather than assessing univariate markers separately, taking the multivariate marker resulting from merging them can yield relevant gain. However, note that the ROC curve and related indices are defined only for univariate markers, as they require the existence of a total order. To address this limitation, a common approach involves transforming the $p$-dimensional multivariate marker $\boldsymbol{X}$ into a univariate one through a functional transformation $\boldsymbol{h}: \mathbb{R}^p \longrightarrow \mathbb{R}$. This transformation $\boldsymbol{h}(\cdot)$ seeks to optimize an objective function related to the  classification accuracy, usually the AUC \citep{Su1993, McIntosh2002, Camblor2019a}.

We enumerate the methods included in the proposed R tool by the \code{multiROC()} function (with the input parameter \code{method}), listed according to the objective function to optimize. Recall that the output of \code{multiROC()} is an object of class `\code{multiroc}`, containing information about the estimation of the ROC curve and subsets for multivariate scenarios. Table 2 in the \href{https://cran.r-project.org/web/packages/movieROC/vignettes/movieROC_vignette.pdf}{vignette} includes the usage of this function.

\textsc{Main syntax:}  \par \hspace{3mm}
\code{multiROC(X, D, method = "lrm", }  \par \hspace{1.8cm}
\verb"formula = 'D ~ X.1 + I(X.1^2) + X.2 + I(X.2^2) + I(X.1*X.2)'" \code{, ...)}


\begin{itemize}
\item[1.-] AUC: Different procedures to estimate the $\boldsymbol{h}(\cdot)$ maximizing the AUC in the multidimensional case have been studied in the literature. Among all families of functions, linear combinations ($\mathcal{L}_{\boldsymbol{\beta}}(\boldsymbol{X}) = \beta_1 X_1 + \dots + \beta_p X_p$) are widely used due to their simplicity; an extensive review of the existing methods was conducted by \citet{Kang2016}. 
\item[] Computation: In the \code{multiROC()} function, fixing input parameters \code{method = "fixedLinear"} and \code{methodLinear} to one from \code{"SuLiu"} \citep{Su1993}, \code{"PepeThompson"} \citep{Pepe2000}, or \code{"minmax"} \citep{Liu2011}. The R function also admits quadratic combinations when $p=2$, i.e. $\mathcal{Q}_{\boldsymbol{\beta}}(\boldsymbol{X}) = \beta_1 X_1 + \beta_2 X_2 + \beta_3 X_1 X_2 + \beta_4 X_1^2 + \beta_5 X_2^2$, by fixing \code{method = "fixedQuadratic"} for a particular \code{coefQuadratic} $= \boldsymbol{\beta} = (\beta_1, \dots, \beta_5)$.
\item[2.-] The risk score function $\mbox{logit} \left\{ \P(D = 1 \, | \, \boldsymbol{X}) \right\}$: Our package allows the user to fit a logistic regression model (\code{method = "lrm"}) considering any family of functions (linear, quadratic, whether considering interactions or not...) by means of the input parameter \code{formula.lrm}. A stepwise regression model is fitted if \code{stepModel = TRUE}. Details are explained in Section~\ref{section:efficientroc}.
\item[3.-] The sensitivity for a particular specificity: 
\begin{itemize}
\item[a)] Considering the theoretical discussion about the search of the optimal transformation $\boldsymbol{h}(\cdot)$ pointed out in Section~\ref{section:efficientroc}, \citet{Camblor2021b} proposed to estimate it by multivariate kernel density estimation for positive and negative groups separately. 
\item[] Computation: The \code{multiROC()} function integrates the estimation procedures for the bandwidth matrix developed by \citet{Duong2007}, by fixing \code{method = "kernelOptimal"} and choosing a proper method to estimate the bandwidth (\code{"kernelOptimal.H"}).
\item[b)] Mainly linear combinations have been explored to date in the scientific literature \citep{Meisner2021,PerezFernandez2020}. For a fixed specificity $t\in[0,1]$, we seek the linear combination $\mathcal{L}_{\boldsymbol{\beta}(t)}(\boldsymbol{X}) = \beta_1(t) X_1 + \dots + \beta_p(t) X_p$ maximizing the true-positive rate by considering standard subsets for the transformed marker. 
The coefficients $\boldsymbol{\beta}(t)$ are called `dynamic parameters' because they may be different for each $t \in [0,1]$.
\item[] Computation: Since our objective is to display the ROC curve, $\mathcal{L}_{\boldsymbol{\beta}(t)}(\boldsymbol{X})$ is estimated for every $t$ in a grid of the unit interval, resulting in one $\boldsymbol{\hat{\beta}}(t)$ for each $t$. This approach is time-consuming, especially when it is based on the plug-in empirical estimators involved (\code{method = "dynamicEmpirical"}, only implemented for $p=2$), and may result in overfitting. Instead, \citet{Meisner2021} method is recommended (\code{method = "dynamicMeisner"}).
\end{itemize}
\end{itemize}


Once the classification subsets for a multivariate marker are constructed by the \code{multiROC()} function, several R methods may be used for the output object (see Table~\ref{table:funcmovieROC}). They include \code{print} relevant information or \code{plot} the resulting ROC curve. The main contribution of the package is to plot the construction of the ROC curve together with the classification subsets in static figure for a particular FPR (\code{plot\_buildROC()} function), or in a video for tracking the whole process (\code{movieROC()} function).

\medskip

Figure~\ref{fig:biroc} illustrates snapshots of videos resulting from \code{movieROC()} function for two FPR: $0.1$ and $0.55$. Particularly, classification accuracy of the bivariate marker \code{(cg20202438, cg18384097)} was studied by using four different approaches indicated on the captions, considering linear combinations (top) and nonlinear transformations (bottom). This figure was implemented by the code below, integrating \code{multiROC()} and \code{movieROC()} functions. Four videos are saved as GIF files with names \code{"PepeTh.gif"} (a), \code{"Meisner.gif"} (b), \code{"LRM.gif"} (c), and \code{"KernelDens.gif"} (d).

\begin{figure}[h!]
    \begin{subfigure}{0.49\textwidth}
          \includegraphics[width=\linewidth,page=1]{figures/movieROC_g1g2_PT.pdf}
          \includegraphics[width=\linewidth,page=2]{figures/movieROC_g1g2_PT.pdf}
        \caption{Linear combinations with fixed parameters by \citet{Pepe2000}.}
    \end{subfigure} \hspace{0.01\textwidth}
    \begin{subfigure}{0.49\textwidth}
              \includegraphics[width=\linewidth,page=1]{figures/movieROC_g1g2_Meis.pdf}
              \includegraphics[width=\linewidth,page=2]{figures/movieROC_g1g2_Meis.pdf}
        \caption{Linear combinations with dynamic parameters by \citet{Meisner2021}.}
    \end{subfigure}
    
\end{figure}
    
\begin{figure}[h!]\ContinuedFloat
        \begin{subfigure}{0.49\textwidth}
          \includegraphics[width=\linewidth,page=1]{figures/movieROC_g1g2_lrm.pdf}
          \includegraphics[width=\linewidth,page=2]{figures/movieROC_g1g2_lrm.pdf}
        \caption{Logistic regression model with quadratic formula by default (see \code{formula.lrm} in Table 2 of the \href{https://cran.r-project.org/web/packages/movieROC/vignettes/movieROC_vignette.pdf}{vignette}). \hspace*{2cm}}
    \end{subfigure} \hspace{0.01\textwidth}
    \begin{subfigure}{0.49\textwidth}
              \includegraphics[width=\linewidth,page=1]{figures/movieROC_g1g2_optimalT.pdf}
              \includegraphics[width=\linewidth,page=2]{figures/movieROC_g1g2_optimalT.pdf}
        \caption{Optimal transformation by multivariate kernel density estimation with \code{"Hbcv"} method by default \citep{Camblor2021b}.}
    \end{subfigure}
    
         \vspace*{-1mm}
     
\caption{Snapshots (from \code{movieROC()} videos) of the classification procedure and ROC curve for the bivariate marker \code{(cg20202438, cg18384097)} when false-positive rate equals 0.1 (top of each subfigure) and 0.55 (bottom of each subfigure). Four different methods for classification are displayed.}
\label{fig:biroc}
\end{figure}

\begin{example}
R> X <- HCC[ ,c("cg20202438", "cg18384097")]; D <- HCC$tumor
R> biroc_12_PT <- multiROC(X, D, method = "fixedLinear", methodLinear = "PepeThompson")
R> biroc_12_Meis <- multiROC(X, D, method = "dynamicMeisner", verbose = TRUE)
R> biroc_12_lrm <- multiROC(X, D)
R> biroc_12_kernel <- multiROC(X, D, method = "kernelOptimal")
R> list_biroc <- list(PepeTh = biroc_12_PT, Meisner = biroc_12_Meis, 
+	     	LRM = biroc_12_lrm, KernelDens = biroc_12_kernel)
R> lapply(names(list_biroc), function(x) movieROC(list_biroc[[x]],  
+           display.method = "OV", xlab = "Gene 20202438", ylab = "Gene 18384097", 
+           cex = 1.2, alpha.points = 1, lwd.curve = 4, file = paste0(x, ".gif")))
\end{example}


\bigskip

When the marker has a dimension higher than two it is difficult to visualize the data and the classification regions. Therefore, the \code{movieROC()} function offers two options for showing the results, both on a bidimensional space. On the one hand, to choose two of the components of the multivariate marker and project the classification subsets on the plain defined by them (Figure~\ref{fig:multiroccurve}, middle). On the other, to project the classification regions on the plain defined by the two first principal components (Figure~\ref{fig:multiroccurve}, left).
The R function \code{prcomp()} from \pkg{stats} is used to perform Principal Components Analysis (PCA) \citep{Hotelling1933}. 

Figure~\ref{fig:multiroccurve} shows the difficulty in displaying the decision rules when $p>2$ (the 3 genes used along this manuscript), even with the two options implemented in our package. It was generated using \code{multiROC()} and \code{plot\_buildROC()}:

\begin{example}
R> multiroc_PT <- multiROC(X = HCC[ ,c("cg20202438", "cg18384097", "cg03515901")], 
+                 D = HCC$tumor, method = "fixedLinear", methodLinear = "PepeThompson")
R> multiroc_PT
\end{example}
\vspace*{-3mm}
{\color{darkgray!80}
\begin{example}
Data was encoded with nontumor (controls) and tumor (cases).
There are 62 controls and 62 cases.
A total of 3 variables have been considered.
A linear combination with fixed parameters estimated by PepeThompson approach has 
 been considered.
The specificity and sensitivity reported by the Youden index are 0.855 and 0.742, 
 respectively, corresponding to the cut-off point -0.0755 for the transformation 
 h(X) =  0.81*cg20202438 - 0.1*cg18384097 - 1*cg03515901.
The area under the ROC curve (AUC) is 0.811.
\end{example}
}
\vspace*{-2mm}
\begin{example}
R> plot_buildROC(multiroc_PT, cex = 1.2, lwd.curve = 4)
R> plot_buildROC(multiroc_PT, display.method = "OV", displayOV = c(1,3), cex = 1.2,
+                xlab = "Gene 20202438", ylab = "Gene 03515901", lwd.curve = 4)
\end{example}
\begin{figure}[h!]
  \centering
  \includegraphics[height=4.6cm,page=1,trim={0 4mm 12.5cm 0},clip]{figures/buildROC_multi3.pdf}
  \includegraphics[height=4.6cm,page=2,trim={0 4mm 0 0},clip]{figures/buildROC_multi3.pdf}
  \caption{Multivariate ROC curve estimation for the simultaneous diagnostic accuracy of genes 20202438, 18384097 and 03515901. \citet{Pepe2000} approach was used to estimate the linear coefficients and classification rules (yellow and gray border for positive and negative class, respectively) for a FPR 0.15 are displayed. Left, projected over the 2 principal components from PCA; middle, over the 1st and the 3rd selected genes.}
  \label{fig:multiroccurve}
\end{figure}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generalized ROC curve} \label{section:groc}

There are scenarios whose standard ROC curves are not concave (first two genes in Figure~\ref{fig:roccurves}, gray solid line), reflecting that the standard initial assumption of existence of a monotone relationship between the marker and the response is misleading. In Figure~\ref{fig:densities}, we may see that difference in gene 20202438 distribution between those tissues who have the characteristic and those who do not is mainly on dispersion. To accommodate this common type of scenarios, \citet{Camblor2017a} extended the ROC curve definition to the case where both extremes for marker values are associated with a higher risk of having the characteristic of interest, by considering the \dfn{both-sided family of eligible classification subsets}:
$$\mathcal{I}_g(t) = \Big\{ s_t = (-\infty,x_t^L] \cup (x_t^U, \infty) \mbox{ : } x_t^L \leq x_t^U \in \mathcal{S}(X) \mbox{ , } \P(\chi \in s_t) = t \Big\}.$$

\noindent It becomes crucial to consider the supremum in the definition of the generalized ROC curve because the decision rule for each $t \in [0,1]$ is not univocally defined: there exist infinite pairs $x_t^L \leq x_t^U$ reporting a specificity $1-t$ (i.e. $\mathcal{I}_g(t)$ is uncountably infinite). 
Computationally, this optimization process incurs a time-consuming estimation, depending on the number of different marker values in the sample.

\medskip

After the introduction of this extension, several studies followed up regarding estimation of the gROC curve \citep{Camblor2017a, Camblor2019b} and related measures such as its area (gAUC) \citep{Camblor2021a} and the Youden index \citep{Camblor2019c, Bantis2021a}.  
By considering this generalization, another property of the classification subsets may be lost: the regions may not be self-contained over the increase in false-positive rate. It may happen that a subject is classified as a positive for a particular FPR $t_1$, but as a negative for a higher FPR $t_2$. Therefore, it is natural to establish a restriction \textit{(C)} on the classification subsets, ensuring that any subject classified as a positive for a fixed specificity (or sensitivity) will be also classified as a positive for any classification subset with lower specificity (higher sensitivity). \citet{PerezFernandez2020} proposed an algorithm to estimate the gROC curve under restriction \textit{(C)}, included in the \code{gROC()} function of the presented R package. See final Section for computational details about this algorithm implementation.

\medskip

\textsc{Main syntax:} \par \hspace{3mm}
\code{gROC(X, D, side = "both", ...)} \hspace{8mm} \code{gROC\_param(X, D, side = "both", ...)}

\medskip

\noindent Table 1 in the \href{https://cran.r-project.org/web/packages/movieROC/vignettes/movieROC_vignette.pdf}{vignette} collects the input and output parameters of the \code{gROC()} function, which estimates the gROC curve, both in the mentioned direction (\code{side = "both"}) and in the opposite, i.e. when classification subsets of the form $s_t=(x_t^L, x_t^U]$ are considered (\code{side = "both2"}). In addition, all the particular methods for a  `\code{groc}' object collected in Table~\ref{table:funcmovieROC} above may be used in this general scenario.

%\begin{table}[h!]
% \renewcommand{\arraystretch}{1.5}
%{\footnotesize
%\begin{tabular}{@{}p{1.7cm}|p{11.9cm}@{}}
%\toprule
%\multicolumn{2}{c}{Input parameters}\\
%\hline
%\centering \code{X} & Vector of marker values. \\
%\centering \code{D} & Vector of response values. Two levels; if more, the two
%first ones are used.\\
%\centering \code{side} & Type of ROC curve. One of \code{"right"} ($\mathcal{R}_r(\cdot)$), 
%\code{"left"} ($\mathcal{R}_l(\cdot)$), \code{"both"} ($\mathcal{R}_g(\cdot)$) or \code{"both2"} ($\mathcal{R}_{g'}(\cdot)$). Default: \code{"right"}.\\
%\centering \code{N} & Length of the vector of FPR used to build the ROC curve: $t \in \{ 0, 1/N, 2/N, \dots, 1 \}$. Default: \code{1000}. Only used for the \code{gROC\_param()} function.\\
%\hdashline
%\centering \code{restric} & If TRUE, the gROC curve with restriction \textit{(C)} is computed. Default: FALSE.\\
%\centering \code{optim} & If TRUE (and \code{restric = TRUE}), the computation of the optimal gROC curve under restriction \textit{(C)} is performed by using Floyd's algorithm \citep{Floyd1962}. It is computed by the \code{allShortestPaths()} function in the \CRANpkg{e1071} package. Default: TRUE.\\
%\centering \code{t0} & An integer number between 1 and $m+1$. If \code{restric = TRUE}, the restricted gROC curve is computed departing from (\code{t0}$-1$)/$m$. Default: the one reporting the Youden index.\\
%\centering \code{t0max} & If TRUE, the computation of the gROC curve under restriction \textit{(C)} is performed departing from every possible \code{t0} and the one reporting the maximum AUC is selected.\\
%\bottomrule
%\end{tabular}
%\begin{tabular}{@{}p{2cm}|p{11.6cm}@{}}
%\toprule
%\multicolumn{2}{c}{Output parameters}\\
%\hline
%\centering \code{controls, cases} & Marker values of negative and positive subjects, respectively. \\
%\centering \code{t} & Vector of false-positive rates.\\
%\centering \code{roc} & Vector of values of the ROC curve for \code{t}.\\
%\centering \code{c} & Vector of marker thresholds resulting in (\code{t}, \code{roc}) if \code{side = "right" | "left"}.\\
%\centering \code{xl, xu} & Vectors of marker thresholds resulting in (\code{t}, \code{roc}) if \code{side = "both" | "both2"}.\\
%\centering \code{auc} & Area under the curve estimate.\\
%\centering \code{a, b} & Estimates for parameters $a$ and $b$ used in ROC curve estimation: $\hat{a} = \left[ \overline{\xi_n} - \overline{\chi_m} \right]/\hat{s}_\xi$, $\hat{b} = \hat{s}_\chi / \hat{s}_\xi$. Only used for the \code{gROC\_param()} function.\\
%\centering \code{p0} & Estimate of the `central value', $\mu^*$, about to which the thresholds $x^L$ and $x^U$ are symmetrical. Only used for the \code{gROC\_param()} function.\\
%\hdashline
%\centering \code{aucfree} & Area under the curve estimate without restrictions.\\
%\centering \code{aucsi0} & gAUC under restriction \textit{(C)} departing from every false-positive rate, $FPR \in \{ 0, 1/m, \dots, 1 \}$.\\
%\bottomrule
%\end{tabular}
%}
%\caption{\color{yellow}
%Most relevant parameters of the \code{gROC()} function to estimate the standard and the gROC curve. The \code{gROC\_param()} function works similarly when the binormal scenario is assumed.}
%\label{table:gROC}
%\end{table}



Following the gene 20202438 expression intensity diagnostic accuracy is evaluated by the gROC curve without restrictions (\code{groc\_selg1} object) and under the restriction \textit{(C)} (\code{groc\_selg1\_C} object). The classification subsets and sensitivity for a specificity of $0.9$ are displayed with the \code{predict()} function.

\begin{example}
R> groc_selg1 <- gROC(X = HCC$cg20202438, D = HCC$tumor, side = "both")
R> predict(groc_selg1, FPR = .1)
\end{example}
%\begin{example}
%R> groc_selg1
%\end{example}
%\vspace*{-3mm}
%{\color{darkgray!80}
%\begin{example}
%Data was encoded with nontumor (controls) and tumor (cases).
%It is assumed that both lower and larges values of the marker indicate larger 
% confidence that a given subject is a case.
%There are 62 controls and 62 cases.
%The specificity and sensitivity reported by the Youden index are 0.694 and 0.726, 
% respectively, corresponding to the following classification subset: 
% (-Inf, 0.737) U (0.799, Inf).
%The area under the gROC curve (gAUC) is 0.765.
%\end{example}
%}

\vspace*{-3mm}
{\color{darkgray!80}
\begin{example}
$ClassSubsets			   $Specificity		 $Sensitivity	
          [,1]      [,2]		[1] 0.9032258		[1] 0.4032258	
[1,]      -Inf 0.7180623
[2,] 0.8296072       Inf		
\end{example}
}

\begin{example}
R> groc_selg1_C <- gROC(X = HCC$cg20202438, D = HCC$tumor, side = "both", 
+		       restric = TRUE, optim = TRUE)
\end{example}

\medskip

All the classification regions underlying the standard and the generalized ROC curves without and with restrictions are represented in Figure~\ref{fig:regionsgroc}. The following code was used to generate the figure, illustrating the usage and output of the \code{plot\_regions()} function. Besides displaying all the classification regions underlying every specificity (in gray), the one chosen by the user (FPR = 0.15 by default) is highlighted in blue. Note that the ROC curves are rotated $90^\circ$ to the right, in order to use the vertical axis for FPR in both plots. 
 
\begin{example}
R> plot_regions(roc_selg1, cex.legend = 1.5, plot.auc = TRUE, 
+		main = "Standard right-sided assumption [Classification subsets]")
R> plot_regions(groc_selg1, plot.auc = TRUE, legend = F, main.plotroc = "gROC curve",
+		main = "General approach [Classification subsets]")
R> plot_regions(groc_selg1_C, plot.auc = TRUE, legend = F, main.plotroc = "gROC curve",
+		main = "General approach with restriction (C) [Classific. subsets]", 
+		xlab = "Gene 20202438 expression intensity")
\end{example}

\begin{figure}[h!]
\centering
	\includegraphics[width=.91\linewidth,page=1,trim={5mm 1cm 1.2cm 3mm},clip]{figures/plotregions_gene20202438.pdf}
	\includegraphics[width=.91\linewidth,page=2,trim={5mm 1cm 1.2cm 0},clip]{figures/plotregions_gene20202438.pdf}
	\includegraphics[width=.91\linewidth,page=3,trim={5mm 2mm 1.2cm 0},clip]{figures/plotregions_gene20202438.pdf}
	\caption{Classification regions and the ROC curve (90º rotated) for evaluation of gene 20202438 expression intensity assuming i) standard scenario (top), ii) generalized scenario without restrictions (middle), iii) generalized scenario under restriction \textit{(C)} over the subsets (bottom).}
	\label{fig:regionsgroc}
\end{figure}

It is clear the gain achieved for considering the generalized scenario for this marker, which fits better its distribution in each group. Standard estimated AUC is 0.547, while the gAUC increases to 0.765. The gAUC is not especially affected by imposing the restriction \textit{(C)}, resulting in 0.762.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Efficient ROC curve: pursuing an optimal transformation} \label{section:efficientroc}

By keeping classification subsets of the form $s_t = (c_t, \infty)$, an alternative approach can be explored: transforming the univariate marker through a suitable function $h: \mathbb{R} \longrightarrow \mathbb{R}$ to enhance its accuracy. 
Henceforth, the transformation $h^*(\cdot)$ reporting the dominant ROC curve compared to the one from any other function (i.e. $\mathcal{R}_{h^*}(\cdot) \geq \mathcal{R}_h(\cdot)$) will be referred to as \dfn{optimal transformation} (in the ROC sense), and the resulting ROC curve is called eROC \citep{Kauppi2016}. Following the well-known Neyman–Pearson lemma, \citet{McIntosh2002} proved that $h^*(\cdot)$ is the likelihood ratio.

We enumerate the methods included in the proposed R tool by the \code{hROC()} function (with the input parameter \code{type}), listed according to the procedure considered to estimate $h^*(\cdot)$. The output of this function is an object of class `\code{hroc}`. See Table 3 in the \href{https://cran.r-project.org/web/packages/movieROC/vignettes/movieROC_vignette.pdf}{vignette} for function usage and output details.

\medskip

\textsc{Main syntax:}  \hspace{3mm}
\code{hROC(X, D, type = "lrm", formula.lrm =  } \verb"'D ~ pol(X,3)'" \code{, ...)}
 
\begin{itemize}
\item[1.-] \citet{Camblor2019a} exploited the result proved by \citet{McIntosh2002}, suggesting to estimate the logit of the risk function by logistic regression, since it is a monotone increasing transformation of the likelihood ratio.
\item[] Computation: By the proposed R tool, the user can define any transformation $h(\cdot)$ for the right-hand side of the logistic regression model to be fitted, $\mbox{logit} \big\{ \P(D = 1 \, | \, x) \big\} = h(x)$. Particularly, by fixing the input parameters: \code{type = "lrm"} and defining the function $h(\cdot)$ as \code{formula.lrm}.

\item[2.-] Arguing as in \citet{Camblor2021b} for univariate markers instead of multivariate, the optimal transformation in the ROC sense is equivalent to $h^*(\cdot)=f_\xi(\cdot)/\big(f_\xi(\cdot) + f_\chi(\cdot)\big)$, where $f(\cdot)$ denotes the density function.
In order to estimate $h^*(\cdot)$, different estimation procedures for the density functions separately may be used, such as the kernel density estimator.
\item[] Computation: By the \code{hROC()} function, the user may fix \code{type = "kernel"} and choosing a proper bandwidth for the kernel estimation by \code{kernel.h} in order to compute this method.

\item[3.-] \citet{Camblor2019a} also included the estimation of the \dfn{overfitting function}, $h_{of}(\cdot)$, defined as the optimal one when no restrictions on the shape of $h^*(\cdot)$ are imposed. It takes the value 1 for the positive marker values and 0 for the negative ones, reporting an estimated AUC of 1, but totally depending on the available sample (the resulting rules cannot be extended).
\item[] Computation: $h_{of}(\cdot)$ may be estimated by fixing the input parameter \code{type = "overfitting"}.
\end{itemize}



Following code and figures study the capacity of improving the classification performance of the gene 18384097 expression intensity via the above functional transformations and its impact on the final decision rules. The first one considering an ordinary cubic polynomial formula (\code{hroc\_cubic\_selg2}), and a linear tail-restricted cubic splines (\code{hroc\_rcs\_selg2}) for the right-hand side of logistic regression model. The second one using two different bandwidths ($h=1$ and $h=3$) for density function estimation. For a comparative purpose, the last one estimates the gROC curve under restriction \textit{(C)}.

\begin{example}
R> X <- HCC$cg18384097; D <- HCC$tumor
\end{example}
\begin{example}
R> hroc_cubic_selg2 <- hROC(X, D); hroc_cubic_selg2
\end{example}
\vspace*{-3mm}
{\color{darkgray!80}
\begin{example}
Data was encoded with nontumor (controls) and tumor (cases).
There are 62 controls and 62 cases.
A logistic regression model of the form D ~ pol(X,3) has been performed.
The estimated parameters of the model are the following:
 Intercept          X        X^2        X^3 
   "1.551"   "32.054" "-120.713"  "100.449" 
The specificity and sensitivity reported by the Youden index are 0.935 and 0.532, 
 respectively, corresponding to the following classification subset: 
 (-Inf, 0.442) U (0.78, Inf).
The area under the ROC curve (AUC) is 0.759.
\end{example}
}

\begin{example}
R> hroc_rcs_selg2 <- hROC(X, D, formula.lrm = "D ~ rcs(X,8)")
R> hroc_lkr1_selg2 <- hROC(X, D, type = "kernel")
R> hroc_lkr3_selg2 <- hROC(X, D, type = "kernel", kernel.h = 3)
R> hroc_overfit_selg2 <- hROC(X, D, type = "overfitting")

R> groc_selg2_C <- gROC(X, D, side = "both", restric = TRUE, optim = TRUE)
\end{example}

\medskip

The following code snippet compares the AUC achieved from each approach considered above:
\begin{example}
R> list_hroc <- list(Cubic = hroc_cubic_selg2, Splines = hroc_rcs_selg2, 
+	            Overfit = hroc_overfit_selg2, LikRatioEst_h3 = hroc_lkr3_selg2,
+	            LikRatioEst_h1 = hroc_lkr1_selg2, gAUC_restC = groc_selg2_C)
\end{example}

\clearpage

\begin{example}
R> AUCs <- sapply(list_hroc, function(x) x$auc)
R> round(AUCs, 3)
\end{example}
\vspace*{-3mm}
{\color{darkgray!80}
\begin{example}
Cubic        Splines   Overfit   LikRatioEst_h3    LikRatioEst_h1       gAUC_restC 
0.759          0.807     1.000            0.781             0.799            0.836
\end{example}
}

\medskip

The shape of the classification regions over the original space $\mathcal{S}(X)$ depends on the monotonicity of $h^*(\cdot)$, which may be graphically studied by the \code{plot\_funregions()} function (see Figure~\ref{fig:transformations}). These regions can be visualized by the R function \code{plot\_regions()} (see Figure~\ref{fig:regionshroc}). Both are explained in Table~\ref{table:funcmovieROC} and illustrated below. The next chunk of code produced Figure~\ref{fig:transformations}, representing the different functional transformations estimated previously:
\begin{example}
R> lapply(list_hroc, function(x) plot_funregions(x, FPR = .15, FPR2 = .5))
\end{example}

\vspace*{-3mm}

\begin{figure}[H]
\centering
\includegraphics[width=.85\textwidth]{figures/plotfunregions_hroc_lrm_gene18384097.pdf}
  \caption{Different functional transformations and resulting classification subsets for gene 18384097. Rules for FPR 0.15 (blue) and 0.50 (red) are remarked. Top, from left to right: cubic polynomial function, restricted cubic splines (with 8 knots), and overfitted transformation. Bottom: likelihood ratio estimation with bandwidths 3 (left) and 1 (middle), and transformation resulting in the gROC curve under restriction \textit{(C)}.}
  \label{fig:transformations}
\end{figure}

%\noindent The next chunk of code produced Figure~\ref{fig:transformations}, which represents the different functional transformations estimated previously by using the \code{plot\_funregions()} function.



Finally, using the \code{plot\_regions()} function, Figure~\ref{fig:regionshroc} shows the resulting classification subsets over the original space for the best two of the six methods above. First method (fitting a logistic regression model with restricted cubic splines with 8 knots) reports an AUC of 0.804 (compared to 0.684 by the standard ROC curve), but the shape of some classification rules is complex, such as $s_t=(-\infty,a_t] \cup (b_t,c_t] \cup (d_t,\infty)$. This area increases to 0.836 by considering subsets of the form $s_t=(-\infty,x_t^L] \cup (x_t^U,\infty)$, even imposing the restriction $\textit{(C)}$ to get a functional transformation $h(\cdot)$.


\begin{figure}[H]
\centering
	\includegraphics[width=.91\linewidth,page=1,trim={5mm 1cm 1.2cm 4mm},clip]{figures/plotregions_gene18384097.pdf}
	\includegraphics[width=.91\linewidth,page=2,trim={5mm 3mm 1.2cm 0},clip]{figures/plotregions_gene18384097.pdf}
	\caption{Classification regions and the resulting ROC curve (90º rotated) for the gene 18384097. Top, ROC curve for restricted cubic splines transformation with 8 knots; bottom, gROC curve under restriction \textit{(C)} for the original marker.}
	\label{fig:regionshroc}
\end{figure}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Summary and conclusion} \label{section:conclusion}

Conducting binary classification using continuous markers requires establishment of decision rules. In the standard case, each specificity $t \in [0,1]$ entails a classification subset of the form $s_t = (c_t,\infty)$ univocally defined. However, in more complex situations -- such as there is a non-monotone relationship between the marker and the response or in multivariate scenarios -- these become not clear. Visualization of the decision rules becomes crucial in these cases. To address this, the \CRANpkg{movieROC} package incorporates novel visualization tools complementing the ROC curve representation.

\noindent This R package offers a user-friendly and easily comprehensible software solution tailored for practical researchers. It implements statistical techniques to estimate and compare, and finally to graphically represent different classification procedures. While several R packages address ROC curve estimation, the proposed one emphasizes the classification process, tracking the decision rules underlying the studied binary classification problem. This tool incorporates different considerations and transformations which may be useful to capture the potential of the marker to classify in non-standard scenarios. Nevertheless, this library is also useful in standard cases, as well as when the marker itself comes from a classification or regression method (such as support vector machines), because it provides nice visuals and additional information not usually reported with the ROC curve.

\noindent The main function of the package, \code{movieROC()}, allows to monitor how the resulting classification subsets change along different specificities, thereby building the corresponding ROC curve. Notably, it introduces time as a third dimension to keep those specificities, generating informative videos. For interested readers or potential users of \CRANpkg{movieROC}, the \href{https://cran.r-project.org/web/packages/movieROC/movieROC.pdf}{manual} available in CRAN provides complete information about the implemented functions and their parameters. In addition, a \href{https://cran.r-project.org/web/packages/movieROC/vignettes/movieROC_vignette.pdf}{vignette} is accessible, including mathematical formalism and details about the algorithms implemented.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Computational considerations} \label{sec:complim}

\paragraph{Dependencies} Some functions of our package depend on other libraries available on CRAN:
\begin{itemize}
\item \code{gROC(X, D, side = "both", restric = TRUE, optim = TRUE, ...)} uses the \code{allShortestPaths()} function in the \CRANpkg{e1071} package \citep{e1071CRAN2023}.
\item  \code{hROC(X, D, type = "lrm", ...)} and \code{multiROC(X, D, method = "lrm", ...)} use the \code{lrm()} function in the \CRANpkg{rms} package \citep{rmsCRAN2023}.
\item \code{multiROC(X, D, method = "kernelOptimal", ...)} uses the \code{kde()} function in the \CRANpkg{ks} package \citep{ksCRAN2023}.
\item \code{multiROC(X, D, method = "dynamicMeisner", ...)} uses the \code{maxTPR()} function in the \pkg{maxTPR} package \citep{Meisner2021}. This package was removed from the CRAN repository, so we integrated the code of the \code{maxTPR()} function into our package. This function uses \code{Rsolnp::solnp()} and \code{robustbase::BYlogreg()}.
\item \code{multiROC(X, D, method = "fixedLinear", methodLinear, ...)} uses the R functions included in \citet{Kang2016} (Appendix). We integrated this code into our package.
\item \code{movieROC(obj, save = TRUE, ...)} uses the \code{saveGIF()} function in the \CRANpkg{animation} package \citep{animationCRAN2021}.
\end{itemize}


\paragraph{Limitations}

Users should be aware of certain limitations while working with this package:
\begin{itemize}
\item Some methods are potentially time-consuming, especially with medium to large sample sizes:

\item[] The estimation of the gROC curve under restriction \textit{(C)} can be computationally intensive, especially when considering different FPR to locally optimize the search using \code{gROC(X, D, side = "both", restric = TRUE, optim = TRUE, t0max = TRUE)}. Note that this method involves a quite exhaustive search of the self-contained classification subsets leading to the optimal gROC curve estimate. However, even selecting different false-positive rates $t_0$ to start from, it may not result in the optimal achievable estimate under restriction \textit{(C)}. Input parameters \code{restric}, \code{optim}, \code{t0} and \code{t0max} for \code{gROC()} function included in Table 1 of the \href{https://cran.r-project.org/web/packages/movieROC/vignettes/movieROC_vignette.pdf}{vignette} serve to control this search.

\item[] Similarly, it also occurs for multivariate markers when considering linear frontiers with dynamic parameters (by using \code{multiROC(X, D, method = "dynamicMeisner" | "dynamicEmpirical")}). 
\item Most implemented R functions consider empirical estimation for the resulting ROC curve, even if the procedure to estimate the decision rules is semi-parametric. An exception is the \code{gROC\_param()} function, which accommodates the binormal scenario. 
\item When visualizing  classification regions for multivariate markers with high dimension \linebreak (\code{plot\_buildROC()} and \code{movieROC()} functions for a `\code{multiroc}' object), our package provides some alternatives, but additional improvements could provide further aid in interpretation.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Acknowledgements}

The authors acknowledge support by the Grants PID2019-104486GB-I00 and PID2020-118101GB-I00 from Ministerio de Ciencia e Innovación (Spanish Government), and by a financial Grant for Excellence Mobility for lecturers and researchers subsidized by the University of Oviedo in collaboration with Banco Santander.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliography{PerFer-MarCam_movieROC}

\address{Sonia P\' erez Fern\'andez\\
  Department of Statistics and Operations Research and Mathematics Didactics\\
  University of Oviedo, Asturias, Spain\\
  (ORCiD: \href{https://orcid.org/0000-0002-2767-6399}{0000-0002-2767-6399})\\
  \email{perezsonia@uniovi.es}}

\address{Pablo Mart\'inez Camblor\\
  Department of Anesthesiology\\
  Geisel School of Medicine at Dartmouth, New Hampshire, USA\\
  and\\
  Faculty of Health Sciences\\
  Universidad Autónoma de Chile, Chile\\
  (ORCiD: \href{https://orcid.org/0000-0001-7845-3905}{0000-0001-7845-3905})\\
  \email{Pablo.Martinez-Camblor@hitchcock.org}}

\address{Norberto Corral Blanco\\
  Department of Statistics and Operations Research and Mathematics Didactics\\
  University of Oviedo, Asturias, Spain\\
  (ORCiD: \href{https://orcid.org/0000-0002-6962-6154}{0000-0002-6962-6154})\\
  \email{norbert@uniovi.es}}
