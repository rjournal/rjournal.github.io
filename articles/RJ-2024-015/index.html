<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/>
  <meta name="generator" content="distill" />

  <style type="text/css">
  /* Hide doc at startup (prevent jankiness while JS renders/transforms) */
  body {
    visibility: hidden;
  }
  </style>

 <!--radix_placeholder_import_source-->
 <!--/radix_placeholder_import_source-->

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { color: #00769e; background-color: #f1f3f5; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { color: #00769e; } /* Normal */
code span.al { color: #ad0000; } /* Alert */
code span.an { color: #5e5e5e; } /* Annotation */
code span.at { color: #657422; } /* Attribute */
code span.bn { color: #ad0000; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #00769e; } /* ControlFlow */
code span.ch { color: #20794d; } /* Char */
code span.cn { color: #8f5902; } /* Constant */
code span.co { color: #5e5e5e; } /* Comment */
code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
code span.dt { color: #ad0000; } /* DataType */
code span.dv { color: #ad0000; } /* DecVal */
code span.er { color: #ad0000; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #ad0000; } /* Float */
code span.fu { color: #4758ab; } /* Function */
code span.im { } /* Import */
code span.in { color: #5e5e5e; } /* Information */
code span.kw { color: #00769e; } /* Keyword */
code span.op { color: #5e5e5e; } /* Operator */
code span.ot { color: #00769e; } /* Other */
code span.pp { color: #ad0000; } /* Preprocessor */
code span.sc { color: #5e5e5e; } /* SpecialChar */
code span.ss { color: #20794d; } /* SpecialString */
code span.st { color: #20794d; } /* String */
code span.va { color: #111111; } /* Variable */
code span.vs { color: #20794d; } /* VerbatimString */
code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
</style>

<style>
  div.csl-bib-body { }
  div.csl-entry {
    clear: both;
    }
  .hanging div.csl-entry {
    margin-left:2em;
    text-indent:-2em;
  }
  div.csl-left-margin {
    min-width:2em;
    float:left;
  }
  div.csl-right-inline {
    margin-left:2em;
    padding-left:1em;
  }
  div.csl-indent {
    margin-left: 2em;
  }
</style>

  <!--radix_placeholder_meta_tags-->
<title>`clarify`: Simulation-Based Inference for Regression Models</title>

<meta property="description" itemprop="description" content="Simulation-based inference is an alternative to the delta method for&#10;computing the uncertainty around regression post-estimation (i.e.,&#10;derived) quantities such as average marginal effects, average adjusted&#10;predictions, and other functions of model parameters. It works by&#10;drawing model parameters from their joint distribution and estimating&#10;quantities of interest from each set of simulated values, which form a&#10;simulated &quot;posterior&quot; distribution of the quantity from which&#10;confidence intervals can be computed. `clarify` provides a simple,&#10;unified interface for performing simulation-based inference for any&#10;user-specified derived quantities as well as wrappers for common&#10;quantities of interest. `clarify` supports a large and growing number&#10;of models through its interface with the `marginaleffects` package and&#10;provides native support for multiply imputed data."/>

<link rel="canonical" href="https://doi.org/10.32614/RJ-2024-015/"/>
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/"/>
<link rel="icon" type="image/vnd.microsoft.icon" href="../../resources/favicon.ico"/>

<!--  https://schema.org/Article -->
<meta property="article:published" itemprop="datePublished" content="2025-01-31"/>
<meta property="article:created" itemprop="dateCreated" content="2025-01-31"/>
<meta name="article:author" content="Noah Greifer"/>
<meta name="article:author" content="Steven Worthington"/>
<meta name="article:author" content="Stefano Iacus"/>
<meta name="article:author" content="Gary King"/>

<!--  https://developers.facebook.com/docs/sharing/webmasters#markup -->
<meta property="og:title" content="`clarify`: Simulation-Based Inference for Regression Models"/>
<meta property="og:type" content="article"/>
<meta property="og:description" content="Simulation-based inference is an alternative to the delta method for&#10;computing the uncertainty around regression post-estimation (i.e.,&#10;derived) quantities such as average marginal effects, average adjusted&#10;predictions, and other functions of model parameters. It works by&#10;drawing model parameters from their joint distribution and estimating&#10;quantities of interest from each set of simulated values, which form a&#10;simulated &quot;posterior&quot; distribution of the quantity from which&#10;confidence intervals can be computed. `clarify` provides a simple,&#10;unified interface for performing simulation-based inference for any&#10;user-specified derived quantities as well as wrappers for common&#10;quantities of interest. `clarify` supports a large and growing number&#10;of models through its interface with the `marginaleffects` package and&#10;provides native support for multiply imputed data."/>
<meta property="og:url" content="https://doi.org/10.32614/RJ-2024-015/"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:site_name" content="The R Journal"/>

<!--  https://dev.twitter.com/cards/types/summary -->
<meta property="twitter:card" content="summary"/>
<meta property="twitter:title" content="`clarify`: Simulation-Based Inference for Regression Models"/>
<meta property="twitter:description" content="Simulation-based inference is an alternative to the delta method for&#10;computing the uncertainty around regression post-estimation (i.e.,&#10;derived) quantities such as average marginal effects, average adjusted&#10;predictions, and other functions of model parameters. It works by&#10;drawing model parameters from their joint distribution and estimating&#10;quantities of interest from each set of simulated values, which form a&#10;simulated &quot;posterior&quot; distribution of the quantity from which&#10;confidence intervals can be computed. `clarify` provides a simple,&#10;unified interface for performing simulation-based inference for any&#10;user-specified derived quantities as well as wrappers for common&#10;quantities of interest. `clarify` supports a large and growing number&#10;of models through its interface with the `marginaleffects` package and&#10;provides native support for multiply imputed data."/>
<meta property="twitter:url" content="https://doi.org/10.32614/RJ-2024-015/"/>

<!--  https://scholar.google.com/intl/en/scholar/inclusion.html#indexing -->
<meta name="citation_title" content="`clarify`: Simulation-Based Inference for Regression Models"/>
<meta name="citation_fulltext_html_url" content="https://doi.org/10.32614/RJ-2024-015"/>
<meta name="citation_pdf_url" content="RJ-2024-015.pdf"/>
<meta name="citation_volume" content="16"/>
<meta name="citation_issue" content="2"/>
<meta name="citation_doi" content="10.32614/RJ-2024-015"/>
<meta name="citation_journal_title" content="The R Journal"/>
<meta name="citation_issn" content="2073-4859"/>
<meta name="citation_firstpage" content="1"/>
<meta name="citation_fulltext_world_readable" content=""/>
<meta name="citation_online_date" content="2025/01/31"/>
<meta name="citation_publication_date" content="2025/01/31"/>
<meta name="citation_author" content="Noah Greifer"/>
<meta name="citation_author_institution" content="Harvard University"/>
<meta name="citation_author" content="Steven Worthington"/>
<meta name="citation_author_institution" content="Harvard University"/>
<meta name="citation_author" content="Stefano Iacus"/>
<meta name="citation_author_institution" content="Harvard University"/>
<meta name="citation_author" content="Gary King"/>
<meta name="citation_author_institution" content="Harvard University"/>
<!--/radix_placeholder_meta_tags-->
  <!--radix_placeholder_rmarkdown_metadata-->

<script type="text/json" id="radix-rmarkdown-metadata">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["title","description","author","date","date_received","journal","volume","issue","slug","citation_url","packages","preview","bibliography","CTV","legacy_pdf","legacy_converted","output","draft","pdf_url","doi","creative_commons","csl","canonical_url"]}},"value":[{"type":"character","attributes":{},"value":["`clarify`: Simulation-Based Inference for Regression Models"]},{"type":"character","attributes":{},"value":["Simulation-based inference is an alternative to the delta method for\ncomputing the uncertainty around regression post-estimation (i.e.,\nderived) quantities such as average marginal effects, average adjusted\npredictions, and other functions of model parameters. It works by\ndrawing model parameters from their joint distribution and estimating\nquantities of interest from each set of simulated values, which form a\nsimulated \"posterior\" distribution of the quantity from which\nconfidence intervals can be computed. `clarify` provides a simple,\nunified interface for performing simulation-based inference for any\nuser-specified derived quantities as well as wrappers for common\nquantities of interest. `clarify` supports a large and growing number\nof models through its interface with the `marginaleffects` package and\nprovides native support for multiply imputed data."]},{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address"]}},"value":[{"type":"character","attributes":{},"value":["Noah Greifer"]},{"type":"character","attributes":{},"value":["Harvard University"]},{"type":"character","attributes":{},"value":["Institute for Quantitative Social Science","Cambridge, MA","ngreifer.github.io","*ORCiD: [0000-0003-3067-7154](https://orcid.org/0000-0003-3067-7154)*","[`ngreifer@iq.harvard.edu`](mailto:ngreifer@iq.harvard.edu)\n"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address"]}},"value":[{"type":"character","attributes":{},"value":["Steven Worthington"]},{"type":"character","attributes":{},"value":["Harvard University"]},{"type":"character","attributes":{},"value":["Institute for Quantitative Social Science","Cambridge, MA","*ORCiD: [0000-0001-9550-5797](https://orcid.org/0000-0001-9550-5797)*","[`sworthington@iq.harvard.edu`](mailto:sworthington@iq.harvard.edu)\n"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address"]}},"value":[{"type":"character","attributes":{},"value":["Stefano Iacus"]},{"type":"character","attributes":{},"value":["Harvard University"]},{"type":"character","attributes":{},"value":["Institute for Quantitative Social Science","Cambridge, MA","*ORCiD: [0000-0002-4884-0047](https://orcid.org/0000-0002-4884-0047)*","[`siacus@iq.harvard.edu`](mailto:siacus@iq.harvard.edu)\n"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address"]}},"value":[{"type":"character","attributes":{},"value":["Gary King"]},{"type":"character","attributes":{},"value":["Harvard University"]},{"type":"character","attributes":{},"value":["Institute for Quantitative Social Science","Cambridge, MA","*ORCiD: [0000-0002-5327-7631](https://orcid.org/0000-0002-5327-7631)*","[`king@harvard.edu`](mailto:king@harvard.edu)\n"]}]}]},{"type":"character","attributes":{},"value":["2025-01-31"]},{"type":"character","attributes":{},"value":["2024-01-11"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["title","issn","firstpage","lastpage"]}},"value":[{"type":"character","attributes":{},"value":["The R Journal"]},{"type":"character","attributes":{},"value":["2073-4859"]},{"type":"double","attributes":{},"value":[1]},{"type":"NULL"}]},{"type":"integer","attributes":{},"value":[16]},{"type":"integer","attributes":{},"value":[2]},{"type":"character","attributes":{},"value":["RJ-2024-015"]},{"type":"character","attributes":{},"value":["https://doi.org/10.32614/RJ-2024-015"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["cran","bioc"]}},"value":[{"type":"character","attributes":{},"value":["clarify","marginaleffects","MatchIt","modelbased","emmeans","effects","ggeffects","Amelia","mice","MatchThem"]},{"type":"list","attributes":{},"value":[]}]},{"type":"character","attributes":{},"value":["preview.png"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["CausalInference","Econometrics","MachineLearning","MissingData","MixedModels","OfficialStatistics","TeachingStatistics"]},{"type":"logical","attributes":{},"value":[true]},{"type":"logical","attributes":{},"value":[true]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["distill::distill_article"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["self_contained","toc","mathjax","md_extension"]}},"value":[{"type":"logical","attributes":{},"value":[true]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"]},{"type":"character","attributes":{},"value":["-tex_math_single_backslash"]}]}]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["RJ-2024-015.pdf"]},{"type":"character","attributes":{},"value":["10.32614/RJ-2024-015"]},{"type":"character","attributes":{},"value":["CC BY"]},{"type":"character","attributes":{},"value":["/home/mitchell/R/x86_64-pc-linux-gnu-library/4.4/rjtools/rjournal.csl"]},{"type":"character","attributes":{},"value":["https://doi.org/10.32614/RJ-2024-015/"]}]}
</script>
<!--/radix_placeholder_rmarkdown_metadata-->
  
  <script type="text/json" id="radix-resource-manifest">
  {"type":"character","attributes":{},"value":["clarify.pdf","clarify.tex","figures/plot1-1.pdf","figures/plot1-1.png","figures/plot2-1.pdf","figures/plot2-1.png","figures/plot3-1.pdf","figures/plot3-1.png","figures/plot4-1.pdf","figures/plot4-1.png","figures/plot8-1.pdf","figures/plot8-1.png","figures/plot9-1.pdf","figures/plot9-1.png","RJreferences.bib","RJwrapper.tex"]}
  </script>
  <!--radix_placeholder_navigation_in_header-->
<meta name="distill:offset" content="../.."/>

<script type="application/javascript">

  window.headroom_prevent_pin = false;

  window.document.addEventListener("DOMContentLoaded", function (event) {

    // initialize headroom for banner
    var header = $('header').get(0);
    var headerHeight = header.offsetHeight;
    var headroom = new Headroom(header, {
      tolerance: 5,
      onPin : function() {
        if (window.headroom_prevent_pin) {
          window.headroom_prevent_pin = false;
          headroom.unpin();
        }
      }
    });
    headroom.init();
    if(window.location.hash)
      headroom.unpin();
    $(header).addClass('headroom--transition');

    // offset scroll location for banner on hash change
    // (see: https://github.com/WickyNilliams/headroom.js/issues/38)
    window.addEventListener("hashchange", function(event) {
      window.scrollTo(0, window.pageYOffset - (headerHeight + 25));
    });

    // responsive menu
    $('.distill-site-header').each(function(i, val) {
      var topnav = $(this);
      var toggle = topnav.find('.nav-toggle');
      toggle.on('click', function() {
        topnav.toggleClass('responsive');
      });
    });

    // nav dropdowns
    $('.nav-dropbtn').click(function(e) {
      $(this).next('.nav-dropdown-content').toggleClass('nav-dropdown-active');
      $(this).parent().siblings('.nav-dropdown')
         .children('.nav-dropdown-content').removeClass('nav-dropdown-active');
    });
    $("body").click(function(e){
      $('.nav-dropdown-content').removeClass('nav-dropdown-active');
    });
    $(".nav-dropdown").click(function(e){
      e.stopPropagation();
    });
  });
</script>

<style type="text/css">

/* Theme (user-documented overrideables for nav appearance) */

.distill-site-nav {
  color: rgba(255, 255, 255, 0.8);
  background-color: #0F2E3D;
  font-size: 15px;
  font-weight: 300;
}

.distill-site-nav a {
  color: inherit;
  text-decoration: none;
}

.distill-site-nav a:hover {
  color: white;
}

@media print {
  .distill-site-nav {
    display: none;
  }
}

.distill-site-header {

}

.distill-site-footer {

}


/* Site Header */

.distill-site-header {
  width: 100%;
  box-sizing: border-box;
  z-index: 3;
}

.distill-site-header .nav-left {
  display: inline-block;
  margin-left: 8px;
}

@media screen and (max-width: 768px) {
  .distill-site-header .nav-left {
    margin-left: 0;
  }
}


.distill-site-header .nav-right {
  float: right;
  margin-right: 8px;
}

.distill-site-header a,
.distill-site-header .title {
  display: inline-block;
  text-align: center;
  padding: 14px 10px 14px 10px;
}

.distill-site-header .title {
  font-size: 18px;
  min-width: 150px;
}

.distill-site-header .logo {
  padding: 0;
}

.distill-site-header .logo img {
  display: none;
  max-height: 20px;
  width: auto;
  margin-bottom: -4px;
}

.distill-site-header .nav-image img {
  max-height: 18px;
  width: auto;
  display: inline-block;
  margin-bottom: -3px;
}



@media screen and (min-width: 1000px) {
  .distill-site-header .logo img {
    display: inline-block;
  }
  .distill-site-header .nav-left {
    margin-left: 20px;
  }
  .distill-site-header .nav-right {
    margin-right: 20px;
  }
  .distill-site-header .title {
    padding-left: 12px;
  }
}


.distill-site-header .nav-toggle {
  display: none;
}

.nav-dropdown {
  display: inline-block;
  position: relative;
}

.nav-dropdown .nav-dropbtn {
  border: none;
  outline: none;
  color: rgba(255, 255, 255, 0.8);
  padding: 16px 10px;
  background-color: transparent;
  font-family: inherit;
  font-size: inherit;
  font-weight: inherit;
  margin: 0;
  margin-top: 1px;
  z-index: 2;
}

.nav-dropdown-content {
  display: none;
  position: absolute;
  background-color: white;
  min-width: 200px;
  border: 1px solid rgba(0,0,0,0.15);
  border-radius: 4px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.1);
  z-index: 1;
  margin-top: 2px;
  white-space: nowrap;
  padding-top: 4px;
  padding-bottom: 4px;
}

.nav-dropdown-content hr {
  margin-top: 4px;
  margin-bottom: 4px;
  border: none;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.nav-dropdown-active {
  display: block;
}

.nav-dropdown-content a, .nav-dropdown-content .nav-dropdown-header {
  color: black;
  padding: 6px 24px;
  text-decoration: none;
  display: block;
  text-align: left;
}

.nav-dropdown-content .nav-dropdown-header {
  display: block;
  padding: 5px 24px;
  padding-bottom: 0;
  text-transform: uppercase;
  font-size: 14px;
  color: #999999;
  white-space: nowrap;
}

.nav-dropdown:hover .nav-dropbtn {
  color: white;
}

.nav-dropdown-content a:hover {
  background-color: #ddd;
  color: black;
}

.nav-right .nav-dropdown-content {
  margin-left: -45%;
  right: 0;
}

@media screen and (max-width: 768px) {
  .distill-site-header a, .distill-site-header .nav-dropdown  {display: none;}
  .distill-site-header a.nav-toggle {
    float: right;
    display: block;
  }
  .distill-site-header .title {
    margin-left: 0;
  }
  .distill-site-header .nav-right {
    margin-right: 0;
  }
  .distill-site-header {
    overflow: hidden;
  }
  .nav-right .nav-dropdown-content {
    margin-left: 0;
  }
}


@media screen and (max-width: 768px) {
  .distill-site-header.responsive {position: relative; min-height: 500px; }
  .distill-site-header.responsive a.nav-toggle {
    position: absolute;
    right: 0;
    top: 0;
  }
  .distill-site-header.responsive a,
  .distill-site-header.responsive .nav-dropdown {
    display: block;
    text-align: left;
  }
  .distill-site-header.responsive .nav-left,
  .distill-site-header.responsive .nav-right {
    width: 100%;
  }
  .distill-site-header.responsive .nav-dropdown {float: none;}
  .distill-site-header.responsive .nav-dropdown-content {position: relative;}
  .distill-site-header.responsive .nav-dropdown .nav-dropbtn {
    display: block;
    width: 100%;
    text-align: left;
  }
}

/* Site Footer */

.distill-site-footer {
  width: 100%;
  overflow: hidden;
  box-sizing: border-box;
  z-index: 3;
  margin-top: 30px;
  padding-top: 30px;
  padding-bottom: 30px;
  text-align: center;
}

/* Headroom */

d-title {
  padding-top: 6rem;
}

@media print {
  d-title {
    padding-top: 4rem;
  }
}

.headroom {
  z-index: 1000;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
}

.headroom--transition {
  transition: all .4s ease-in-out;
}

.headroom--unpinned {
  top: -100px;
}

.headroom--pinned {
  top: 0;
}

/* adjust viewport for navbar height */
/* helps vertically center bootstrap (non-distill) content */
.min-vh-100 {
  min-height: calc(100vh - 100px) !important;
}

</style>

<script src="../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<link href="../../site_libs/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"/>
<link href="../../site_libs/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"/>
<script src="../../site_libs/headroom-0.9.4/headroom.min.js"></script>
<!--/radix_placeholder_navigation_in_header-->
  <!--radix_placeholder_distill-->

<style type="text/css">

body {
  background-color: white;
}

.pandoc-table {
  width: 100%;
}

.pandoc-table>caption {
  margin-bottom: 10px;
}

.pandoc-table th:not([align]) {
  text-align: left;
}

.pagedtable-footer {
  font-size: 15px;
}

d-byline .byline {
  grid-template-columns: 2fr 2fr;
}

d-byline .byline h3 {
  margin-block-start: 1.5em;
}

d-byline .byline .authors-affiliations h3 {
  margin-block-start: 0.5em;
}

.authors-affiliations .orcid-id {
  width: 16px;
  height:16px;
  margin-left: 4px;
  margin-right: 4px;
  vertical-align: middle;
  padding-bottom: 2px;
}

d-title .dt-tags {
  margin-top: 1em;
  grid-column: text;
}

.dt-tags .dt-tag {
  text-decoration: none;
  display: inline-block;
  color: rgba(0,0,0,0.6);
  padding: 0em 0.4em;
  margin-right: 0.5em;
  margin-bottom: 0.4em;
  font-size: 70%;
  border: 1px solid rgba(0,0,0,0.2);
  border-radius: 3px;
  text-transform: uppercase;
  font-weight: 500;
}

d-article table.gt_table td,
d-article table.gt_table th {
  border-bottom: none;
  font-size: 100%;
}

.html-widget {
  margin-bottom: 2.0em;
}

.l-screen-inset {
  padding-right: 16px;
}

.l-screen .caption {
  margin-left: 10px;
}

.shaded {
  background: rgb(247, 247, 247);
  padding-top: 20px;
  padding-bottom: 20px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.shaded .html-widget {
  margin-bottom: 0;
  border: 1px solid rgba(0, 0, 0, 0.1);
}

.shaded .shaded-content {
  background: white;
}

.text-output {
  margin-top: 0;
  line-height: 1.5em;
}

.hidden {
  display: none !important;
}

hr.section-separator {
  border: none;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  margin: 0px;
}


d-byline {
  border-top: none;
}

d-article {
  padding-top: 2.5rem;
  padding-bottom: 30px;
  border-top: none;
}

d-appendix {
  padding-top: 30px;
}

d-article>p>img {
  width: 100%;
}

d-article h2 {
  margin: 1rem 0 1.5rem 0;
}

d-article h3 {
  margin-top: 1.5rem;
}

d-article iframe {
  border: 1px solid rgba(0, 0, 0, 0.1);
  margin-bottom: 2.0em;
  width: 100%;
}

/* Tweak code blocks */

d-article div.sourceCode code,
d-article pre code {
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
}

d-article pre,
d-article div.sourceCode,
d-article div.sourceCode pre {
  overflow: auto;
}

d-article div.sourceCode {
  background-color: white;
}

d-article div.sourceCode pre {
  padding-left: 10px;
  font-size: 12px;
  border-left: 2px solid rgba(0,0,0,0.1);
}

d-article pre {
  font-size: 12px;
  color: black;
  background: none;
  margin-top: 0;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

d-article pre a {
  border-bottom: none;
}

d-article pre a:hover {
  border-bottom: none;
  text-decoration: underline;
}

d-article details {
  grid-column: text;
  margin-bottom: 0.8em;
}

@media(min-width: 768px) {

d-article pre,
d-article div.sourceCode,
d-article div.sourceCode pre {
  overflow: visible !important;
}

d-article div.sourceCode pre {
  padding-left: 18px;
  font-size: 14px;
}

/* tweak for Pandoc numbered line within distill */
d-article pre.numberSource code > span {
    left: -2em;
}

d-article pre {
  font-size: 14px;
}

}

figure img.external {
  background: white;
  border: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
  padding: 18px;
  box-sizing: border-box;
}

/* CSS for d-contents */

.d-contents {
  grid-column: text;
  color: rgba(0,0,0,0.8);
  font-size: 0.9em;
  padding-bottom: 1em;
  margin-bottom: 1em;
  padding-bottom: 0.5em;
  margin-bottom: 1em;
  padding-left: 0.25em;
  justify-self: start;
}

@media(min-width: 1000px) {
  .d-contents.d-contents-float {
    height: 0;
    grid-column-start: 1;
    grid-column-end: 4;
    justify-self: center;
    padding-right: 3em;
    padding-left: 2em;
  }
}

.d-contents nav h3 {
  font-size: 18px;
  margin-top: 0;
  margin-bottom: 1em;
}

.d-contents li {
  list-style-type: none
}

.d-contents nav > ul {
  padding-left: 0;
}

.d-contents ul {
  padding-left: 1em
}

.d-contents nav ul li {
  margin-top: 0.6em;
  margin-bottom: 0.2em;
}

.d-contents nav a {
  font-size: 13px;
  border-bottom: none;
  text-decoration: none
  color: rgba(0, 0, 0, 0.8);
}

.d-contents nav a:hover {
  text-decoration: underline solid rgba(0, 0, 0, 0.6)
}

.d-contents nav > ul > li > a {
  font-weight: 600;
}

.d-contents nav > ul > li > ul {
  font-weight: inherit;
}

.d-contents nav > ul > li > ul > li {
  margin-top: 0.2em;
}


.d-contents nav ul {
  margin-top: 0;
  margin-bottom: 0.25em;
}

.d-article-with-toc h2:nth-child(2) {
  margin-top: 0;
}


/* Figure */

.figure {
  position: relative;
  margin-bottom: 2.5em;
  margin-top: 1.5em;
}

.figure .caption {
  color: rgba(0, 0, 0, 0.6);
  font-size: 12px;
  line-height: 1.5em;
}

.figure img.external {
  background: white;
  border: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
  padding: 18px;
  box-sizing: border-box;
}

.figure .caption a {
  color: rgba(0, 0, 0, 0.6);
}

.figure .caption b,
.figure .caption strong, {
  font-weight: 600;
  color: rgba(0, 0, 0, 1.0);
}

/* Citations */

d-article .citation {
  color: inherit;
  cursor: inherit;
}

div.hanging-indent{
  margin-left: 1em; text-indent: -1em;
}

/* Citation hover box */

.tippy-box[data-theme~=light-border] {
  background-color: rgba(250, 250, 250, 0.95);
}

.tippy-content > p {
  margin-bottom: 0;
  padding: 2px;
}


/* Tweak 1000px media break to show more text */

@media(min-width: 1000px) {
  .base-grid,
  distill-header,
  d-title,
  d-abstract,
  d-article,
  d-appendix,
  distill-appendix,
  d-byline,
  d-footnote-list,
  d-citation-list,
  distill-footer {
    grid-template-columns: [screen-start] 1fr [page-start kicker-start] 80px [middle-start] 50px [text-start kicker-end] 65px 65px 65px 65px 65px 65px 65px 65px [text-end gutter-start] 65px [middle-end] 65px [page-end gutter-end] 1fr [screen-end];
    grid-column-gap: 16px;
  }

  .grid {
    grid-column-gap: 16px;
  }

  d-article {
    font-size: 1.06rem;
    line-height: 1.7em;
  }
  figure .caption, .figure .caption, figure figcaption {
    font-size: 13px;
  }
}

@media(min-width: 1180px) {
  .base-grid,
  distill-header,
  d-title,
  d-abstract,
  d-article,
  d-appendix,
  distill-appendix,
  d-byline,
  d-footnote-list,
  d-citation-list,
  distill-footer {
    grid-template-columns: [screen-start] 1fr [page-start kicker-start] 60px [middle-start] 60px [text-start kicker-end] 60px 60px 60px 60px 60px 60px 60px 60px [text-end gutter-start] 60px [middle-end] 60px [page-end gutter-end] 1fr [screen-end];
    grid-column-gap: 32px;
  }

  .grid {
    grid-column-gap: 32px;
  }
}


/* Get the citation styles for the appendix (not auto-injected on render since
   we do our own rendering of the citation appendix) */

d-appendix .citation-appendix,
.d-appendix .citation-appendix {
  font-size: 11px;
  line-height: 15px;
  border-left: 1px solid rgba(0, 0, 0, 0.1);
  padding-left: 18px;
  border: 1px solid rgba(0,0,0,0.1);
  background: rgba(0, 0, 0, 0.02);
  padding: 10px 18px;
  border-radius: 3px;
  color: rgba(150, 150, 150, 1);
  overflow: hidden;
  margin-top: -12px;
  white-space: pre-wrap;
  word-wrap: break-word;
}

/* Include appendix styles here so they can be overridden */

d-appendix {
  contain: layout style;
  font-size: 0.8em;
  line-height: 1.7em;
  margin-top: 60px;
  margin-bottom: 0;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  color: rgba(0,0,0,0.5);
  padding-top: 60px;
  padding-bottom: 48px;
}

d-appendix h3 {
  grid-column: page-start / text-start;
  font-size: 15px;
  font-weight: 500;
  margin-top: 1em;
  margin-bottom: 0;
  color: rgba(0,0,0,0.65);
}

d-appendix h3 + * {
  margin-top: 1em;
}

d-appendix ol {
  padding: 0 0 0 15px;
}

@media (min-width: 768px) {
  d-appendix ol {
    padding: 0 0 0 30px;
    margin-left: -30px;
  }
}

d-appendix li {
  margin-bottom: 1em;
}

d-appendix a {
  color: rgba(0, 0, 0, 0.6);
}

d-appendix > * {
  grid-column: text;
}

d-appendix > d-footnote-list,
d-appendix > d-citation-list,
d-appendix > distill-appendix {
  grid-column: screen;
}

/* Include footnote styles here so they can be overridden */

d-footnote-list {
  contain: layout style;
}

d-footnote-list > * {
  grid-column: text;
}

d-footnote-list a.footnote-backlink {
  color: rgba(0,0,0,0.3);
  padding-left: 0.5em;
}



/* Anchor.js */

.anchorjs-link {
  /*transition: all .25s linear; */
  text-decoration: none;
  border-bottom: none;
}
*:hover > .anchorjs-link {
  margin-left: -1.125em !important;
  text-decoration: none;
  border-bottom: none;
}

/* Social footer */

.social_footer {
  margin-top: 30px;
  margin-bottom: 0;
  color: rgba(0,0,0,0.67);
}

.disqus-comments {
  margin-right: 30px;
}

.disqus-comment-count {
  border-bottom: 1px solid rgba(0, 0, 0, 0.4);
  cursor: pointer;
}

#disqus_thread {
  margin-top: 30px;
}

.article-sharing a {
  border-bottom: none;
  margin-right: 8px;
}

.article-sharing a:hover {
  border-bottom: none;
}

.sidebar-section.subscribe {
  font-size: 12px;
  line-height: 1.6em;
}

.subscribe p {
  margin-bottom: 0.5em;
}


.article-footer .subscribe {
  font-size: 15px;
  margin-top: 45px;
}


.sidebar-section.custom {
  font-size: 12px;
  line-height: 1.6em;
}

.custom p {
  margin-bottom: 0.5em;
}

/* Styles for listing layout (hide title) */
.layout-listing d-title, .layout-listing .d-title {
  display: none;
}

/* Styles for posts lists (not auto-injected) */


.posts-with-sidebar {
  padding-left: 45px;
  padding-right: 45px;
}

.posts-list .description h2,
.posts-list .description p {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
}

.posts-list .description h2 {
  font-weight: 700;
  border-bottom: none;
  padding-bottom: 0;
}

.posts-list h2.post-tag {
  border-bottom: 1px solid rgba(0, 0, 0, 0.2);
  padding-bottom: 12px;
}
.posts-list {
  margin-top: 60px;
  margin-bottom: 24px;
}

.posts-list .post-preview {
  text-decoration: none;
  overflow: hidden;
  display: block;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  padding: 24px 0;
}

.post-preview-last {
  border-bottom: none !important;
}

.posts-list .posts-list-caption {
  grid-column: screen;
  font-weight: 400;
}

.posts-list .post-preview h2 {
  margin: 0 0 6px 0;
  line-height: 1.2em;
  font-style: normal;
  font-size: 24px;
}

.posts-list .post-preview p {
  margin: 0 0 12px 0;
  line-height: 1.4em;
  font-size: 16px;
}

.posts-list .post-preview .thumbnail {
  box-sizing: border-box;
  margin-bottom: 24px;
  position: relative;
  max-width: 500px;
}
.posts-list .post-preview img {
  width: 100%;
  display: block;
}

.posts-list .metadata {
  font-size: 12px;
  line-height: 1.4em;
  margin-bottom: 18px;
}

.posts-list .metadata > * {
  display: inline-block;
}

.posts-list .metadata .publishedDate {
  margin-right: 2em;
}

.posts-list .metadata .dt-authors {
  display: block;
  margin-top: 0.3em;
  margin-right: 2em;
}

.posts-list .dt-tags {
  display: block;
  line-height: 1em;
}

.posts-list .dt-tags .dt-tag {
  display: inline-block;
  color: rgba(0,0,0,0.6);
  padding: 0.3em 0.4em;
  margin-right: 0.2em;
  margin-bottom: 0.4em;
  font-size: 60%;
  border: 1px solid rgba(0,0,0,0.2);
  border-radius: 3px;
  text-transform: uppercase;
  font-weight: 500;
}

.posts-list img {
  opacity: 1;
}

.posts-list img[data-src] {
  opacity: 0;
}

.posts-more {
  clear: both;
}


.posts-sidebar {
  font-size: 16px;
}

.posts-sidebar h3 {
  font-size: 16px;
  margin-top: 0;
  margin-bottom: 0.5em;
  font-weight: 400;
  text-transform: uppercase;
}

.sidebar-section {
  margin-bottom: 30px;
}

.categories ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

.categories li {
  color: rgba(0, 0, 0, 0.8);
  margin-bottom: 0;
}

.categories li>a {
  border-bottom: none;
}

.categories li>a:hover {
  border-bottom: 1px solid rgba(0, 0, 0, 0.4);
}

.categories .active {
  font-weight: 600;
}

.categories .category-count {
  color: rgba(0, 0, 0, 0.4);
}


@media(min-width: 768px) {
  .posts-list .post-preview h2 {
    font-size: 26px;
  }
  .posts-list .post-preview .thumbnail {
    float: right;
    width: 30%;
    margin-bottom: 0;
  }
  .posts-list .post-preview .description {
    float: left;
    width: 45%;
  }
  .posts-list .post-preview .metadata {
    float: left;
    width: 20%;
    margin-top: 8px;
  }
  .posts-list .post-preview p {
    margin: 0 0 12px 0;
    line-height: 1.5em;
    font-size: 16px;
  }
  .posts-with-sidebar .posts-list {
    float: left;
    width: 75%;
  }
  .posts-with-sidebar .posts-sidebar {
    float: right;
    width: 20%;
    margin-top: 60px;
    padding-top: 24px;
    padding-bottom: 24px;
  }
}


/* Improve display for browsers without grid (IE/Edge <= 15) */

.downlevel {
  line-height: 1.6em;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
  margin: 0;
}

.downlevel .d-title {
  padding-top: 6rem;
  padding-bottom: 1.5rem;
}

.downlevel .d-title h1 {
  font-size: 50px;
  font-weight: 700;
  line-height: 1.1em;
  margin: 0 0 0.5rem;
}

.downlevel .d-title p {
  font-weight: 300;
  font-size: 1.2rem;
  line-height: 1.55em;
  margin-top: 0;
}

.downlevel .d-byline {
  padding-top: 0.8em;
  padding-bottom: 0.8em;
  font-size: 0.8rem;
  line-height: 1.8em;
}

.downlevel .section-separator {
  border: none;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.downlevel .d-article {
  font-size: 1.06rem;
  line-height: 1.7em;
  padding-top: 1rem;
  padding-bottom: 2rem;
}


.downlevel .d-appendix {
  padding-left: 0;
  padding-right: 0;
  max-width: none;
  font-size: 0.8em;
  line-height: 1.7em;
  margin-bottom: 0;
  color: rgba(0,0,0,0.5);
  padding-top: 40px;
  padding-bottom: 48px;
}

.downlevel .footnotes ol {
  padding-left: 13px;
}

.downlevel .base-grid,
.downlevel .distill-header,
.downlevel .d-title,
.downlevel .d-abstract,
.downlevel .d-article,
.downlevel .d-appendix,
.downlevel .distill-appendix,
.downlevel .d-byline,
.downlevel .d-footnote-list,
.downlevel .d-citation-list,
.downlevel .distill-footer,
.downlevel .appendix-bottom,
.downlevel .posts-container {
  padding-left: 40px;
  padding-right: 40px;
}

@media(min-width: 768px) {
  .downlevel .base-grid,
  .downlevel .distill-header,
  .downlevel .d-title,
  .downlevel .d-abstract,
  .downlevel .d-article,
  .downlevel .d-appendix,
  .downlevel .distill-appendix,
  .downlevel .d-byline,
  .downlevel .d-footnote-list,
  .downlevel .d-citation-list,
  .downlevel .distill-footer,
  .downlevel .appendix-bottom,
  .downlevel .posts-container {
  padding-left: 150px;
  padding-right: 150px;
  max-width: 900px;
}
}

.downlevel pre code {
  display: block;
  border-left: 2px solid rgba(0, 0, 0, .1);
  padding: 0 0 0 20px;
  font-size: 14px;
}

.downlevel code, .downlevel pre {
  color: black;
  background: none;
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

.downlevel .posts-list .post-preview {
  color: inherit;
}



</style>

<script type="application/javascript">

function is_downlevel_browser() {
  if (bowser.isUnsupportedBrowser({ msie: "12", msedge: "16"},
                                 window.navigator.userAgent)) {
    return true;
  } else {
    return window.load_distill_framework === undefined;
  }
}

// show body when load is complete
function on_load_complete() {

  // add anchors
  if (window.anchors) {
    window.anchors.options.placement = 'left';
    window.anchors.add('d-article > h2, d-article > h3, d-article > h4, d-article > h5');
  }


  // set body to visible
  document.body.style.visibility = 'visible';

  // force redraw for leaflet widgets
  if (window.HTMLWidgets) {
    var maps = window.HTMLWidgets.findAll(".leaflet");
    $.each(maps, function(i, el) {
      var map = this.getMap();
      map.invalidateSize();
      map.eachLayer(function(layer) {
        if (layer instanceof L.TileLayer)
          layer.redraw();
      });
    });
  }

  // trigger 'shown' so htmlwidgets resize
  $('d-article').trigger('shown');
}

function init_distill() {

  init_common();

  // create front matter
  var front_matter = $('<d-front-matter></d-front-matter>');
  $('#distill-front-matter').wrap(front_matter);

  // create d-title
  $('.d-title').changeElementType('d-title');

  // separator
  var separator = '<hr class="section-separator" style="clear: both"/>';
  // prepend separator above appendix
  $('.d-byline').before(separator);
  $('.d-article').before(separator);

  // create d-byline
  var byline = $('<d-byline></d-byline>');
  $('.d-byline').replaceWith(byline);

  // create d-article
  var article = $('<d-article></d-article>');
  $('.d-article').wrap(article).children().unwrap();

  // move posts container into article
  $('.posts-container').appendTo($('d-article'));

  // create d-appendix
  $('.d-appendix').changeElementType('d-appendix');

  // flag indicating that we have appendix items
  var appendix = $('.appendix-bottom').children('h3').length > 0;

  // replace footnotes with <d-footnote>
  $('.footnote-ref').each(function(i, val) {
    appendix = true;
    var href = $(this).attr('href');
    var id = href.replace('#', '');
    var fn = $('#' + id);
    var fn_p = $('#' + id + '>p');
    fn_p.find('.footnote-back').remove();
    var text = fn_p.html();
    var dtfn = $('<d-footnote></d-footnote>');
    dtfn.html(text);
    $(this).replaceWith(dtfn);
  });
  // remove footnotes
  $('.footnotes').remove();

  // move refs into #references-listing
  $('#references-listing').replaceWith($('#refs'));

  $('h1.appendix, h2.appendix').each(function(i, val) {
    $(this).changeElementType('h3');
  });
  $('h3.appendix').each(function(i, val) {
    var id = $(this).attr('id');
    $('.d-contents a[href="#' + id + '"]').parent().remove();
    appendix = true;
    $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('d-appendix'));
  });

  // show d-appendix if we have appendix content
  $("d-appendix").css('display', appendix ? 'grid' : 'none');

  // localize layout chunks to just output
  $('.layout-chunk').each(function(i, val) {

    // capture layout
    var layout = $(this).attr('data-layout');

    // apply layout to markdown level block elements
    var elements = $(this).children().not('details, div.sourceCode, pre, script');
    elements.each(function(i, el) {
      var layout_div = $('<div class="' + layout + '"></div>');
      if (layout_div.hasClass('shaded')) {
        var shaded_content = $('<div class="shaded-content"></div>');
        $(this).wrap(shaded_content);
        $(this).parent().wrap(layout_div);
      } else {
        $(this).wrap(layout_div);
      }
    });


    // unwrap the layout-chunk div
    $(this).children().unwrap();
  });

  // remove code block used to force  highlighting css
  $('.distill-force-highlighting-css').parent().remove();

  // remove empty line numbers inserted by pandoc when using a
  // custom syntax highlighting theme, except when numbering line
  // in code chunk
  $('pre:not(.numberLines) code.sourceCode a:empty').remove();

  // load distill framework
  load_distill_framework();

  // wait for window.distillRunlevel == 4 to do post processing
  function distill_post_process() {

    if (!window.distillRunlevel || window.distillRunlevel < 4)
      return;

    // hide author/affiliations entirely if we have no authors
    var front_matter = JSON.parse($("#distill-front-matter").html());
    var have_authors = front_matter.authors && front_matter.authors.length > 0;
    if (!have_authors)
      $('d-byline').addClass('hidden');

    // article with toc class
    $('.d-contents').parent().addClass('d-article-with-toc');

    // strip links that point to #
    $('.authors-affiliations').find('a[href="#"]').removeAttr('href');

    // add orcid ids
    $('.authors-affiliations').find('.author').each(function(i, el) {
      var orcid_id = front_matter.authors[i].orcidID;
      var author_name = front_matter.authors[i].author
      if (orcid_id) {
        var a = $('<a></a>');
        a.attr('href', 'https://orcid.org/' + orcid_id);
        var img = $('<img></img>');
        img.addClass('orcid-id');
        img.attr('alt', author_name ? 'ORCID ID for ' + author_name : 'ORCID ID');
        img.attr('src','data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg==');
        a.append(img);
        $(this).append(a);
      }
    });

    // hide elements of author/affiliations grid that have no value
    function hide_byline_column(caption) {
      $('d-byline').find('h3:contains("' + caption + '")').parent().css('visibility', 'hidden');
    }

    // affiliations
    var have_affiliations = false;
    for (var i = 0; i<front_matter.authors.length; ++i) {
      var author = front_matter.authors[i];
      if (author.affiliation !== "&nbsp;") {
        have_affiliations = true;
        break;
      }
    }
    if (!have_affiliations)
      $('d-byline').find('h3:contains("Affiliations")').css('visibility', 'hidden');

    // published date
    if (!front_matter.publishedDate)
      hide_byline_column("Published");

    // document object identifier
    var doi = $('d-byline').find('h3:contains("DOI")');
    var doi_p = doi.next().empty();
    if (!front_matter.doi) {
      // if we have a citation and valid citationText then link to that
      if ($('#citation').length > 0 && front_matter.citationText) {
        doi.html('Citation');
        $('<a href="#citation"></a>')
          .text(front_matter.citationText)
          .appendTo(doi_p);
      } else {
        hide_byline_column("DOI");
      }
    } else {
      $('<a></a>')
         .attr('href', "https://doi.org/" + front_matter.doi)
         .html(front_matter.doi)
         .appendTo(doi_p);
    }

     // change plural form of authors/affiliations
    if (front_matter.authors.length === 1) {
      var grid = $('.authors-affiliations');
      grid.children('h3:contains("Authors")').text('Author');
      grid.children('h3:contains("Affiliations")').text('Affiliation');
    }

    // remove d-appendix and d-footnote-list local styles
    $('d-appendix > style:first-child').remove();
    $('d-footnote-list > style:first-child').remove();

    // move appendix-bottom entries to the bottom
    $('.appendix-bottom').appendTo('d-appendix').children().unwrap();
    $('.appendix-bottom').remove();

    // hoverable references
    $('span.citation[data-cites]').each(function() {
      const citeChild = $(this).children()[0]
      // Do not process if @xyz has been used without escaping and without bibliography activated
      // https://github.com/rstudio/distill/issues/466
      if (citeChild === undefined) return true

      if (citeChild.nodeName == "D-FOOTNOTE") {
        var fn = citeChild
        $(this).html(fn.shadowRoot.querySelector("sup"))
        $(this).id = fn.id
        fn.remove()
      }
      var refs = $(this).attr('data-cites').split(" ");
      var refHtml = refs.map(function(ref) {
        // Could use CSS.escape too here, we insure backward compatibility in navigator
        return "<p>" + $('div[id="ref-' + ref + '"]').html() + "</p>";
      }).join("\n");
      window.tippy(this, {
        allowHTML: true,
        content: refHtml,
        maxWidth: 500,
        interactive: true,
        interactiveBorder: 10,
        theme: 'light-border',
        placement: 'bottom-start'
      });
    });

    // fix footnotes in tables (#411)
    // replacing broken distill.pub feature
    $('table d-footnote').each(function() {
      // we replace internal showAtNode methode which is triggered when hovering a footnote
      this.hoverBox.showAtNode = function(node) {
        // ported from https://github.com/distillpub/template/pull/105/files
        calcOffset = function(elem) {
            let x = elem.offsetLeft;
            let y = elem.offsetTop;
            // Traverse upwards until an `absolute` element is found or `elem`
            // becomes null.
            while (elem = elem.offsetParent && elem.style.position != 'absolute') {
                x += elem.offsetLeft;
                y += elem.offsetTop;
            }

            return { left: x, top: y };
        }
        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop
        const bbox = node.getBoundingClientRect();
        const offset = calcOffset(node);
        this.show([offset.left + bbox.width, offset.top + bbox.height]);
      }
    })

    // clear polling timer
    clearInterval(tid);

    // show body now that everything is ready
    on_load_complete();
  }

  var tid = setInterval(distill_post_process, 50);
  distill_post_process();

}

function init_downlevel() {

  init_common();

   // insert hr after d-title
  $('.d-title').after($('<hr class="section-separator"/>'));

  // check if we have authors
  var front_matter = JSON.parse($("#distill-front-matter").html());
  var have_authors = front_matter.authors && front_matter.authors.length > 0;

  // manage byline/border
  if (!have_authors)
    $('.d-byline').remove();
  $('.d-byline').after($('<hr class="section-separator"/>'));
  $('.d-byline a').remove();

  // remove toc
  $('.d-contents').remove();

  // move appendix elements
  $('h1.appendix, h2.appendix').each(function(i, val) {
    $(this).changeElementType('h3');
  });
  $('h3.appendix').each(function(i, val) {
    $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('.d-appendix'));
  });


  // inject headers into references and footnotes
  var refs_header = $('<h3></h3>');
  refs_header.text('References');
  $('#refs').prepend(refs_header);

  var footnotes_header = $('<h3></h3');
  footnotes_header.text('Footnotes');
  $('.footnotes').children('hr').first().replaceWith(footnotes_header);

  // move appendix-bottom entries to the bottom
  $('.appendix-bottom').appendTo('.d-appendix').children().unwrap();
  $('.appendix-bottom').remove();

  // remove appendix if it's empty
  if ($('.d-appendix').children().length === 0)
    $('.d-appendix').remove();

  // prepend separator above appendix
  $('.d-appendix').before($('<hr class="section-separator" style="clear: both"/>'));

  // trim code
  $('pre>code').each(function(i, val) {
    $(this).html($.trim($(this).html()));
  });

  // move posts-container right before article
  $('.posts-container').insertBefore($('.d-article'));

  $('body').addClass('downlevel');

  on_load_complete();
}


function init_common() {

  // jquery plugin to change element types
  (function($) {
    $.fn.changeElementType = function(newType) {
      var attrs = {};

      $.each(this[0].attributes, function(idx, attr) {
        attrs[attr.nodeName] = attr.nodeValue;
      });

      this.replaceWith(function() {
        return $("<" + newType + "/>", attrs).append($(this).contents());
      });
    };
  })(jQuery);

  // prevent underline for linked images
  $('a > img').parent().css({'border-bottom' : 'none'});

  // mark non-body figures created by knitr chunks as 100% width
  $('.layout-chunk').each(function(i, val) {
    var figures = $(this).find('img, .html-widget');
    // ignore leaflet img layers (#106)
    figures = figures.filter(':not(img[class*="leaflet"])')
    if ($(this).attr('data-layout') !== "l-body") {
      figures.css('width', '100%');
    } else {
      figures.css('max-width', '100%');
      figures.filter("[width]").each(function(i, val) {
        var fig = $(this);
        fig.css('width', fig.attr('width') + 'px');
      });

    }
  });

  // auto-append index.html to post-preview links in file: protocol
  // and in rstudio ide preview
  $('.post-preview').each(function(i, val) {
    if (window.location.protocol === "file:")
      $(this).attr('href', $(this).attr('href') + "index.html");
  });

  // get rid of index.html references in header
  if (window.location.protocol !== "file:") {
    $('.distill-site-header a[href]').each(function(i,val) {
      $(this).attr('href', $(this).attr('href').replace(/^index[.]html/, "./"));
    });
  }

  // add class to pandoc style tables
  $('tr.header').parent('thead').parent('table').addClass('pandoc-table');
  $('.kable-table').children('table').addClass('pandoc-table');

  // add figcaption style to table captions
  $('caption').parent('table').addClass("figcaption");

  // initialize posts list
  if (window.init_posts_list)
    window.init_posts_list();

  // implmement disqus comment link
  $('.disqus-comment-count').click(function() {
    window.headroom_prevent_pin = true;
    $('#disqus_thread').toggleClass('hidden');
    if (!$('#disqus_thread').hasClass('hidden')) {
      var offset = $(this).offset();
      $(window).resize();
      $('html, body').animate({
        scrollTop: offset.top - 35
      });
    }
  });
}

document.addEventListener('DOMContentLoaded', function() {
  if (is_downlevel_browser())
    init_downlevel();
  else
    window.addEventListener('WebComponentsReady', init_distill);
});

</script>

<style type="text/css">
/* base variables */

/* Edit the CSS properties in this file to create a custom
   Distill theme. Only edit values in the right column
   for each row; values shown are the CSS defaults.
   To return any property to the default,
   you may set its value to: unset
   All rows must end with a semi-colon.                      */

/* Optional: embed custom fonts here with `@import`          */
/* This must remain at the top of this file.                 */



html {
  /*-- Main font sizes --*/
  --title-size:      50px;
  --body-size:       1.06rem;
  --code-size:       14px;
  --aside-size:      12px;
  --fig-cap-size:    13px;
  /*-- Main font colors --*/
  --title-color:     #000000;
  --header-color:    rgba(0, 0, 0, 0.8);
  --body-color:      rgba(0, 0, 0, 0.8);
  --aside-color:     rgba(0, 0, 0, 0.6);
  --fig-cap-color:   rgba(0, 0, 0, 0.6);
  /*-- Specify custom fonts ~~~ must be imported above   --*/
  --heading-font:    sans-serif;
  --mono-font:       monospace;
  --body-font:       sans-serif;
  --navbar-font:     sans-serif;  /* websites + blogs only */
}

/*-- ARTICLE METADATA --*/
d-byline {
  --heading-size:    0.6rem;
  --heading-color:   rgba(0, 0, 0, 0.5);
  --body-size:       0.8rem;
  --body-color:      rgba(0, 0, 0, 0.8);
}

/*-- ARTICLE TABLE OF CONTENTS --*/
.d-contents {
  --heading-size:    18px;
  --contents-size:   13px;
}

/*-- ARTICLE APPENDIX --*/
d-appendix {
  --heading-size:    15px;
  --heading-color:   rgba(0, 0, 0, 0.65);
  --text-size:       0.8em;
  --text-color:      rgba(0, 0, 0, 0.5);
}

/*-- WEBSITE HEADER + FOOTER --*/
/* These properties only apply to Distill sites and blogs  */

.distill-site-header {
  --title-size:       18px;
  --text-color:       rgba(255, 255, 255, 0.8);
  --text-size:        15px;
  --hover-color:      white;
  --bkgd-color:       #0F2E3D;
}

.distill-site-footer {
  --text-color:       rgba(255, 255, 255, 0.8);
  --text-size:        15px;
  --hover-color:      white;
  --bkgd-color:       #0F2E3D;
}

/*-- Additional custom styles --*/
/* Add any additional CSS rules below                      */
</style>
<style type="text/css">
/* base variables */

/* Edit the CSS properties in this file to create a custom
   Distill theme. Only edit values in the right column
   for each row; values shown are the CSS defaults.
   To return any property to the default,
   you may set its value to: unset
   All rows must end with a semi-colon.                      */

/* Optional: embed custom fonts here with `@import`          */
/* This must remain at the top of this file.                 */



html {
  /*-- Main font sizes --*/
  --title-size:      50px;
  --body-size:       1.06rem;
  --code-size:       14px;
  --aside-size:      12px;
  --fig-cap-size:    13px;
  /*-- Main font colors --*/
  --title-color:     #000000;
  --header-color:    rgba(0, 0, 0, 0.8);
  --body-color:      rgba(0, 0, 0, 0.8);
  --aside-color:     rgba(0, 0, 0, 0.6);
  --fig-cap-color:   rgba(0, 0, 0, 0.6);
  /*-- Specify custom fonts ~~~ must be imported above   --*/
  --heading-font:    sans-serif;
  --mono-font:       monospace;
  --body-font:       sans-serif;
  --navbar-font:     sans-serif;  /* websites + blogs only */
}

/*-- ARTICLE METADATA --*/
d-byline {
  --heading-size:    0.6rem;
  --heading-color:   rgba(0, 0, 0, 0.5);
  --body-size:       0.8rem;
  --body-color:      rgba(0, 0, 0, 0.8);
}

/*-- ARTICLE TABLE OF CONTENTS --*/
.d-contents {
  --heading-size:    18px;
  --contents-size:   13px;
}

/*-- ARTICLE APPENDIX --*/
d-appendix {
  --heading-size:    15px;
  --heading-color:   rgba(0, 0, 0, 0.65);
  --text-size:       0.8em;
  --text-color:      rgba(0, 0, 0, 0.7);
}

/*-- WEBSITE HEADER + FOOTER --*/
/* These properties only apply to Distill sites and blogs  */

.distill-site-header {
  --title-size:       18px;
  --text-color:       rgba(0, 0, 0, 0.8);
  --text-size:        15px;
  --hover-color:      black;
  --bkgd-color:       #ffffff;
}

.distill-site-footer {
  --text-color:       rgba(0, 0, 0, 0.8);
  --text-size:        15px;
  --hover-color:      black;
  --bkgd-color:       #fafafa;
}

/*-- Additional custom styles --*/
/* Add any additional CSS rules below                      */

.nav-right > a {
  text-transform: uppercase;
}

d-title h1, d-title p, d-title figure,
d-abstract p, d-abstract b {
  grid-column: page;
}

.rj-blue {
  color: #2467bb;
}

ul li {
  line-height: 1.6;
  margin-top: 0em;
  margin-bottom: 0em;
}</style>
<style type="text/css">
/* base style */

/* FONT FAMILIES */

:root {
  --heading-default: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
  --mono-default: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  --body-default: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
}

body,
.posts-list .post-preview p,
.posts-list .description p {
  font-family: var(--body-font), var(--body-default);
}

h1, h2, h3, h4, h5, h6,
.posts-list .post-preview h2,
.posts-list .description h2 {
  font-family: var(--heading-font), var(--heading-default);
}

d-article div.sourceCode code,
d-article pre code {
  font-family: var(--mono-font), var(--mono-default);
}


/*-- TITLE --*/
d-title h1,
.posts-list > h1 {
  color: var(--title-color, black);
}

d-title h1 {
  font-size: var(--title-size, 50px);
}

/*-- HEADERS --*/
d-article h1,
d-article h2,
d-article h3,
d-article h4,
d-article h5,
d-article h6 {
  color: var(--header-color, rgba(0, 0, 0, 0.8));
}

/*-- BODY --*/
d-article > p,  /* only text inside of <p> tags */
d-article > ul, /* lists */
d-article > ol {
  color: var(--body-color, rgba(0, 0, 0, 0.8));
  font-size: var(--body-size, 1.06rem);
}


/*-- CODE --*/
d-article div.sourceCode code,
d-article pre code {
  font-size: var(--code-size, 14px);
}

/*-- ASIDE --*/
d-article aside {
  font-size: var(--aside-size, 12px);
  color: var(--aside-color, rgba(0, 0, 0, 0.6));
}

/*-- FIGURE CAPTIONS --*/
figure .caption,
figure figcaption,
.figure .caption {
  font-size: var(--fig-cap-size, 13px);
  color: var(--fig-cap-color, rgba(0, 0, 0, 0.6));
}

/*-- METADATA --*/
d-byline h3 {
  font-size: var(--heading-size, 0.6rem);
  color: var(--heading-color, rgba(0, 0, 0, 0.5));
}

d-byline {
  font-size: var(--body-size, 0.8rem);
  color: var(--body-color, rgba(0, 0, 0, 0.8));
}

d-byline a,
d-article d-byline a {
  color: var(--body-color, rgba(0, 0, 0, 0.8));
}

/*-- TABLE OF CONTENTS --*/
.d-contents nav h3 {
  font-size: var(--heading-size, 18px);
}

.d-contents nav a {
  font-size: var(--contents-size, 13px);
}

/*-- APPENDIX --*/
d-appendix h3 {
  font-size: var(--heading-size, 15px);
  color: var(--heading-color, rgba(0, 0, 0, 0.65));
}

d-appendix {
  font-size: var(--text-size, 0.8em);
  color: var(--text-color, rgba(0, 0, 0, 0.5));
}

d-appendix d-footnote-list a.footnote-backlink {
  color: var(--text-color, rgba(0, 0, 0, 0.5));
}

/*-- WEBSITE HEADER + FOOTER --*/
.distill-site-header .title {
  font-size: var(--title-size, 18px);
  font-family: var(--navbar-font), var(--heading-default);
}

.distill-site-header a,
.nav-dropdown .nav-dropbtn {
  font-family: var(--navbar-font), var(--heading-default);
}

.nav-dropdown .nav-dropbtn {
  color: var(--text-color, rgba(255, 255, 255, 0.8));
  font-size: var(--text-size, 15px);
}

.distill-site-header a:hover,
.nav-dropdown:hover .nav-dropbtn {
  color: var(--hover-color, white);
}

.distill-site-header {
  font-size: var(--text-size, 15px);
  color: var(--text-color, rgba(255, 255, 255, 0.8));
  background-color: var(--bkgd-color, #0F2E3D);
}

.distill-site-footer {
  font-size: var(--text-size, 15px);
  color: var(--text-color, rgba(255, 255, 255, 0.8));
  background-color: var(--bkgd-color, #0F2E3D);
}

.distill-site-footer a:hover {
  color: var(--hover-color, white);
}</style>
<!--/radix_placeholder_distill-->
  <script src="../../site_libs/header-attrs-2.29/header-attrs.js"></script>
  <script src="../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
  <script src="../../site_libs/popper-2.6.0/popper.min.js"></script>
  <link href="../../site_libs/tippy-6.2.7/tippy.css" rel="stylesheet" />
  <link href="../../site_libs/tippy-6.2.7/tippy-light-border.css" rel="stylesheet" />
  <script src="../../site_libs/tippy-6.2.7/tippy.umd.min.js"></script>
  <script src="../../site_libs/anchor-4.2.2/anchor.min.js"></script>
  <script src="../../site_libs/bowser-1.9.3/bowser.min.js"></script>
  <script src="../../site_libs/webcomponents-2.0.0/webcomponents.js"></script>
  <script src="../../site_libs/distill-2.2.21/template.v2.js"></script>
  <!--radix_placeholder_site_in_header-->
<!--/radix_placeholder_site_in_header-->
  <script>
    $(function() {
      console.log("Starting...")

      // Mathjax config (add automatic linebreaks when supported)
      // MathJax = {
      //    tex: {
      //        inlineMath: [['$', '$'], ['\\(', '\\)']],
      //        displayMath: [['$$', '$$'], ['\\[', '\\]']],
      //        tags: 'ams',
      //        multline: true,
      //    },
      //    options: {
      //        linebreaks: { automatic: true },
      //    },
      // };

      // Always show Published - distill hides it if not set
      function show_byline_column(caption) {
        $('d-byline').find('h3:contains("' + caption + '")').parent().css('visibility', 'visible');
      }

      show_byline_column('Published')

      // tweak function
      var rmd_meta = JSON.parse($("#radix-rmarkdown-metadata").html());
      function get_meta(name, meta) {
        var ind = meta.attributes.names.value.findIndex((e) => e == name)
        var val = meta.value[ind]
        if (val.type != 'list') {
          return val.value.toString()
        }
        return val
      }

      // tweak description
      // Add clickable tags
      const slug = get_meta('slug', rmd_meta)
      const cite_url = get_meta('citation_url', rmd_meta)

      var title = $("d-title").text

      const buttons = $('<div class="dt-tags" style="grid-column: page;">')
      buttons.append('<a href="#citation" class="dt-tag"><i class="fas fa-quote-left"></i> Cite</a>')
      buttons.append('<a href="' + slug + '.pdf" class="dt-tag"><i class="fas fa-file-pdf"></i> PDF</a>')
      buttons.append('<a href="' + slug + '.zip" class="dt-tag"><i class="fas fa-file-zipper"></i> Supplement</a>')

      // adds Abstract: in front of the first <p> in the title section --
      // unless it happens to be the subtitle (FIXME: this is a bad hack - can't distill do this?)
      var tpar = $("d-title p:not(:empty)").filter(function() {
        return !$(this).hasClass("subtitle");
      }).first();
      if (tpar) {
        const abstract = $('<d-abstract>')
        abstract.append('<b>Abstract:</b><br>')
        abstract.append(tpar) // Move description to d-abstract
        $("d-title p:empty").remove() // Remove empty paragraphs after title
        abstract.append(buttons)
        abstract.insertAfter($('d-title')) // Add abstract section after title */
      }

      // tweak by-line
      var byline = $("d-byline div.byline")
      ind = rmd_meta.attributes.names.value.findIndex((e) => e == "journal")
      const journal = get_meta('journal', rmd_meta)
      const volume = get_meta('volume', rmd_meta)
      const issue = get_meta('issue', rmd_meta)
      const jrtitle = get_meta('title', journal)
      const year = ((jrtitle == "R News") ? 2000 : 2008) + parseInt(volume)
      const firstpage = get_meta('firstpage', journal)
      const lastpage = get_meta('lastpage', journal)
      byline.append('<div class="rjournal grid">')
      $('div.rjournal').append('<h3>Volume</h3>')
      $('div.rjournal').append('<h3>Pages</h3>')
      $('div.rjournal').append('<a class="volume" href="../../issues/'+year+'-'+issue+'">'+volume+'/'+issue+'</a>')
      $('div.rjournal').append('<p class="pages">'+firstpage+' - '+lastpage+'</p>')

      const received_date = new Date(get_meta('date_received', rmd_meta))
      byline.find('h3:contains("Published")').parent().append('<h3>Received</h3><p>'+received_date.toLocaleDateString('en-US', {month: 'short'})+' '+received_date.getDate()+', '+received_date.getFullYear()+'</p>')

    })
  </script>

  <style>
      /*
    .nav-dropdown-content .nav-dropdown-header {
      text-transform: lowercase;
    }
    */

    d-byline .byline {
      grid-template-columns: 2fr 2fr 2fr 2fr;
    }

    d-byline .rjournal {
      grid-column-end: span 2;
      grid-template-columns: 1fr 1fr;
      margin-bottom: 0;
    }

    d-title h1, d-title p, d-title figure,
    d-abstract p, d-abstract b {
      grid-column: page;
    }

    d-title .dt-tags {
      grid-column: page;
    }

    .dt-tags .dt-tag {
      text-transform: lowercase;
    }

    d-article h1 {
      line-height: 1.1em;
    }

    d-abstract p, d-article p {
      text-align: justify;
    }

    @media(min-width: 1000px) {
      .d-contents.d-contents-float {
        justify-self: end;
      }

      nav.toc {
        border-right: 1px solid rgba(0, 0, 0, 0.1);
        border-right-width: 1px;
        border-right-style: solid;
        border-right-color: rgba(0, 0, 0, 0.1);
      }
    }

    .posts-list .dt-tags .dt-tag {
      text-transform: lowercase;
    }

    @keyframes highlight-target {
      0% {
        background-color: #ffa;
      }
      66% {
        background-color: #ffa;
      }
      100% {
        background-color: none;
      }
    }

    d-article :target, d-appendix :target {
       animation: highlight-target 3s;
    }

    .header-section-number {
      margin-right: 0.5em;
    }

    d-appendix .citation-appendix,
    .d-appendix .citation-appendix {
      color: rgb(60, 60, 60);
    }

    d-article h2 {
      border-bottom: 0px solid rgba(0, 0, 0, 0.1);
      padding-bottom: 0rem;
    }
    d-article h3 {
      font-size: 20px;
    }
    d-article h4 {
      font-size: 18px;
      text-transform: none;
    }

    @media (min-width: 1024px) {
      d-article h2 {
        font-size: 32px;
      }
      d-article h3 {
        font-size: 24px;
      }
      d-article h4 {
        font-size: 20px;
      }
    }
  </style>


</head>

<body>

<!--radix_placeholder_front_matter-->

<script id="distill-front-matter" type="text/json">
{"title":"`clarify`: Simulation-Based Inference for Regression Models","description":"Simulation-based inference is an alternative to the delta method for\ncomputing the uncertainty around regression post-estimation (i.e.,\nderived) quantities such as average marginal effects, average adjusted\npredictions, and other functions of model parameters. It works by\ndrawing model parameters from their joint distribution and estimating\nquantities of interest from each set of simulated values, which form a\nsimulated \"posterior\" distribution of the quantity from which\nconfidence intervals can be computed. `clarify` provides a simple,\nunified interface for performing simulation-based inference for any\nuser-specified derived quantities as well as wrappers for common\nquantities of interest. `clarify` supports a large and growing number\nof models through its interface with the `marginaleffects` package and\nprovides native support for multiply imputed data.","doi":"10.32614/RJ-2024-015","authors":[{"author":"Noah Greifer","authorURL":"#","affiliation":"Harvard University","affiliationURL":"#","orcidID":""},{"author":"Steven Worthington","authorURL":"#","affiliation":"Harvard University","affiliationURL":"#","orcidID":""},{"author":"Stefano Iacus","authorURL":"#","affiliation":"Harvard University","affiliationURL":"#","orcidID":""},{"author":"Gary King","authorURL":"#","affiliation":"Harvard University","affiliationURL":"#","orcidID":""}],"publishedDate":"2025-01-31T00:00:00.000+00:00","citationText":"Greifer, et al., 2025"}
</script>

<!--/radix_placeholder_front_matter-->
<!--radix_placeholder_navigation_before_body-->
<header class="header header--fixed" role="banner">
<nav class="distill-site-nav distill-site-header">
<div class="nav-left">
<a class="logo" href="../../index.html">
<img src="../../resources/rlogo.png" alt="Logo"/>
</a>
<a href="../../index.html" class="title">The R Journal</a>
</div>
<div class="nav-right">
<a href="../../index.html">Home</a>
<a href="../../issues/2024-1">Current</a>
<a href="../../issues.html">Issues</a>
<a href="../../news.html">News</a>
<a href="../../submissions.html">Submit</a>
<a href="../../editors.html">Editorial board</a>
<a href="../../articles.xml">
<i class="fa fa-rss" aria-hidden="true"></i>
</a>
<a href="javascript:void(0);" class="nav-toggle">&#9776;</a>
</div>
</nav>
</header>
<!--/radix_placeholder_navigation_before_body-->
<!--radix_placeholder_site_before_body-->
<!--/radix_placeholder_site_before_body-->

<div class="d-title">
<h1>clarify: Simulation-Based Inference for Regression Models</h1>

<!--radix_placeholder_categories-->
<!--/radix_placeholder_categories-->
<p><p>Simulation-based inference is an alternative to the delta method for
computing the uncertainty around regression post-estimation (i.e.,
derived) quantities such as average marginal effects, average adjusted
predictions, and other functions of model parameters. It works by
drawing model parameters from their joint distribution and estimating
quantities of interest from each set of simulated values, which form a
simulated “posterior” distribution of the quantity from which
confidence intervals can be computed. <code>clarify</code> provides a simple,
unified interface for performing simulation-based inference for any
user-specified derived quantities as well as wrappers for common
quantities of interest. <code>clarify</code> supports a large and growing number
of models through its interface with the <code>marginaleffects</code> package and
provides native support for multiply imputed data.</p></p>
</div>

<div class="d-byline">
  Noah Greifer  (Harvard University)
  
,   Steven Worthington  (Harvard University)
  
,   Stefano Iacus  (Harvard University)
  
,   Gary King  (Harvard University)
  
<br/>2025-01-31
</div>

<div class="d-article">
<div class="article">
<h3 data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction</h3>
<p>Although regression models are frequently used in empirical research to
study relationships among variables, often the quantity of substantive
interest is not one of the coefficients of the model, but rather a
quantity derived from the coefficients, such as predicted values or
average marginal effects. Quantifying the uncertainty of these derived
quantities (i.e., computing standard errors, confidence intervals, and
p-values) requires additional processing. Several methods of doing so
exist, including the delta method, the bootstrap, and simulation-based
inference. <a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a>
implements simulation-based inference, which we describe below along
with these other methods.</p>
<p>The delta method involves computing a first-order Taylor series
approximation to the variance of the derived quantity, and standard
Wald-based inference relies on computing quantiles based on the Normal
distribution and using them to compute p-values and confidence
intervals. <a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a>
implements an alternative to the delta method—simulation-based
inference—which involves simulating a “posterior” distribution of the
derived quantities. Simulation-based inference does not require
understanding Taylor series or the calculus that underlies it, which can
make it more palatable to nontechnical audiences and easier to learn for
students without necessarily sacrificing statistical performance (King,
Tomz, and Wittenberg 2000; Zelner 2009). Some studies have found that
simulation-based inference performs as well or better than the delta
method for computing derived quantities (i.e., with respect to achieving
close to nominal coverage for confidence intervals), especially for
complicated derived quantities and in smaller samples (MacKinnon,
Lockwood, and Williams 2004; Hole 2007; Herron 1999). Its empirical
performance has been particularly well studied in the context of
mediation analysis, in which the quantities of interest are products and
ratios of regression coefficients, where it has been shown to perform
well relative to the delta method due to the non-Normality of these
quantities (Tofighi and MacKinnon 2016; Preacher and Selig 2012).</p>
<p>The methodology
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> relies on was
developed by Krinsky and Robb (1986) and is described in King, Tomz, and
Wittenberg (2000) and Herron (1999). Simulation-based inference involves
taking draws from a specified joint distribution of model parameters,
computing derived quantities from these draws, and collecting the
derived quantities in a “posterior” distribution, from which uncertainty
measures (standard errors and confidence intervals) can be computed.
This method assumes the model parameters are drawn from a multivariate
Normal (or T) distribution with means at the estimated values and
covariance equal to the asymptotic covariance matrix of the estimated
values, a standard assumption motivated by the central limit theorem
that underlies usual inference on the original model parameters.
Arriving at the posterior distribution does not require taking any
derivatives or making any approximations beyond those usually used for
inference on model parameter estimates, except for the approximation due
to Monte Carlo error induced by sampling from a finite number of
simulations (which can always be reduced by increasing the number of
draws at the cost of increased computing time).</p>
<p>The nonparametric bootstrap is another alternative to the delta method
for inference that does not require its analytic approximations (Efron
and Tibshirani 1986); bootstrapping typically involves re-sampling
individuals from the sample, fitting the model in each bootstrap sample,
and computing the quantity of interest from each model. Although
bootstrapping tends to work well in practice, especially for complex and
non-Normal estimators, refitting the model repeatedly can be
prohibitively time-consuming and computationally expensive, especially
for complicated models or large datasets. Simulation-based inference
only requires the model to be fit once, and the simulations involve
taking draws from a distribution produced from the single set of
estimated parameters, making it much quicker in practice and allowing
the user to capitalize on the already valid estimation of the model
parameters. Methods for computing valid confidence intervals in cases
when the quantity of interest has a complicated distribution are better
developed when bootstrapping, however (Efron and Tibshirani 1986).</p>
<p>More formally, we fit a regression model <span class="math inline">\(y_i = f(x_i; \beta)\)</span>, such as
a linear or other generalized linear model with model coefficients
<span class="math inline">\(\beta\)</span>. We assume
<span class="math display">\[\hat{\beta} \sim \text{MVN}(\beta, \Sigma_{\hat{\beta}})\]</span>
where <span class="math inline">\(\hat{\beta}\)</span> is the vector of estimates of <span class="math inline">\(\beta\)</span> and
<span class="math inline">\(\Sigma_{\hat{\beta}}\)</span> is their asymptotic covariance matrix. We define
a function <span class="math inline">\(\tau(\beta)\)</span> that represents a quantity of interest derived
from the model parameters, and compute its estimate
<span class="math inline">\(\widehat{\tau(\beta)}\)</span> as <span class="math inline">\(\tau(\hat{\beta})\)</span>. To perform
simulation-based inference, we take <span class="math inline">\(M\)</span> draws <span class="math inline">\(\tilde{\beta}^{(j)}\)</span> for
<span class="math inline">\(j\in(1, \dots, M)\)</span> from a multivariate Normal distribution with mean
vector <span class="math inline">\(\mu = \hat{\beta}\)</span> and covariance
<span class="math inline">\(\Sigma = \hat{\Sigma}_{\hat{\beta}}\)</span>, where
<span class="math inline">\(\hat{\Sigma}_{\hat{\beta}}\)</span> is an estimate of the asymptotic covariance
matrix of the parameter estimates. We use the distribution of
<span class="math inline">\(\tilde{\tau}=\tau(\tilde{\beta})\)</span> as the “posterior” distribution of
<span class="math inline">\(\widehat{\tau(\beta)}\)</span>, and compute its variance as
<span class="math display">\[\hat\sigma^2_{\widehat{\tau(\beta)}} = \frac{1}{M-1}\sum^M_{j=1}{(\tilde{\tau}^{(j)} - \bar{\tilde{\tau}})^2}\]</span>
and quantile <span class="math inline">\(100(1-\alpha)\%\)</span> confidence interval limits as
<span class="math inline">\(\left[\tilde{\tau}_{(\frac{\alpha}{2})}, \tilde{\tau}_{(1-\frac{\alpha}{2})}\right]\)</span>
where <span class="math inline">\(\tilde{\tau}_{(q)}\)</span> is the <span class="math inline">\(q\)</span>th value of <span class="math inline">\(\tilde{\tau}\)</span> when
arranged in ascending order (i.e., the <span class="math inline">\(q\)</span>th quantile of the empirical
cumulative distribution function). Simulation-based Wald-type confidence
intervals can be computed as
<span class="math inline">\(\left[\tau(\hat{\beta}) + \hat\sigma_{\widehat{\tau(\beta)}} Z_{\frac{\alpha}{2}}, \tau(\hat{\beta}) + \hat\sigma_{\widehat{\tau(\beta)}} Z_{1-\frac{\alpha}{2}} \right]\)</span>,
where <span class="math inline">\(Z_q\)</span> is the <span class="math inline">\(q\)</span>th quantile of a standard Normal distribution. The
delta method-based Wald-type confidence intervals use this formula but
with the first-order Taylor approximation to the asymptotic variance:
<span class="math inline">\(\hat\sigma^2_{\widehat{\tau(\beta)}}=\nabla\tau(\hat{\beta}) \Sigma_{\hat{\beta}} \nabla\tau&#39;(\hat{\beta})\)</span>,
where <span class="math inline">\(\nabla\tau(\hat{\beta})\)</span> is the gradient of <span class="math inline">\(\tau(\beta)\)</span> with
respect to <span class="math inline">\(\beta\)</span> evaluated at <span class="math inline">\(\hat{\beta}\)</span>.</p>
<p>To compute a p-value for a hypothesis test involving the quantity of
interest, i.e., <span class="math inline">\(\text{H}_0: \tau (\beta) = \tau_0\)</span> with a given null
value <span class="math inline">\(\tau_0\)</span>, we can invert the confidence interval (Thulin 2021);
that is, we find the largest value of <span class="math inline">\(\alpha\)</span> such that <span class="math inline">\(\tau_0\)</span> is
within the confidence interval and use that <span class="math inline">\(\alpha\)</span> as the p-value for
the test. For Wald-based inference (either using the simulation-based
variance or delta method-based variance), this is equivalent to
performing a standard two-sided Z-test using the test statistic
<span class="math inline">\(Z=\left(\tau(\hat\beta)-\tau_0\right) / \hat\sigma_{\widehat{\tau(\beta)}}\)</span>.
One benefit of using the quantile p-values for inference is that
equivalent tests of the same hypothesis will always yield identical
p-values; for example, testing the equality of two derived quantities
will yield the same p-value when comparing the difference between the
quantities against a null hypothesis of 0 and the ratio of the
quantities against a null hypothesis of 1, as each of these hypothesis
is true if and only if the other is true.</p>
<p>One would expect simulation-based quantile inference, simulation-based
Wald inference, and delta method-based Wald inference to align when the
posterior is Normally distributed around the estimate, in which case any
discrepancies would be due to Monte Carlo error in the simulated values
(and therefore would shrink with increasing draws). However, for low
values of <span class="math inline">\(\alpha\)</span>, it may require many draws for the simulation-based
intervals to stabilize; delta method-based intervals are not subject to
this error. There are a few cases in which the results might diverge: in
some cases, the first-order Taylor series approximation to the variance
may be poor, though in practice the approximation error is small and
shrinks quickly with increasing sample size. When the posterior
distribution is non-Normal but symmetric around the estimate, the
quantile intervals may be more accurate (i.e., in the sense of achieving
closer to nominal coverage) because they do not rely on quantiles from
the Normal distribution (Tofighi and MacKinnon 2016).</p>
<p>Another potential advantage quantile intervals can have over
Wald-intervals is that when <em>some</em> monotonic transformation of the
estimate has a symmetric distribution centered around the transformed
estimate, the quantile intervals can achieve correct coverage without
requiring knowledge of <em>which</em> transformation is required (Efron and
Tibshirani 1986); this is true of the quantile-based p-values as well.
When the distribution is not centered around the estimate and no
monotonic transformation will make it so, though, neither quantile-based
nor Wald-based intervals would be expected to perform well, and quantile
intervals could yield even worse coverage than Wald-based intervals, a
phenomenon that occurs in the context of bootstrapping <span class="math display">\[Efron and
Tibshirani (1986)\]</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. An informal falsification test for whether such
a monotonic transformation exists is whether the median of the simulated
estimates is aligned with the point estimate; if it is not, there is no
monotonic transformation that will yield a symmetric quantile interval
with the desired coverage.</p>
<h3 data-number="2" id="related-software"><span class="header-section-number">2</span> Related Software</h3>
<p>Similar functionality exists in the <strong>CLARIFY</strong> package in Stata<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>
(Tomz, Wittenberg, and King 2003) and used to be available in the
<code>Zelig</code> R package (Imai, King, and Lau 2008), though there are
differences in these implementations.
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> provides
additional flexibility by allowing the user to request any derived
quantity, in addition to providing shortcuts for common quantities,
including predictions at representative values, average marginal
effects, and average dose-response functions (described below).
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> relies on and
can be seen as a companion to the
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
package (Arel-Bundock, Greifer, and Heiss Forthcoming), which offers
similar functionality but primarily uses the delta method for
calculating uncertainty (though simulation-based inference is supported
in a more limited capacity as well).</p>
<h3 data-number="3" id="using"><span class="header-section-number">3</span> Using <a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a></h3>
<p>There are four steps to using
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a>:</p>
<ol type="1">
<li><p>Fit the model to the data using modeling functions in supported
packages.</p></li>
<li><p>Use <code>sim()</code> to take draws from the multivariate distribution of the
estimated model coefficients.</p></li>
<li><p>Use <code>sim_apply()</code> or its wrappers <code>sim_setx()</code>, <code>sim_ame()</code>, and
<code>sim_adrf()</code> to compute derived quantities using each simulated set
of coefficients.</p></li>
<li><p>Use <code>summary()</code> and <code>plot()</code> to summarize and visualize the
distribution of the derived quantities and perform inference on
them.</p></li>
</ol>
<p>In the sections below, we will describe how to implement these steps in
detail. First, we will load
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> using
<code>library()</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(clarify)</span></code></pre></div>
<p>For a running example, we will use the <code>lalonde</code> dataset in the
<a href="https://CRAN.R-project.org/package=MatchIt"><strong>MatchIt</strong></a> package (Ho et
al. 2011), which contains data on 614 participants enrolled in a job
training program or sampled from a survey (Dehejia and Wahba 1999). The
treatment variable is <code>treat</code> and the outcome is <code>re78</code>, and all other
variables are confounders. Although the original use of this dataset was
to estimate the effect of <code>treat</code> on <code>re78</code>, we will use it more
generally to demonstrate all of
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a>’s
capabilities. In addition, we will use a transformation of the outcome
variable to demonstrate applications to nonlinear models, for which the
benefits of simulation-based inference are more apparent.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;lalonde&quot;</span>, <span class="at">package =</span> <span class="st">&quot;MatchIt&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a binary outcome variable</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>lalonde<span class="sc">$</span>re78_0 <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(lalonde<span class="sc">$</span>re78 <span class="sc">&gt;</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(lalonde)</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      treat age educ   race married nodegree re74 re75       re78 re78_0</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; NSW1     1  37   11  black       1        1    0    0  9930.0460      1</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; NSW2     1  22    9 hispan       0        1    0    0  3595.8940      1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; NSW3     1  30   12  black       0        0    0    0 24909.4500      1</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; NSW4     1  27   11  black       0        1    0    0  7506.1460      1</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; NSW5     1  33    8  black       0        1    0    0   289.7899      1</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; NSW6     1  22    9  black       0        1    0    0  4056.4940      1</span></span></code></pre></div>
<h4 class="unnumbered" data-number="3.1" id="fitting-the-model">1. Fitting the model</h4>
<p>The first step is to fit the model.
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> can operate on
a large set of models (those supported by
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>),
including generalized linear models, multinomial models, multivariate
models, and instrumental variable models, many of which are available in
other R packages. Even if
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> does not offer
direct support for a given model, there are ways to use its
functionality regardless (explained in more detail below).</p>
<p>Because we are computing derived quantities, it is not critical to
parameterize the model in such a way that the coefficients are
interpretable, e.g., by using a model with interpretable coefficients or
centering predictors. Below, we will fit a probit regression model for
the outcome given the treatment and confounders. Coefficients in probit
regression do not have a straightforward interpretation, but that does
not matter; our quantities of interest can be expressed as derived
quantities—functions of the model parameters, such as predictions,
counterfactual predictions, and averages and contrasts of them.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">glm</span>(re78_0 <span class="sc">~</span> treat <span class="sc">*</span> married <span class="sc">+</span> age <span class="sc">+</span> educ <span class="sc">+</span> race <span class="sc">+</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>             nodegree <span class="sc">+</span> re74 <span class="sc">+</span> re75, <span class="at">data =</span> lalonde,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">family =</span> <span class="fu">binomial</span>(<span class="st">&quot;probit&quot;</span>))</span></code></pre></div>
<h4 class="unnumbered" data-number="3.2" id="drawing-from-the-coefficient-distribution">2. Drawing from the coefficient distribution</h4>
<p>After fitting the model, we will use <code>sim()</code> to draw coefficients from
their sampling distribution. The sampling distribution is assumed to be
multivariate Normal or multivariate T with appropriate degrees of
freedom, with a mean vector equal to the estimated coefficients and a
covariance matrix equal to the asymptotic covariance matrix extracted
from the model. The arguments to <code>sim()</code> are listed below:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sim</span>(<span class="at">fit =</span> , <span class="at">n =</span> , <span class="at">vcov =</span> , <span class="at">coefs =</span> , <span class="at">dist =</span> )</span></code></pre></div>
<ul>
<li><p><code>fit</code> – the fitted model object, the output of the call to the
fitting function (e.g., <code>glm()</code>)</p></li>
<li><p><code>n</code> – the number of simulated values to draw; by default, 1000.
More values will yield more replicable and precise results at the
cost of speed.</p></li>
<li><p><code>vcov</code> – either the covariance matrix of the estimated
coefficients, a function used to extract it from the model (e.g.,
<code>sandwich::vcovHC()</code> for the robust covariance matrix), or a string
or formula giving a code for extracting the covariance matrix, which
is passed to <code>marginaleffects::get_vcov()</code>. If left unspecified, the
default covariance matrix will be extracted from the model.</p></li>
<li><p><code>coefs</code> – either a vector of coefficients to be sampled or a
function to extract them from the fitted model. If left unspecified,
the default coefficients will be extracted from the model. Typically
this does not need to be specified.</p></li>
<li><p><code>dist</code> – the name of the distribution from which to draw the
sampled coefficients. Can be <code>"normal"</code> for a Normal distribution or
<code>t(#)</code> for a T-distribution, where <code>#</code> represents the degrees of
freedom. If left unspecified, <code>sim()</code> will decide on which
distribution makes sense given the characteristics of the model (the
decision is made by <code>insight::get_df()</code> with <code>type = "wald"</code>).
Typically this does not need to be specified.</p></li>
</ul>
<p>If one’s model is not supported by
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a>, one can omit
the <code>fit</code> argument and just specify the <code>vcov</code> and <code>coefs</code> argument,
which will draw the coefficients from the distribution named in <code>dist</code>
(<code>"normal"</code> by default).</p>
<p><code>sim()</code> uses a random number generator to draw the sampled coefficients
from the sampling distribution, so a seed should be set using
<code>set.seed()</code> to ensure results are replicable across sessions. Using
more iterations (i.e., increasing <code>n</code>) yields results that will be more
stable across runs even when a seed is not set.</p>
<p>The output of the call to <code>sim()</code> is a <code>clarify_sim</code> object, which
contains the sampled coefficients, the original model fit object if
supplied, and the coefficients and covariance matrix used to sample.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Drawing 1000 simulated coefficients using an HC2 robust</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># covariance matrix</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>s <span class="ot">&lt;-</span> <span class="fu">sim</span>(fit, <span class="at">n =</span> <span class="dv">1000</span>,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>         <span class="at">vcov =</span> <span class="st">&quot;HC2&quot;</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>s</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; A `clarify_sim` object</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  - 11 coefficients, 1000 simulated values</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  - sampled distribution: multivariate normal</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  - original fitting function call:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; glm(formula = re78_0 ~ treat * married + age + educ + race + </span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     nodegree + re74 + re75, family = binomial(&quot;probit&quot;), data = lalonde)</span></span></code></pre></div>
<h4 class="unnumbered" data-number="3.3" id="computing-derived-quantities">3. Computing derived quantities</h4>
<p>After sampling the coefficients, one can compute derived quantities on
each set of sampled coefficients and store the result, which represents
the “posterior” distribution of the derived quantity, as well as on the
original coefficients, which are used as the final estimates. The core
functionality is provided by <code>sim_apply()</code>, which accepts a
<code>clarify_sim</code> object from <code>sim()</code> and a function to compute and return
one or more derived quantities, then applies that function to each set
of simulated coefficients. The arguments to <code>sim_apply()</code> are below:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sim_apply</span>(<span class="at">sim =</span> , <span class="at">FUN =</span> , <span class="at">verbose =</span> , <span class="at">cl =</span> , ...)</span></code></pre></div>
<ul>
<li><p><code>sim</code> – a <code>clarify_sim</code> object; the output of a call to <code>sim()</code>.</p></li>
<li><p><code>FUN</code> – a function that takes in either a model fit object or a
vector of coefficients and returns one or more derived quantities.
The first argument should be named <code>fit</code> to take in a model fit
object or <code>coefs</code> to take in coefficients.</p></li>
<li><p><code>verbose</code> – whether to display a progress bar.</p></li>
<li><p><code>cl</code> – an argument that controls parallel processing, which can be
the number of cores to use or a cluster object resulting from
<code>parallel::makeCluster()</code>.</p></li>
<li><p><code>...</code> – further arguments to <code>FUN</code>.</p></li>
</ul>
<p>The <code>FUN</code> argument can be specified in one of two ways: either as a
function that takes in a model fit object (e.g., a <code>glm</code> or <code>lm</code> object,
the output of a call to <code>glm()</code> or <code>lm()</code>) or a function that takes in a
vector of coefficients. The latter will always work but the former only
works for supported models. When the function takes in a model fit
object, <code>sim_apply()</code> will first insert each set of sampled coefficients
into the model fit object and then supply the modified model to <code>FUN</code>.</p>
<p>For example, we will let our derived quantity of interest be the
predicted probability of the outcome for participant PSID1. We specify
our <code>FUN</code> function as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>sim_fun1 <span class="ot">&lt;-</span> <span class="cf">function</span>(fit) {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">predict</span>(fit, <span class="at">newdata =</span> lalonde[<span class="st">&quot;PSID1&quot;</span>,], <span class="at">type =</span> <span class="st">&quot;response&quot;</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The <code>fit</code> object supplied to this function will be one in which the
coefficients have been set to their values in a draw from their sampling
distribution as generated by <code>sim()</code>. We then supply the function to
<code>sim_apply()</code> to simulate the sampling distribution of the predicted
value of interest:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>est1 <span class="ot">&lt;-</span> <span class="fu">sim_apply</span>(s, <span class="at">FUN =</span> sim_fun1, <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>est1</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; A `clarify_est` object (from `sim_apply()`)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  - 1000 simulated values</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  - 1 quantity estimated:                </span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  PSID1 0.9757211</span></span></code></pre></div>
<p>The resulting <code>clarify_est</code> object contains the simulated estimates in
matrix form as well as the estimate computed on the original
coefficients. We will examine the posterior distribution shortly, but
first we will demonstrate computing a derived quantity from the
coefficients directly.</p>
<p>The <code>race</code> variable is a factor, and the <code>black</code> category is used as the
reference level, so it is not immediately clear whether there is a
difference between the coefficients <code>racehispan</code> and <code>racewhite</code>, which
represent the non-reference categories <code>hispan</code> and <code>white</code>. To compare
these two directly, we can use <code>sim_apply()</code> to compute a derived
quantity that corresponds to the difference between them.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>sim_fun2 <span class="ot">&lt;-</span> <span class="cf">function</span>(coefs) {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  hispan <span class="ot">&lt;-</span> <span class="fu">unname</span>(coefs[<span class="st">&quot;racehispan&quot;</span>])</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  white <span class="ot">&lt;-</span> <span class="fu">unname</span>(coefs[<span class="st">&quot;racewhite&quot;</span>])</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="st">&quot;w - h&quot;</span> <span class="ot">=</span> white <span class="sc">-</span> hispan)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>est2 <span class="ot">&lt;-</span> <span class="fu">sim_apply</span>(s, <span class="at">FUN =</span> sim_fun2, <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>est2</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; A `clarify_est` object (from `sim_apply()`)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  - 1000 simulated values</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  - 1 quantity estimated:                  </span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  w - h -0.09955915</span></span></code></pre></div>
<p>The function supplied to <code>FUN</code> can be arbitrarily complicated and return
as many derived quantities as one wants, though the slower each run of
<code>FUN</code> is, the longer it will take to simulate the derived quantities.
Using parallel processing by supplying an argument to <code>cl</code> can sometimes
dramatically speed up evaluation.</p>
<p>There are several functions in
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> that serve as
convenience wrappers for <code>sim_apply()</code> to automate some common derived
quantities of interest. These include</p>
<ul>
<li><p><code>sim_setx()</code> – computing predicted values and first differences at
representative or user-specified values of the predictors</p></li>
<li><p><code>sim_ame()</code> – computing average adjusted predictions, contrasts of
average adjusted predictions, and average marginal effects</p></li>
<li><p><code>sim_adrf()</code> – computing average dose-response functions and
average marginal effects functions</p></li>
</ul>
<p>These are described in their own sections below. In addition, there are
functions that have methods for <code>clarify_est</code> objects, including
<code>cbind()</code> for combining two <code>clarify_est</code> objects together and
<code>transform()</code> for computing quantities that are derived from the
already-computed derived quantities. These are also described in their
own sections below.</p>
<h4 class="unnumbered" data-number="3.4" id="summarize-and-visualize-the-simulated-distribution">4. Summarize and visualize the simulated distribution</h4>
<p>To examine the uncertainty around and perform inference on our estimated
quantities, we can use <code>plot()</code> and <code>summary()</code> on the <code>clarify_est</code>
object.</p>
<p><code>plot()</code> displays a density plot of the resulting estimates across the
simulations, with markers identifying the point estimate (computed using
the original model coefficients as recommended by Rainey (2023)) and,
optionally, uncertainty bounds (which function like confidence or
credible interval bounds). The arguments to <code>plot()</code> are below:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="at">x =</span> , <span class="at">parm =</span> , <span class="at">ci =</span> , <span class="at">level =</span> , <span class="at">method =</span> , <span class="at">reference =</span>)</span></code></pre></div>
<ul>
<li><p><code>x</code> – the <code>clarify_est</code> object (the output of a call to
<code>sim_apply()</code>).</p></li>
<li><p><code>parm</code> – the names or indices of the quantities to be plotted if
more than one was estimated in <code>sim_apply()</code>; if unspecified, all
will be plotted.</p></li>
<li><p><code>ci</code> – whether to display lines at the uncertainty bounds. The
default is <code>TRUE</code> to display them.</p></li>
<li><p><code>level</code> – if <code>ci</code> is <code>TRUE</code>, the desired two-sided confidence
level. The default is .95 so that that the bounds are at the .025
and .975 quantiles when <code>method</code> (see below) is <code>"quantile"</code>.</p></li>
<li><p><code>method</code> – if <code>ci</code> is <code>TRUE</code>, the method used to compute the
bounds. Allowable methods include thea Normal approximation
(<code>"wald"</code>) or using the quantiles of the resulting distribution
(<code>"quantile"</code>). The Normal approximation involves multiplying the
standard deviation of the estimates (i.e., which functions like the
standard error of the sampling distribution) by the critical
Z-statistic computed using <code>(1-level)/2</code> to create a symmetric
margin of error around the point estimate. The default is
<code>"quantile"</code> to instead use quantile-based bounds.</p></li>
<li><p><code>reference</code> – whether to display a normal density over the plot for
each estimate and an indicator line for the median of the estimate.
The default is <code>FALSE</code> to omit them.</p></li>
</ul>
<p>Below, we plot the first estimate we computed above, the predicted
probability for participant PSID1:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(est1, <span class="at">reference =</span> <span class="cn">TRUE</span>, <span class="at">ci =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="center">
<figure>
<img src="figures/plot1-1.png" style="width:100.0%" alt="graphic without alt text" />
<figcaption>image</figcaption>
</figure>
</div>
<p>Overlaid on the plot in red is a Normal distribution with the same mean
and standard deviation as the simulated values; this is requested by
setting <code>reference = TRUE</code>. From the plot, one can see that the
distribution of simulated values is non-Normal, asymmetrical, and not
centered around the estimate, with no values falling above 1 because the
outcome is a predicted probability. Given its non-Normality, the
quantile-based bounds may be more appropriate than those resulting from
the Normal approximation, as the bounds computed from the Normal
approximation would be outside the bounds of the estimate. The blue
reference line for the median of the estimates is close to the point
estimate, suggesting it is possible for a monotonic transformation to
have a symmetric distribution around the estimate<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. The plot itself
is a <code>ggplot</code> object that can be modified using <code>ggplot2</code> syntax.</p>
<p>We can use <code>summary()</code> to display the value of the point estimate, the
uncertainty bounds, and other statistics that describe the distribution
of estimates. The arguments to <code>summary()</code> are below:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="at">object =</span> , <span class="at">parm =</span> , <span class="at">level =</span> , <span class="at">method =</span> , <span class="at">null =</span> )</span></code></pre></div>
<ul>
<li><p><code>object</code> – the <code>clarify_est</code> object (the output of a call to
<code>sim_apply()</code>).</p></li>
<li><p><code>parm</code> – the names or indices of the quantities to be displayed if
more than one was estimated in <code>sim_apply()</code>; if unspecified, all
will be displayed.</p></li>
<li><p><code>level</code> – the desired two-sided confidence level. The default is
.95 so that that the bounds are at the .025 and .975 quantiles when
method (see below) is <code>"quantile"</code>.</p></li>
<li><p><code>method</code> – the method used to compute the uncertainty bounds.
Allowable methods include a Normal approximation (<code>"wald"</code>) or using
the quantiles of the resulting distribution (<code>"quantile"</code>). See
<code>plot()</code> above.</p></li>
<li><p><code>null</code> – an optional argument specifying the desired null value in
a hypothesis test for the estimates. If specified, a p-value will be
computed using either a standard Z-test (if <code>method</code> is <code>"wald"</code>) or
an inversion of the uncertainty interval (described below). The
default is not to display any p-values.</p></li>
</ul>
<p>We can use <code>summary()</code> with the default arguments on our first
<code>clarify_est</code> object to view the point estimate and quantile-based
uncertainty bounds.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est1)</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       Estimate 2.5 % 97.5 %</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; PSID1    0.976 0.890  0.996</span></span></code></pre></div>
<p>Our second estimated quantity, the difference between two regression
coefficients, is closer to Normally distributed, as the plot below
demonstrates (and would be expected theoretically), so we will use the
Normal approximation to test the hypothesis that difference differs from
0.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(est2, <span class="at">reference =</span> <span class="cn">TRUE</span>, <span class="at">ci =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="center">
<figure>
<img src="figures/plot2-1.png" style="width:100.0%" alt="graphic without alt text" />
<figcaption>image</figcaption>
</figure>
</div>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est2, <span class="at">method =</span> <span class="st">&quot;wald&quot;</span>, <span class="at">null =</span> <span class="dv">0</span>)</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;       Estimate   2.5 %  97.5 % Std. Error Z value P-value</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; w - h  -0.0996 -0.5352  0.3361     0.2223   -0.45    0.65</span></span></code></pre></div>
<p>The uncertainty intervals and p-values in the <code>summary()</code> output are
computed using the Normal approximation because we set
<code>method = "wald"</code>, and the p-value for the test that our estimate is
equal to 0 is returned because we set <code>null = 0</code>. Note that the Normal
approximation should be used only when the simulated posterior
distribution is both close to Normal and centered around the estimate
(i.e., when the mean of the simulated values <span class="math display">\[red vertical line\]</span>
coincides with the estimate computed on the original coefficients
<span class="math display">\[black vertical line\]</span>). In such cases, however, the delta method will
likely perform as well, if not better, and all of its other benefits
apply (i.e., it is computationally quicker and not subject to Monte
Carlo error).</p>
<h3 data-number="4" id="sim_apply-wrappers-sim_setx-sim_ame-sim_adrf"><span class="header-section-number">4</span> <code>sim_apply()</code> Wrappers: <code>sim_setx()</code>, <code>sim_ame()</code>, <code>sim_adrf()</code></h3>
<p><code>sim_apply()</code> can be used to compute the simulated posterior
distribution for an arbitrary derived quantity of interest, but there
are some quantities that are common in applied research and may
otherwise be somewhat challenging to program by hand, so
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> provides
shortcut functions to make computing these quantities simple. These
functions include <code>sim_setx()</code>, <code>sim_ame()</code>, and <code>sim_adrf()</code>. Each of
these can be used only when regression models compatible with
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> are supplied
to the original call to <code>sim()</code>.</p>
<p>Like <code>sim_apply()</code>, each of these functions is named <code>sim_*()</code>, which
signifies that they are to be used on an object produced by <code>sim()</code>
(i.e., a <code>clarify_sim</code> object). (Multiple calls to these functions can
be applied to the same <code>clarify_sim</code> object and combined; see the
<code>cbind()</code> section below.) These functions are described below.</p>
<h4 class="unnumbered" data-number="4.1" id="sim_setx-predictions-at-representative-values"><code>sim_setx()</code>: predictions at representative values</h4>
<p><code>sim_setx()</code> provides an interface to compute predictions at
representative and user-supplied values of the predictors. For example,
we might want to know what the effect of treatment is for a “typical”
individual, which corresponds to the contrast between two model-based
predictions (i.e., one under treatment and one under control for a unit
with “typical” covariate values). This functionality mirrors the
<code>setx()</code> and <code>setx1()</code> functionality of <code>Zelig</code> (which is where its name
originates) and provides similar functionality to functions in
<a href="https://CRAN.R-project.org/package=modelbased"><strong>modelbased</strong></a>,
<a href="https://CRAN.R-project.org/package=emmeans"><strong>emmeans</strong></a>,
<a href="https://CRAN.R-project.org/package=effects"><strong>effects</strong></a>, and
<a href="https://CRAN.R-project.org/package=ggeffects"><strong>ggeffects</strong></a>.</p>
<p>For each predictor, the user can specify whether they want predictions
at specific values or at “typical” values, which are defined in
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> as the mode
for unordered categorical and binary variables, the median for ordered
categorical variables, and the mean for continuous variables.
Predictions for multiple predictor combinations can be requested by
specifying values that will be used to create a grid of predictor
values, or the grid itself can be supplied as a data frame of desired
predictor profiles. In addition, the “first difference”, defined here as
the difference between predictions for two predictor combinations, can
be computed.</p>
<p>The arguments to <code>sim_setx()</code> are as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sim_setx</span>(<span class="at">sim =</span> , <span class="at">x =</span> , <span class="at">x1 =</span> , <span class="at">outcome =</span> , <span class="at">type =</span> , <span class="at">verbose =</span> , <span class="at">cl =</span> )</span></code></pre></div>
<ul>
<li><p><code>sim</code> – a <code>clarify_sim</code> object; the output of a call to <code>sim()</code>.</p></li>
<li><p><code>x</code> – a named list containing the requested values of the
predictors, e.g., <code>list(v1 = 1:4, v2 = "A")</code>, or a data frame
containing the desired profiles. Any predictors not included will be
set at their “typical” value as defined above.</p></li>
<li><p><code>x1</code> – an optional named list or data frame similar to <code>x</code> except
with the value of one predictor changed. When specified, the first
difference is computed between the covariate combination defined in
<code>x</code> (and only one combination is allowed when <code>x1</code> is specified) and
the covariate combination defined in <code>x1</code>.</p></li>
<li><p><code>outcome</code> – a string containing the name of the outcome of interest
when a multivariate (multiple outcome) model is supplied to <code>sim()</code>
or the outcome category of interest when a multinomial model is
supplied to <code>sim()</code>. For univariate (single outcome) and binary
outcomes, this is ignored.</p></li>
<li><p><code>type</code> – a string containing the type of predicted value to return.
In most cases, this can be left unspecified to request predictions
on the scale of the outcome.</p></li>
<li><p><code>verbose</code> – whether to display a progress bar.</p></li>
<li><p><code>cl</code> – an argument that controls parallel processing, which can be
the number of cores to use or a cluster object resulting from
<code>parallel::makeCluster()</code>.</p></li>
</ul>
<p>Here, we will use <code>sim_setx()</code> to examine predicted values of the
outcome for control and treated units, at <code>re75</code> set to 0 and 20000, and
<code>race</code> set to “black”.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>est3 <span class="ot">&lt;-</span> <span class="fu">sim_setx</span>(s,</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>                 <span class="at">x =</span> <span class="fu">list</span>(<span class="at">treat =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>,</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">re75 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">20000</span>),</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                          <span class="at">race =</span> <span class="st">&quot;black&quot;</span>),</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                 <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>When we use <code>summary()</code> on the resulting output, we can see the
estimates and their uncertainty intervals (calculated using quantiles by
default).</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est3)</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;                         Estimate 2.5 % 97.5 %</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 0, re75 = 0        0.667 0.558  0.772</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 1, re75 = 0        0.712 0.617  0.790</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 0, re75 = 20000    0.938 0.700  0.994</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 1, re75 = 20000    0.953 0.747  0.996</span></span></code></pre></div>
<p>To see the complete grid of the predictor values used in the
predictions, which helps to identify the “typical” values of the other
predictors, we can access the <code>"setx"</code> attribute of the object:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">attr</span>(est3, <span class="st">&quot;setx&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;                         treat married      age     educ  race nodegree     re74  re75</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 0, re75 = 0         0       0 27.36319 10.26873 black        1 4557.547     0</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 1, re75 = 0         1       0 27.36319 10.26873 black        1 4557.547     0</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 0, re75 = 20000     0       0 27.36319 10.26873 black        1 4557.547 20000</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 1, re75 = 20000     1       0 27.36319 10.26873 black        1 4557.547 20000</span></span></code></pre></div>
<p>We can plot the distributions of the simulated values using <code>plot()</code>,
which also separates the predictions by the predictor values (it is
often clearer without the uncertainty bounds). The <code>var</code> argument
controls which variable is used for faceting the plots.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(est3, <span class="at">var =</span> <span class="st">&quot;re75&quot;</span>, <span class="at">ci =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="center">
<figure>
<img src="figures/plot3-1.png" style="width:100.0%" alt="graphic without alt text" />
<figcaption>image</figcaption>
</figure>
</div>
<p>One can see again how a delta method or Normal approximation may have
yielded uncertainty intervals outside the plausible range of the
estimate without applying knowledge of the correct transformation to use
to avoid doing so.</p>
<p>If a continuous variable with many levels is included in the grid of the
predictors, something like a dose-response function for a typical unit
can be generated. Below, we set <code>re75</code> to vary from 0 to 20000 in steps
of 2000.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>est4 <span class="ot">&lt;-</span> <span class="fu">sim_setx</span>(s,</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>                 <span class="at">x =</span> <span class="fu">list</span>(<span class="at">treat =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>,</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">re75 =</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">20000</span>, <span class="at">by =</span> <span class="dv">2000</span>),</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>                          <span class="at">race =</span> <span class="st">&quot;black&quot;</span>),</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>                 <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>When we plot the output, we can see how the predictions varies across
the levels of <code>re75</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(est4)</span></code></pre></div>
<div class="center">
<figure>
<img src="figures/plot4-1.png" style="width:100.0%" alt="graphic without alt text" />
<figcaption>image</figcaption>
</figure>
</div>
<p>We will return to display average dose-response functions using
<code>sim_adrf()</code> later.</p>
<p>Finally, we can use <code>sim_setx()</code> to compute first differences, the
contrast between two covariate combinations. We supply one covariate
profile to <code>x</code> and another to <code>x1</code>, and <code>sim_setx()</code> simulates the two
predicted values and their difference. Below, we simulate first
difference for a treated and control unit who have <code>re75</code> of 0 and
typical values of all other covariates:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>est5 <span class="ot">&lt;-</span> <span class="fu">sim_setx</span>(s,</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>                 <span class="at">x =</span> <span class="fu">list</span>(<span class="at">treat =</span> <span class="dv">0</span>, <span class="at">re75 =</span> <span class="dv">0</span>),</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">x1 =</span> <span class="fu">list</span>(<span class="at">treat =</span> <span class="dv">1</span>, <span class="at">re75 =</span> <span class="dv">0</span>),</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>When we use <code>summary()</code>, we see the estimates for the predicted values
and their first difference (“FD”):</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est5)</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           Estimate   2.5 %  97.5 %</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 0   0.7856  0.7039  0.8558</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; treat = 1   0.8213  0.7111  0.8995</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; FD          0.0357 -0.0598  0.1188</span></span></code></pre></div>
<p>It is possible to compute first differences without using <code>x1</code> using
<code>transform()</code>, which we describe later.</p>
<h4 class="unnumbered" data-number="4.2" id="sim_ame-average-adjusted-predictions-and-average-marginal-effects"><code>sim_ame()</code>: average adjusted predictions and average marginal effects</h4>
<p>Using predicted values and effects at representative values is one way
to summarize regression models, but another way is to compute average
adjusted predictions (AAPs), contrasts of AAPs, and average marginal
effects (AMEs). The definitions for these terms may vary and the names
for these concepts differ across sources, but here we define AAPs as the
average of the predicted values for all units after setting one
predictor to a chosen value, and we define AMEs for binary predictors as
the contrast of two AAPs and for continuous predictors as the average of
instantaneous rate of change in the AAP corresponding to a small change
in the predictor from its observed values across all units<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> (Long and
Freese 2014).</p>
<p>The arguments to <code>sim_ame()</code> are as follows:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sim_ame</span>(<span class="at">sim =</span> , <span class="at">var =</span> , <span class="at">subset =</span> , <span class="at">by =</span> , <span class="at">contrast =</span> , <span class="at">outcome =</span> ,</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>        <span class="at">type =</span> , <span class="at">eps =</span> , <span class="at">verbose =</span> , <span class="at">cl =</span> )</span></code></pre></div>
<ul>
<li><p><code>sim</code> – a <code>clarify_sim</code> object; the output of a call to <code>sim()</code>.</p></li>
<li><p><code>var</code> – the name of focal variable over which to compute the AAPs
or AMEs, or a list containing the values for which AAPs should be
computed.</p></li>
<li><p><code>subset</code> – a logical vector, evaluated in the original dataset used
to fit the model, defining a subset of units for which the AAPs or
AMEs are to be computed.</p></li>
<li><p><code>by</code> – the name of one or more variables for which AAPs should be
computed within subgroups. Can be supplied as a character vector of
variable names or a one-sided formula.</p></li>
<li><p><code>contrast</code> – the name of an effect measure used to contrast AAPs.
For continuous outcomes, <code>"diff"</code> requests the difference in means,
but others are available for binary outcomes, including <code>"rr"</code> for
the risk ratio, <code>"or"</code> for the odds ratio, and <code>"nnt"</code> for the
number needed to treat, among others. If not specified, only AAPs
will be computed if the variable named in <code>var</code> is categorical or
specific values of the focal variable are specified in <code>var</code>.
Ignored when the variable named in <code>var</code> is continuous and no
specific values are specified because the AME is the only quantity
computed. When <code>var</code> names a multi-category categorical variable,
<code>contrast</code> cannot be used; see the section describing <code>transform()</code>
for computing contrasts with them.</p></li>
<li><p><code>outcome</code> – a string containing the name of the outcome of interest
when a multivariate (multiple outcome) model is supplied to <code>sim()</code>
or the outcome category of interest when a multinomial model is
supplied to <code>sim()</code>. For univariate (single outcome) and binary
outcomes, this is ignored.</p></li>
<li><p><code>type</code> – a string containing the type of predicted value to return.
In most cases, this can be left unspecified to request predictions
on the scale of the outcome (e.g., probabilities for binary
outcomes).</p></li>
<li><p><code>eps</code> – the value by which the observed values of the variable
named in <code>var</code> are changed when it is continuous to compute the AME.
This usually does not need to be specified.</p></li>
<li><p><code>verbose</code> – whether to display a progress bar.</p></li>
<li><p><code>cl</code> – an argument that controls parallel processing, which can be
the number of cores to use or a cluster object resulting from
<code>parallel::makeCluster()</code>.</p></li>
</ul>
<p>Here, we will use <code>sim_ame()</code> to compute the AME of <code>treat</code> just among
those who were treated (in causal inference, this is known as the
average treatment effect in the treated, or ATT (Greifer and Stuart
2023)). We will request our estimate to be on the risk ratio scale.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>est6 <span class="ot">&lt;-</span> <span class="fu">sim_ame</span>(s,</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">var =</span> <span class="st">&quot;treat&quot;</span>,</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">subset =</span> treat <span class="sc">==</span> <span class="dv">1</span>,</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">contrast =</span> <span class="st">&quot;rr&quot;</span>,</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>We can use <code>summary()</code> to display the estimates and their uncertainty
intervals. Here, we will also use <code>null</code> to include a test for the null
hypothesis that the risk ratio is equal to 1.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est6, <span class="at">null =</span> <span class="fu">c</span>(<span class="st">`</span><span class="at">RR</span><span class="st">`</span> <span class="ot">=</span> <span class="dv">1</span>))</span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         Estimate 2.5 % 97.5 % P-value</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(0)]    0.687 0.608  0.760       .</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(1)]    0.755 0.685  0.809       .</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; RR         1.100 0.949  1.255    0.21</span></span></code></pre></div>
<p>Here we see the estimates for the AAPs, <code>E``[``Y(0)``]</code> for the expected
value of the outcome setting <code>treat</code> to 0 and <code>E``[``Y(1)``]</code> for the
expected value of the outcome setting <code>treat</code> to 1, and the risk ratio
<code>RR</code>. The p-value on the test for the risk ratio aligns with the
uncertainty interval containing 1.</p>
<p>If we instead wanted the risk difference or odds ratio, we would not
have to re-compute the AAPs. Instead, we can use <code>transform()</code> to
compute a new derived quantity from the computed AAPs. The section on
<code>transform()</code> demonstrates this.</p>
<p>We can compute the AME for a continuous predictor. Here, we will
consider <code>age</code> (just for demonstration; this analysis does not have a
valid interpretation).</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>est7 <span class="ot">&lt;-</span> <span class="fu">sim_ame</span>(s,</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">var =</span> <span class="st">&quot;age&quot;</span>,</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>We can use <code>summary()</code> to display the AME estimate and its uncertainty
interval.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est7)</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;              Estimate    2.5 %   97.5 %</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[dY/d(age)] -0.00605 -0.00940 -0.00259</span></span></code></pre></div>
<p>The AME is named <code>E``[``dY/d(age)``]</code>, which signifies that a derivative
has been computed (more precisely, the average of the unit-specific
derivatives). This estimate can be interpreted like a slope in a linear
regression model, but as a single summary of the effect of a predictor
it is often too coarse to capture nonlinear relationships. The section
below explains how to compute average dose-response functions for
continuous predictors, which provide a more complete picture of their
effects on an outcome.</p>
<p>Below, we will examine effect modification of the ATT by the predictor
<code>married</code> using the <code>by</code> argument to estimate AAPs and their ratio
within levels of <code>married</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>est6b <span class="ot">&lt;-</span> <span class="fu">sim_ame</span>(s,</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>                 <span class="at">var =</span> <span class="st">&quot;treat&quot;</span>,</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">subset =</span> treat <span class="sc">==</span> <span class="dv">1</span>,</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">by =</span> <span class="sc">~</span>married,</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>                 <span class="at">contrast =</span> <span class="st">&quot;rr&quot;</span>,</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>                 <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est6b)</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           Estimate 2.5 % 97.5 %</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(0)|0]    0.691 0.612  0.768</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(1)|0]    0.733 0.655  0.796</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; RR[0]        1.061 0.909  1.234</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(0)|1]    0.668 0.556  0.769</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(1)|1]    0.848 0.676  0.940</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; RR[1]        1.270 0.948  1.583</span></span></code></pre></div>
<p>The presence of effect modification can be tested by testing the
contrast between the effects computed within each level of the <code>by</code>
variable; this demonstrated in the section on <code>transform()</code> below.</p>
<h4 class="unnumbered" data-number="4.3" id="sim_adrf-average-dose-response-functions"><code>sim_adrf()</code>: average dose-response functions</h4>
<p>A dose-response function for an individual is the relationship between
the set value of a continuous focal predictor and the expected outcome.
The average dose-response function (ADRF) is the average of the
dose-response functions across all units. Essentially, it is a function
that relates the value of the predictor to the corresponding AAP of the
outcome, the average value of the outcome were all units to be set to
that level of the predictor. ADRFs can be used to provide additional
detail about the effect of a continuous predictor beyond a single AME.</p>
<p>A related quantity is the average marginal effect function (AMEF), which
describes the relationship between a continuous focal predictor and the
AME at that level of the predictor. That is, rather than describing how
the outcome changes as a function of the predictor, it describes how the
<em>effect</em> of the predictor on the outcome changes as a function of the
predictor. It is essentially the derivative of the ADRF and can be used
to identify at which points along the ADRF the predictor has an effect.</p>
<p>The ADRF and AMEF can be computed using <code>sim_adrf()</code>. The arguments are
below:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sim_adrf</span>(<span class="at">sim =</span> , <span class="at">var =</span> , <span class="at">subset =</span> , <span class="at">by =</span> , <span class="at">contrast =</span> , <span class="at">at =</span> ,</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">n =</span> , <span class="at">outcome =</span> , <span class="at">type =</span> , <span class="at">eps =</span> , <span class="at">verbose =</span> , <span class="at">cl =</span> )</span></code></pre></div>
<ul>
<li><p><code>sim</code> – a <code>clarify_sim</code> object; the output of a call to <code>sim()</code>.</p></li>
<li><p><code>var</code> – the name of focal variable over which to compute the ADRF
or AMEF.</p></li>
<li><p><code>subset</code> – a logical vector, evaluated in the original dataset used
to fit the model, defining a subset of units for which the ARDF or
AMEF is to be computed.</p></li>
<li><p><code>by</code> – the name of one or more variables for which the ADRF or AMEF
should be computed within subgroups. Can be supplied as a character
vector of variable names or a one-sided formula.</p></li>
<li><p><code>contrast</code> – either <code>"adrf"</code> or <code>"amef"</code> to request the ADRF or
AMEF, respectively. The default is to compute the ADRF.</p></li>
<li><p><code>at</code> – the values of the focal predictor at which to compute the
ADRF or AMEF. This should be a vector of values that the focal
predictor can take on. If unspecified, a vector of <code>n</code> (see below)
equally-spaced values from the minimum to the maximum value of the
predictor will be used. This should typically be used only if
quantities are desired over a subset of the values of the focal
predictor.</p></li>
<li><p><code>n</code> – if <code>at</code> is unspecified, the number of points along the range
of the focal predictor at which to compute the ADRF or AMEF. More
yields smoother functions, but will take longer and require more
memory. The default is 21.</p></li>
<li><p><code>outcome</code> – a string containing the name of the outcome of interest
when a multivariate (multiple outcome) model is supplied to <code>sim()</code>
or the outcome category of interest when a multinomial model is
supplied to <code>sim()</code>. For univariate (single outcome) and binary
outcomes, this is ignored.</p></li>
<li><p><code>type</code> – a string containing the type of predicted value to return.
In most cases, this can be left unspecified to request predictions
on the scale of the outcome.</p></li>
<li><p><code>eps</code> – the value by which the observed values of the variable
named in <code>var</code> are changed when it is continuous to compute the
AMEF. This usually does not need to be specified.</p></li>
<li><p><code>verbose</code> – whether to display a progress bar.</p></li>
<li><p><code>cl</code> – an argument that controls parallel processing, which can be
the number of cores to use or a cluster object resulting from
<code>parallel::makeCluster()</code>.</p></li>
</ul>
<p>Here, we will consider <code>age</code> (just for demonstration; this analysis does
not have a valid interpretation) and compute the ADRF and AMEF of <code>age</code>
on the outcome. We will only examine ages between 18 and 50, even though
the range of <code>age</code> goes slightly beyond these values. First, we will
compute the ADRF of <code>age</code>, which examines how the outcome would vary on
average if one set all unit’s value of <code>age</code> to each value between 18
and 50 (here we only use even ages to speed up computation).</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>age_seq <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">18</span>, <span class="dv">50</span>, <span class="at">by =</span> <span class="dv">2</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>est8 <span class="ot">&lt;-</span> <span class="fu">sim_adrf</span>(s,</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">var =</span> <span class="st">&quot;age&quot;</span>,</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>                 <span class="at">contrast =</span> <span class="st">&quot;adrf&quot;</span>,</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>                 <span class="at">at =</span> age_seq,</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>                 <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>We can plot the ADRF using <code>plot()</code>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(est8)</span></code></pre></div>
<div class="center">
<figure>
<img src="figures/plot8-1.png" style="width:100.0%" alt="graphic without alt text" />
<figcaption>image</figcaption>
</figure>
</div>
<p>From the plot, we can see that as <code>age</code> increases, the expected outcome
decreases.</p>
<p>We can also examine the AAPs at the requested ages using <code>summary()</code>,
which will display all the estimated AAPs by default, so we will request
just the first 4 (<code>age</code>s 18 to 24):</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est8, <span class="at">parm =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span></code></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;          Estimate 2.5 % 97.5 %</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(18)]    0.821 0.771  0.858</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(20)]    0.811 0.764  0.845</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(22)]    0.800 0.757  0.832</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(24)]    0.788 0.749  0.817</span></span></code></pre></div>
<p>Next we will compute the AMEF, the effect of <code>age</code> at each level of
<code>age</code>.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>est9 <span class="ot">&lt;-</span> <span class="fu">sim_adrf</span>(s,</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>                 <span class="at">var =</span> <span class="st">&quot;age&quot;</span>,</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">contrast =</span> <span class="st">&quot;amef&quot;</span>,</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">at =</span> age_seq,</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>                 <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>We can plot the AMEF using <code>plot()</code>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(est9)</span></code></pre></div>
<div class="center">
<figure>
<img src="figures/plot9-1.png" style="width:100.0%" alt="graphic without alt text" />
<figcaption>image</figcaption>
</figure>
</div>
<p>From the plot, we can see the AME of <code>age</code> decreases slightly but is
mostly constant across values of <code>age</code>, and the uncertainty intervals
for the AMEs consistently exclude 0.</p>
<h3 data-number="5" id="transforming-and-combining-estimates"><span class="header-section-number">5</span> Transforming and Combining Estimates</h3>
<p>Often, our quantities of interest are not just the outputs of the
functions above, but comparisons between them. For example, to test for
moderation of a treatment effect, we may want to compare AMEs in
multiple groups defined by the moderator. Or, it might be that we are
interested in an effect described using a different effect measure than
the one originally produced; for example, we may decide we want the risk
difference AME after computing the risk ratio AME. The functions
<code>transform()</code> and <code>cbind()</code> allow users to transform quantities in a
single <code>clarify_est</code> object and combine two <code>clarify_est</code> objects. These
are essential for computing quantities that themselves are derived from
the derived quantities computed by the <code>sim_*()</code> functions.</p>
<h4 class="unnumbered" data-number="5.1" id="transform"><code>transform()</code></h4>
<p><code>transform()</code> is a generic function in R that is typically used to
create a new variable in a data frame that is a function of other
columns. For example, to compute the binary outcome we used in our
model, we could have run the following<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>lalonde <span class="ot">&lt;-</span> <span class="fu">transform</span>(lalonde,</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">re78_0 =</span> <span class="fu">ifelse</span>(re78 <span class="sc">==</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>))</span></code></pre></div>
<p>Similarly, to compute a derived or transformed quantity from a
<code>clarify_est</code> object, we can use <code>transform()</code>. Here, we will compute
the risk difference AME of <code>treat</code>; previously, we used <code>sim_ame()</code> to
compute the AAPs and the risk ratio.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>est6 <span class="ot">&lt;-</span> <span class="fu">transform</span>(est6,</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">RD =</span> <span class="st">`</span><span class="at">E[Y(1)]</span><span class="st">`</span> <span class="sc">-</span> <span class="st">`</span><span class="at">E[Y(0)]</span><span class="st">`</span>)</span></code></pre></div>
<p>Note that we used tics () around the names of the AAPs; this is
necessary when they contain special characters like parentheses or
brackets. An alternative is to use the shortcut names <code>.b#</code>, where <code>#</code>
is replaced with a number (e.g., as <code>.b1</code>, <code>.b2</code>, etc.) corresponding to
the index of the quantity referenced. For example, because
<code>E``[``Y(1)``]</code>and<code>E``[``Y(0)``]</code> are the second and first computed
quantities, respectively, the above code could be replaced with</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>est6 <span class="ot">&lt;-</span> <span class="fu">transform</span>(est6,</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">RD =</span> .b2 <span class="sc">-</span> .b1)</span></code></pre></div>
<p>which will yield identical results<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<p>When we run <code>summary()</code> on the output, the new quantity, which we named
“RD”, will be displayed along with the other estimates. We will also set
a null value for this quantity.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est6, <span class="at">null =</span> <span class="fu">c</span>(<span class="st">`</span><span class="at">RR</span><span class="st">`</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">`</span><span class="at">RD</span><span class="st">`</span> <span class="ot">=</span> <span class="dv">0</span>))</span></code></pre></div>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         Estimate   2.5 %  97.5 % P-value</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(0)]   0.6866  0.6081  0.7596       .</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(1)]   0.7551  0.6850  0.8088       .</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; RR        1.0998  0.9485  1.2554    0.21</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; RD        0.0685 -0.0382  0.1580    0.21</span></span></code></pre></div>
<p>As mentioned previously, one benefit of using simulation-based inference
with p-values computed from inverting the confidence intervals is that
the p-values for testing the same hypothesis with the risk difference
and risk ratio (and any other effect measure for comparing a pair of
values) will always exactly align, thereby ensuring inference does not
depend on the effect measure used. In contrast, Wald-type inference
(based on either the simulation-derived or delta method standard error)
is not invariant to transformations of the quantity of interest.</p>
<p>The same value would be computed if we were to have called <code>sim_ame()</code>
on the same <code>clarify_sim</code> object and requested the risk difference using
<code>contrast = "diff"</code>; using <code>transform()</code> saves time because the AAPs are
already computed and stored in the <code>clarify_est</code> object.</p>
<p>We can use <code>transform()</code> along with the <code>by</code> variable in <code>sim_ame()</code> to
compute the contrast between quantities computed within each subgroup of
<code>married</code>. Previously we used <code>by</code> to compute the risk ratio ATT within
levels of <code>married</code>; here we will compute the ratio of these risk ratios
to assess the presence of effect modification.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>est6b <span class="sc">|&gt;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">transform</span>(<span class="st">`</span><span class="at">RR[1]/RR[0]</span><span class="st">`</span> <span class="ot">=</span> <span class="st">`</span><span class="at">RR[1]</span><span class="st">`</span> <span class="sc">/</span> <span class="st">`</span><span class="at">RR[0]</span><span class="st">`</span>) <span class="sc">|&gt;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>(<span class="at">parm =</span> <span class="fu">c</span>(<span class="st">&quot;RR[0]&quot;</span>, <span class="st">&quot;RR[1]&quot;</span>, <span class="st">&quot;RR[1]/RR[0]&quot;</span>),</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>          <span class="at">null =</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;             Estimate 2.5 % 97.5 % P-value  </span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; RR[0]          1.061 0.909  1.234   0.434  </span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; RR[1]          1.270 0.948  1.583   0.094 .</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; RR[1]/RR[0]    1.196 0.908  1.516   0.174  </span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ---</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</span></span></code></pre></div>
<p><code>RR``[``1``]``/RR``[``0``]</code> contains the ratio of the risk ratios for
<code>married = 1</code> and <code>married = 0</code>. Here we also include a test for whether
each of the risk ratios and their ratio differ from 1, which is
equivalent to testing whether the risk ratios differ across levels of
<code>married</code>.</p>
<h4 class="unnumbered" data-number="5.2" id="cbind"><code>cbind()</code></h4>
<p><code>cbind()</code> is another generic R function that is typically used to
combine two or more datasets columnwise (i.e., to widen a dataset). In
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a>, <code>cbind()</code> can
be used to combine two <code>clarify_est</code> objects so that the estimates can
be examined jointly and so that it is possible to compare them directly.
For example, if we were to compute AMEs in two subgroups using <code>subset</code>
and wanted to compare them, we would call <code>sim_ame()</code> twice, one for
each subset (though in practice it is more effective to use <code>by</code>; this
is just for illustration), as demonstrated below:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># AME of treat with race = &quot;black&quot;</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>est10b <span class="ot">&lt;-</span> <span class="fu">sim_ame</span>(s, <span class="at">var =</span> <span class="st">&quot;treat&quot;</span>, <span class="at">subset =</span> race <span class="sc">==</span> <span class="st">&quot;black&quot;</span>,</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">contrast =</span> <span class="st">&quot;diff&quot;</span>, <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est10b)</span></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         Estimate   2.5 %  97.5 %</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(0)]   0.6677  0.5813  0.7529</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(1)]   0.7439  0.6661  0.8016</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Diff      0.0762 -0.0359  0.1700</span></span></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co"># AME of treat with race = &quot;hispan&quot;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>est10h <span class="ot">&lt;-</span> <span class="fu">sim_ame</span>(s, <span class="at">var =</span> <span class="st">&quot;treat&quot;</span>, <span class="at">subset =</span> race <span class="sc">==</span> <span class="st">&quot;hispan&quot;</span>,</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">contrast =</span> <span class="st">&quot;diff&quot;</span>, <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est10h)</span></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         Estimate   2.5 %  97.5 %</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(0)]   0.8266  0.7146  0.8990</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(1)]   0.8971  0.7888  0.9527</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Diff      0.0704 -0.0223  0.1387</span></span></code></pre></div>
<p>Here, we computed the risk difference for the subgroups <code>race = "black"</code>
and <code>race = "hispan"</code>. If we wanted to compare the risk differences, we
could combine them and compute a new quantity equal to their difference.
We will do that below.</p>
<p>First, we need to rename the quantities in each object so they do not
overlap; we can do so using <code>names()</code>, which has a special method for
<code>clarify_est</code> objects.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(est10b) <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="fu">names</span>(est10b), <span class="st">&quot;b&quot;</span>, <span class="at">sep =</span> <span class="st">&quot;_&quot;</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(est10h) <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="fu">names</span>(est10h), <span class="st">&quot;h&quot;</span>, <span class="at">sep =</span> <span class="st">&quot;_&quot;</span>)</span></code></pre></div>
<p>Next, we use <code>cbind()</code> to bind the objects together.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>est10 <span class="ot">&lt;-</span> <span class="fu">cbind</span>(est10b, est10h)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est10)</span></code></pre></div>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           Estimate   2.5 %  97.5 %</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(0)]_b   0.6677  0.5813  0.7529</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(1)]_b   0.7439  0.6661  0.8016</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Diff_b      0.0762 -0.0359  0.1700</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(0)]_h   0.8266  0.7146  0.8990</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[Y(1)]_h   0.8971  0.7888  0.9527</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Diff_h      0.0704 -0.0223  0.1387</span></span></code></pre></div>
<p>Finally, we can use <code>transform()</code> to compute the difference between the
risk differences:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>est10 <span class="ot">&lt;-</span> <span class="fu">transform</span>(est10,</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">`</span><span class="at">Dh - Db</span><span class="st">`</span> <span class="ot">=</span> Diff_h <span class="sc">-</span> Diff_b)</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est10, <span class="at">parm =</span> <span class="st">&quot;Dh - Db&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;         Estimate    2.5 %   97.5 %</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Dh - Db -0.00575 -0.06833  0.04103</span></span></code></pre></div>
<p>Importantly, <code>cbind()</code> can only be used to join together <code>clarify_est</code>
objects computed using the same simulated coefficients (i.e., resulting
from the same call to <code>sim()</code>). This preserves the covariance among the
estimated quantities, which is critical for maintaining valid inference.
That is, <code>sim()</code> should only be called once per model, and all derived
quantities should be computed using its output.</p>
<h3 data-number="6" id="using-with-multiply-imputed-data"><span class="header-section-number">6</span> Using <strong>clarify</strong> with Multiply Imputed Data</h3>
<p>Multiple imputation is a popular method of estimating quantities of
interest in the presence of missing data and involves creating multiple
versions of the original dataset each with the missing values imputed
with estimates from an imputation model. Simulation-based inference in
multiply imputed data is relatively straightforward. Simulated
coefficients are drawn from the model estimated in each imputed dataset
separately, and then the simulated coefficients are pooled into a single
set of simulated coefficients. In Bayesian terms, this would be
considered “mixing draws” and is the recommended approach for Bayesian
analysis with multiply imputed data (Zhou and Reiter 2010).</p>
<p>Using <a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> with
multiply imputed data is simple. Rather than using <code>sim()</code>, we use the
function <code>misim()</code>. <code>misim()</code> functions just like <code>sim()</code> except that it
takes in a list of model fits (i.e., containing a model fit to each
imputed dataset) or an object containing such a list (e.g., a <code>mira</code>
object from <code>mice::with()</code> or a <code>mimira</code> object from
<code>MatchThem::with()</code>). <code>misim()</code> simulates coefficient distributions
within each imputed dataset and then appends them together to a form a
single combined set of coefficient draws.</p>
<p><code>sim_apply()</code> and its wrappers accept the output of <code>misim()</code> and
compute the desired quantity using each set of coefficients. When these
functions rely on using a dataset (e.g., <code>sim_ame()</code>, which averages
predicted outcomes across all units in the dataset used to fit the
model), they automatically know to associate a given coefficient draw
with the imputed dataset that was used to fit the model that produced
that draw. In user-written functions supplied to the <code>FUN</code> argument of
<code>sim_apply()</code>, it is important to correctly extract the dataset from the
model fit. This is demonstrated below.</p>
<p>The final estimates of the quantity of interest is computed as the mean
of the estimates computed in each imputed dataset (i.e., using the
original coefficients, not the simulated ones), which is the same
quantity that would be computed using standard pooling rules. This is
not always valid for noncollapsible estimates, like ratios, and so care
should be taken to ensure the mean of the resulting estimates has a
valid interpretation (this is related to the transformation-induced bias
described by Rainey (2017)).</p>
<p>The arguments to <code>misim()</code> are as follows:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="fu">misim</span>(<span class="at">fitlist =</span> , <span class="at">n =</span> , <span class="at">vcov =</span> , <span class="at">coefs =</span> , <span class="at">dist =</span> )</span></code></pre></div>
<ul>
<li><p><code>fitlist</code> – a list of model fits or an accepted object containing
them (e.g., a <code>mira</code> object from <code>mice::with()</code>)</p></li>
<li><p><code>n</code> – the number of simulations to run <em>for each imputed dataset</em>.
The default is 1000, but fewer can be used because the total number
of simulated quantities will be <code>m * n</code>, where <code>m</code> is the number of
imputed datasets.</p></li>
<li><p><code>vcov</code>, <code>coefs</code>, <code>dist</code> – the same as with <code>sim()</code>, except that a
list of such arguments can be supplied to be applied to each imputed
dataset.</p></li>
</ul>
<p>Below we illustrate using <code>misim()</code> and <code>sim_apply()</code> with multiply
imputed data. We will use the <code>africa</code> dataset from the
<a href="https://CRAN.R-project.org/package=Amelia"><strong>Amelia</strong></a> package.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(Amelia)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;africa&quot;</span>, <span class="at">package =</span> <span class="st">&quot;Amelia&quot;</span>)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Multiple imputation</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>a.out <span class="ot">&lt;-</span> <span class="fu">amelia</span>(<span class="at">x =</span> africa, <span class="at">m =</span> <span class="dv">10</span>, <span class="at">cs =</span> <span class="st">&quot;country&quot;</span>,</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">ts =</span> <span class="st">&quot;year&quot;</span>, <span class="at">logs =</span> <span class="st">&quot;gdp_pc&quot;</span>, <span class="at">p2s =</span> <span class="dv">0</span>)</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit model to each dataset</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>model.list <span class="ot">&lt;-</span> <span class="fu">with</span>(a.out, <span class="fu">lm</span>(gdp_pc <span class="sc">~</span> infl <span class="sc">*</span> trade))</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate coefficients, 100 draws per imputation</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>si <span class="ot">&lt;-</span> <span class="fu">misim</span>(model.list, <span class="at">n =</span> <span class="dv">100</span>)</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>si</span></code></pre></div>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; A `clarify_misim` object</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  - 4 coefficients, 10 imputations with 100 simulated values each</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  - sampled distributions: multivariate t(116)</span></span></code></pre></div>
<p>The function we will be applying to each imputed dataset will be one
that computes the AME of <code>infl</code>. (We will run the same analysis
afterward using <code>sim_ame()</code>.)</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>sim_fun <span class="ot">&lt;-</span> <span class="cf">function</span>(fit) {</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Extract the original dataset using get_predictors()</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">&lt;-</span> insight<span class="sc">::</span><span class="fu">get_predictors</span>(fit)</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>  p0 <span class="ot">&lt;-</span> <span class="fu">predict</span>(fit)</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">#Predictions after perturbing infl slightly</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>  p1 <span class="ot">&lt;-</span> <span class="fu">predict</span>(fit, <span class="at">newdata =</span> <span class="fu">transform</span>(X, <span class="at">infl =</span> infl <span class="sc">+</span> <span class="fl">1e-5</span>))</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a> <span class="fu">c</span>(<span class="at">AME =</span> <span class="fu">mean</span>((p1 <span class="sc">-</span> p0) <span class="sc">/</span> <span class="fl">1e-5</span>))</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>est_mi <span class="ot">&lt;-</span> <span class="fu">sim_apply</span>(si, <span class="at">FUN =</span> sim_fun, <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est_mi)</span></code></pre></div>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     Estimate 2.5 % 97.5 %</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; AME    -5.75 -8.82  -2.26</span></span></code></pre></div>
<p>Note that <code>sim_apply()</code> “knows” which imputation produced each set of
simulated coefficients, so using <code>insight::get_predictors()</code> on the
<code>fit</code> supplied to <code>sim_fun()</code> will use the right dataset. Care should be
taken when analyses restrict each imputed dataset in a different way
(e.g. when matching with a caliper in each one), as the resulting
imputations may not refer to a specific target population and mixing the
draws may be invalid.</p>
<p>Below, we can use <code>sim_ame()</code>:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>est_mi2 <span class="ot">&lt;-</span> <span class="fu">sim_ame</span>(si, <span class="at">var =</span> <span class="st">&quot;infl&quot;</span>, <span class="at">verbose =</span> <span class="cn">FALSE</span>)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(est_mi2)</span></code></pre></div>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;               Estimate 2.5 % 97.5 %</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; E[dY/d(infl)]    -5.75 -8.82  -2.26</span></span></code></pre></div>
<p>We get the same results, as expected.</p>
<p>Note that <code>misim()</code> is compatible with model fit objects from
<a href="https://CRAN.R-project.org/package=mice"><strong>mice</strong></a>,
<a href="https://CRAN.R-project.org/package=Amelia"><strong>Amelia</strong></a>,
<a href="https://CRAN.R-project.org/package=MatchThem"><strong>MatchThem</strong></a>, and any
other package that produces a list of model fit objects with each
corresponding to the output of a model fit to an imputed dataset.</p>
<h3 data-number="7" id="comparison-to-other-packages"><span class="header-section-number">7</span> Comparison to Other Packages</h3>
<p>Several packages offer methods for computing interpretable quantities
form regression models, including
<a href="https://CRAN.R-project.org/package=emmeans"><strong>emmeans</strong></a> (Lenth 2024),
<strong>margins</strong> (Leeper 2021),
<a href="https://CRAN.R-project.org/package=modelbased"><strong>modelbased</strong></a>
(Makowski et al. 2020), and
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
(Arel-Bundock, Greifer, and Heiss Forthcoming). Many of the quantities
computed by these packages can also be computed by
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a>, the primary
difference being that
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> uses
simulation-based inference rather than delta method-based inference.</p>
<p><a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
offers the most similar functionality to
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a>, and
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> depends on
functionality provided by
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
to accommodate a wide variety of regression models.
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
also offers simulation-based inference using
<code>marginaleffects::inferences()</code> and support for arbitrary user-specified
post-estimation functions using <code>marginaleffects::hypotheses()</code>.
However, <a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> and
<code>marignalefefcts</code> differ in several ways. The largest difference is that
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> supports
iterative building of more and more complex hypotheses through the
<code>transform()</code> method, which quickly computes new quantities and
transformation from the existing computed quantities, whereas
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
only supports a single transformation and, as of version 0.20.0, cannot
use simulation-based inference for these quantities.</p>
<p>Because of <a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a>’s
focus on simulation, it provides functionality directly aimed at
improving simulation-based inference, including plots to view the
distributions of simulated values and support for parallel processing.
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> also provides
support for simulation-based inference of multiply imputed data, which
does not require any special pooling rules.</p>
<p>There are areas and cases where
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
may be the better choice than
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> or where the
differences between the packages are of little consequence.
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
focuses on providing a complete framework for post-estimation using
model predictions, whereas
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> is primarily
focused on supporting user-defined functions, with commonly used
estimators offered as a convenience. In cases where the delta method is
an acceptable approximation (e.g., for quantities computed from linear
models or other quantities known to be approximately Normally
distributed in finite samples), using the delta method through
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
will be much faster, more accurate, and more replicable than the
simulation-based inference
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> provides. For
the quantities easily computed by
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
that support simulation-based inference through
<code>marginaleffects::inferences()</code>, using
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
can provide a more familiar and flexible syntax than
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> might offer.
Ultimately, the user should use the package that supports their desired
syntax and mode of inference.</p>
<h3 data-number="8" id="conclusion"><span class="header-section-number">8</span> Conclusion</h3>
<p><a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> provides
functionality to facilitate simulation-based inference of deriving
quantities from regression models. This framework provides an
alternative to the delta method that can yield confidence intervals with
closer to nominal coverage for some quantities of interest. While we do
not claim simulation-based inference should be universally preferred
over delta method-based inference, there are cases in which it can
retain some advantageous properties, and we hope the availability of
these methods in
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> encourages
additional research on when those properties can be realized and
facilitates empirical work that takes advantages of these properties.</p>
<h3 class="unnumbered" id="references">References</h3>
<div id="refs" role="list">

</div>
<p>Arel-Bundock, Vincent, Noah Greifer, and Andrew Heiss. Forthcoming. “How
to Intepret Statistical Models Using marginaleffects in R and Python.”
<em>Journal of Statistical Software</em>, Forthcoming.</p>
<p>Dehejia, Rajeev H., and Sadek Wahba. 1999. “Causal Effects in
Nonexperimental Studies: Reevaluating the Evaluation of Training
Programs.” <em>Journal of the American Statistical Association</em> 94 (448):
1053–62. <a href="https://doi.org/10.1080/01621459.1999.10473858" class="uri">https://doi.org/10.1080/01621459.1999.10473858</a>.</p>
<p>Efron, B., and R. Tibshirani. 1986. “Bootstrap Methods for Standard
Errors, Confidence Intervals, and Other Measures of Statistical
Accuracy.” <em>Statistical Science</em> 1 (1): 54–75.
<a href="https://www.jstor.org/stable/2245500" class="uri">https://www.jstor.org/stable/2245500</a>.</p>
<p>Greifer, Noah, and Elizabeth A. Stuart. 2023. “Choosing the Causal
Estimand for Propensity Score Analysis of Observational Studies.”
<a href="https://doi.org/10.48550/arXiv.2106.10577" class="uri">https://doi.org/10.48550/arXiv.2106.10577</a>.</p>
<p>Herron, Michael C. 1999. “Postestimation Uncertainty in Limited
Dependent Variable Models.” <em>Political Analysis</em> 8 (1): 83–98.
<a href="https://doi.org/10.1093/oxfordjournals.pan.a029806" class="uri">https://doi.org/10.1093/oxfordjournals.pan.a029806</a>.</p>
<p>Ho, Daniel E., Kosuke Imai, Gary King, and Elizabeth A. Stuart. 2011.
“MatchIt: Nonparametric Preprocessing for Parametric Causal Inference.”
<em>Journal of Statistical Software, Articles</em> 42 (8): 128.
<a href="https://doi.org/10.18637/jss.v042.i08" class="uri">https://doi.org/10.18637/jss.v042.i08</a>.</p>
<p>Hole, Arne Risa. 2007. “A Comparison of Approaches to Estimating
Confidence Intervals for Willingness to Pay Measures.” <em>Health
Economics</em> 16 (8): 827–40. <a href="https://doi.org/10.1002/hec.1197" class="uri">https://doi.org/10.1002/hec.1197</a>.</p>
<p>Imai, Kosuke, Gary King, and Olivia Lau. 2008. “Toward a Common
Framework for Statistical Analysis and Development.” <em>Journal of
Computational and Graphical Statistics</em> 17 (4): 892–913.
<a href="https://doi.org/10.1198/106186008X384898" class="uri">https://doi.org/10.1198/106186008X384898</a>.</p>
<p>King, Gary, Michael Tomz, and Jason Wittenberg. 2000. “Making the Most
of Statistical Analyses: Improving Interpretation and Presentation.”
<em>American Journal of Political Science</em> 44 (2): 347–61.
<a href="https://doi.org/10.2307/2669316" class="uri">https://doi.org/10.2307/2669316</a>.</p>
<p>Krinsky, Itzhak, and A. Leslie Robb. 1986. “On Approximating the
Statistical Properties of Elasticities.” <em>The Review of Economics and
Statistics</em> 68 (4): 715. <a href="https://doi.org/10.2307/1924536" class="uri">https://doi.org/10.2307/1924536</a>.</p>
<p>Leeper, Thomas J. 2021. <em>Margins: Marginal Effects for Model Objects</em>.</p>
<p>Lenth, Russell V. 2024. <em>Emmeans: Estimated Marginal Means, Aka
Least-Squares Means</em>. <a href="https://CRAN.R-project.org/package=emmeans" class="uri">https://CRAN.R-project.org/package=emmeans</a>.</p>
<p>Long, J. Scott, and Jeremy Freese. 2014. <em>Regression Models for
Categorical Dependent Variables Using Stata</em>. Third edition. College
Station, Texas: Stata Press Publication, StataCorp LP.</p>
<p>MacKinnon, David P., Chondra M. Lockwood, and Jason Williams. 2004.
“Confidence Limits for the Indirect Effect: Distribution of the Product
and Resampling Methods.” <em>Multivariate Behavioral Research</em> 39 (1):
99–128. <a href="https://doi.org/10.1207/s15327906mbr3901_4" class="uri">https://doi.org/10.1207/s15327906mbr3901_4</a>.</p>
<p>Makowski, Dominique, Mattan S. Ben-Shachar, Indrajeet Patil, and Daniel
Lüdecke. 2020. “Estimation of Model-Based Predictions, Contrasts and
Means.” <em>CRAN</em>. <a href="https://github.com/easystats/modelbased" class="uri">https://github.com/easystats/modelbased</a>.</p>
<p>Preacher, Kristopher J., and James P. Selig. 2012. “Advantages of Monte
Carlo Confidence Intervals for Indirect Effects.” <em>Communication Methods
and Measures</em> 6 (2): 77–98.
<a href="https://doi.org/10.1080/19312458.2012.679848" class="uri">https://doi.org/10.1080/19312458.2012.679848</a>.</p>
<p>Rainey, Carlisle. 2017. “Transformation-Induced Bias: Unbiased
Coefficients Do Not Imply Unbiased Quantities of Interest.” <em>Political
Analysis</em> 25 (3): 402–9. <a href="https://doi.org/10.1017/pan.2017.11" class="uri">https://doi.org/10.1017/pan.2017.11</a>.</p>
<p>———. 2023. “A Careful Consideration of CLARIFY: Simulation-Induced
Bias in Point Estimates of Quantities of Interest.” <em>Political Science
Research and Methods</em>, April, 1–10.
<a href="https://doi.org/10.1017/psrm.2023.8" class="uri">https://doi.org/10.1017/psrm.2023.8</a>.</p>
<p>Thulin, Måns. 2021. <em>Modern Statistics with r: From Wrangling and
Exploring Data to Inference and Predictive Modelling</em>. Uppsala, Sweden:
Eos Chasma Press.</p>
<p>Tofighi, Davood, and David P. MacKinnon. 2016. “Monte Carlo Confidence
Intervals for Complex Functions of Indirect Effects.” <em>Structural
Equation Modeling: A Multidisciplinary Journal</em> 23 (2): 194205.
<a href="https://doi.org/10.1080/10705511.2015.1057284" class="uri">https://doi.org/10.1080/10705511.2015.1057284</a>.</p>
<p>Tomz, Michael, Jason Wittenberg, and Gary King. 2003. “Clarify: Software
for Interpreting and Presenting Statistical Results.” <em>Journal of
Statistical Software</em> 8 (January): 1–30.
<a href="https://doi.org/10.18637/jss.v008.i01" class="uri">https://doi.org/10.18637/jss.v008.i01</a>.</p>
<p>Zelner, Bennet A. 2009. “Using simulation to interpret results from
logit, probit, and other nonlinear models.” <em>Strategic Management
Journal</em> 30 (12): 1335–48. <a href="https://doi.org/10.1002/smj.783" class="uri">https://doi.org/10.1002/smj.783</a>.</p>
<p>Zhou, Xiang, and Jerome P. Reiter. 2010. “A Note on Bayesian Inference
After Multiple Imputation.” <em>The American Statistician</em> 64 (2): 159–63.
<a href="https://doi.org/10.1198/tast.2010.09109" class="uri">https://doi.org/10.1198/tast.2010.09109</a>.</p>
</div>
<h3 class="appendix" data-number="9" id="cran-packages-used"><span class="header-section-number">9</span> CRAN packages used</h3>
<p><a href="https://cran.r-project.org/package=clarify">clarify</a>, <a href="https://cran.r-project.org/package=marginaleffects">marginaleffects</a>, <a href="https://cran.r-project.org/package=MatchIt">MatchIt</a>, <a href="https://cran.r-project.org/package=modelbased">modelbased</a>, <a href="https://cran.r-project.org/package=emmeans">emmeans</a>, <a href="https://cran.r-project.org/package=effects">effects</a>, <a href="https://cran.r-project.org/package=ggeffects">ggeffects</a>, <a href="https://cran.r-project.org/package=Amelia">Amelia</a>, <a href="https://cran.r-project.org/package=mice">mice</a>, <a href="https://cran.r-project.org/package=MatchThem">MatchThem</a></p>
<h3 class="appendix" data-number="10" id="cran-task-views-implied-by-cited-packages"><span class="header-section-number">10</span> CRAN Task Views implied by cited packages</h3>
<p><a href="https://cran.r-project.org/view=CausalInference">CausalInference</a>, <a href="https://cran.r-project.org/view=Econometrics">Econometrics</a>, <a href="https://cran.r-project.org/view=MachineLearning">MachineLearning</a>, <a href="https://cran.r-project.org/view=MissingData">MissingData</a>, <a href="https://cran.r-project.org/view=MixedModels">MixedModels</a>, <a href="https://cran.r-project.org/view=OfficialStatistics">OfficialStatistics</a>, <a href="https://cran.r-project.org/view=TeachingStatistics">TeachingStatistics</a></p>
<h3 class="appendix" data-number="11" id="note"><span class="header-section-number">11</span> Note</h3>
<p>This article is converted from a Legacy LaTeX article using the
<a href="https://cran.r-project.org/package=texor">texor</a> package.
The pdf version is the official version. To report a problem with the html,
refer to CONTRIBUTE on the R Journal homepage.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>We thank an anonymous reviewer for pointing out a scenario in
which this could occur: for a quantity of interest with a
right-skewed sampling distribution, one would prefer an estimate to
the right of the quantity’s true value to have a confidence interval
skewed to left to capture the bulk of the sampling distribution, but
in practice a quantile confidence interval would also be skewed to
the right. While a symmetric Wald-based interval may not have
adequate coverage, the quantile-based interval could perform even
worse.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Despite the similar name, the R package
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> and the
Stata package <strong>CLARIFY</strong> differ in several ways, one of which is
that the estimates reported by
<a href="https://CRAN.R-project.org/package=clarify"><strong>clarify</strong></a> in R are
those computed using the original model coefficients, whereas those
reported by <strong>CLARIFY</strong> in Stata are those computed as the average
of the simulated distribution. The R implementation avoids the
“simulation-induced bias” described by Rainey (2023).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>In fact, we know the inverse link function for the model (i.e.,
the Normal distribution function <code>qnorm()</code>) is such a transformation
in this case;
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>
and other packages that implement the delta method for confidence
intervals around model predictions typically automatically compute
confidence intervals on the transformed predictions before
transforming the intervals back using the model’s link function. As
long as such a transformation exists, the quantile intervals will be
as valid as those that rely on transforming and back-transforming.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>In
<a href="https://CRAN.R-project.org/package=marginaleffects"><strong>marginaleffects</strong></a>,
AAPs are computed using <code>avg_predictions()</code>, AMEs for binary
variables are computed using <code>avg_comparisons()</code>, and AMEs for
continuous variables are computed using <code>avg_slopes()</code>. AAPs are
sometimes known as average “counterfactual” predictions.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Users familiar with the <code>tidyverse</code> will note the similarities
between <code>transform()</code> and <code>dplyr::mutate()</code>; only <code>transform()</code> can
be used with <code>clarify_est</code> objects.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Note that if a quantity is named <code>.b#</code>, e.g., <code>.b1</code>, it can only
be referred to using the positional shortcut and not its named. That
is, the positional shortcut takes precedence over the names of the
quantities.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r distill-force-highlighting-css"><code class="sourceCode r"></code></pre></div>
<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</section>
<!--radix_placeholder_article_footer-->
<!--/radix_placeholder_article_footer-->
</div>

<div class="d-appendix">
</div>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<!--radix_placeholder_site_after_body-->
<!--/radix_placeholder_site_after_body-->
<!--radix_placeholder_appendices-->
<div class="appendix-bottom">
  <h3 id="reuse">Reuse</h3>
  <p>Text and figures are licensed under Creative Commons Attribution <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>. The figures that have been reused from other sources don't fall under this license and can be recognized by a note in their caption: "Figure from ...".</p>
  <h3 id="citation">Citation</h3>
  <p>For attribution, please cite this work as</p>
  <pre class="citation-appendix short">Greifer, et al., "`clarify`: Simulation-Based Inference for Regression Models", The R Journal, 2025</pre>
  <p>BibTeX citation</p>
  <pre class="citation-appendix long">@article{RJ-2024-015,
  author = {Greifer, Noah and Worthington, Steven and Iacus, Stefano and King, Gary},
  title = {`clarify`: Simulation-Based Inference for Regression Models},
  journal = {The R Journal},
  year = {2025},
  note = {https://doi.org/10.32614/RJ-2024-015},
  doi = {10.32614/RJ-2024-015},
  volume = {16},
  issue = {2},
  issn = {2073-4859},
  pages = {1}
}</pre>
</div>
<!--/radix_placeholder_appendices-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<!--radix_placeholder_navigation_after_body--><html><body>
<div class="distill-site-nav distill-site-footer">
<p>© The R Foundation, <a href="mailto:r-journal@r-project.org">web page
contact</a>.</p>
</div>
<!--/radix_placeholder_navigation_after_body-->
</body></html>


</body>

</html>
