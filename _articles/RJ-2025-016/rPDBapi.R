# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit rPDBapi.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.pos = "H", out.extra = "")
library(rPDBapi)
library(webshot)
Sys.setenv(CHROMOTE_TIMEOUT = 2000)


## ----figure1, out.width = "100%", fig.cap = "Data Retrieval and Query Workflow for RCSB PDB API Using rPDBapi Package"----
 knitr::include_graphics("figures/flow_diagram.jpg")


## ----load, echo = TRUE--------------------------------------------------------
# install.packages("rPDBapi", repos = "http://cran.us.r-project.org")
library("rPDBapi")


## ----query_search_hemoglobin, echo = TRUE-------------------------------------
pdbs = query_search(search_term = "hemoglobin")
head(pdbs)


## ----query_search_PubmedIdQuery, echo = TRUE----------------------------------
pdbs = query_search(search_term = 32453425, query_type = "PubmedIdQuery")
pdbs


## ----query_search_pfam, echo = TRUE-------------------------------------------
# Search by PFAM number (protein kinase domain)
pdbs = query_search(search_term = "PF00069", query_type="pfam")  
head(pdbs)


## ----query_search_pdbs, echo=TRUE---------------------------------------------
# Load necessary libraries
library(rPDBapi)
library(Biostrings)
library(ggplot2)

# Get first 100 entries
pdbs <- pdbs[1:100]



## ----get_protein_length, echo=TRUE--------------------------------------------

get_protein_length <- function(pdb_id) {
  fasta <- get_fasta_from_rcsb_entry(pdb_id, chain_id = "A")
  sequence <- AAString(fasta)
  return(nchar(sequence))
}

# Apply the function to all retrieved PDB IDs
protein_lengths <- sapply(pdbs, get_protein_length)

# Create a data frame for plotting
length_data <- data.frame(PDB_ID = names(protein_lengths), Length = protein_lengths)

head(length_data)


## ----figure2, echo=TRUE, out.width = "75%", fig.width=3, fig.height=3, fig.cap = "Histogram of protein lengths in the kinase domain family."----
# Plot the distribution of protein lengths
ggplot(length_data, aes(x = Length)) +
  geom_histogram(binwidth = 10, fill = "blue", color = "black", alpha = 0.7) +
  labs(x = "Protein Length (Amino Acids)",
       y = "Frequency") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10),   
    axis.title.x = element_text(size = 8),  
    axis.title.y = element_text(size = 8),  
    axis.text = element_text(size = 7)      
  )


## ----perform_search, eval=FALSE, echo=TRUE------------------------------------
# perform_search(
#   search_operator,
#   return_type = "ENTRY",
#   request_options = NULL,
#   return_with_scores = FALSE,
#   return_raw_json_dict = FALSE,
#   verbosity = TRUE
# )


## ----DefaultOperator, eval=FALSE, echo=TRUE-----------------------------------
# DefaultOperator <- function(value) {
#   res <- list(value = value)
#   structure(res, class = c("DefaultOperator", class(res)))
# }


## ----ExactMatchOperator, eval=FALSE, echo=TRUE--------------------------------
# ExactMatchOperator <- function(attribute, value) {
#   res <- list(attribute = attribute, value = value, operator = "exact_match")
#   structure(res, class = c("ExactMatchOperator", class(res)))
# }


## ----InOperator, eval=FALSE, echo=TRUE----------------------------------------
# InOperator <- function(attribute, value) {
#   res <- list(attribute = attribute, operator = "in", value = value)
#   structure(res, class = c("InOperator", class(res)))
# }


## ----ContainsOperators, eval=FALSE, echo=TRUE---------------------------------
# ContainsWordsOperator <- function(attribute, value) {
#   res <- list(attribute = attribute, operator = "contains_words", value = value)
#   structure(res, class = c("ContainsWordsOperator", class(res)))
# }
# 
# ContainsPhraseOperator <- function(attribute, value) {
#   res <- list(attribute = attribute, operator = "contains_phrase", value = value)
#   structure(res, class = c("ContainsPhraseOperator", class(res)))
# }


## ----ContainsAndRangeOperators, eval=FALSE, echo=TRUE-------------------------
# ComparisonOperator <- function(attribute, value, comparison_type) {
#   if (ComparisonType[[comparison_type]] == "not_equal") {
#     param_dict <- list(operator = "equals", negation = TRUE)
#   } else {
#     param_dict <- list(operator = ComparisonType[[comparison_type]])
#   }
#   param_dict$attribute <- attribute
#   param_dict$value <- value
#   structure(param_dict, class = c("ComparisonOperator", class(param_dict)))
# }
# 
# RangeOperator <- function(attribute, from_value, to_value, include_lower = TRUE,
#                           include_upper = TRUE, negation = FALSE) {
#   res <- list(
#     operator = "range",
#     attribute = attribute,
#     negation = negation,
#     value = list(from = from_value, to = to_value)
#   )
#   structure(res, class = c("RangeOperator", class(res)))
# }


## ----ExistsOperator, eval=FALSE, echo=TRUE------------------------------------
# ExistsOperator <- function(attribute) {
#   res <- list(attribute = attribute, operator = "exists")
#   structure(res, class = c("ExistsOperator", class(res)))
# }


## ----search_operator_InOperator, echo = TRUE----------------------------------
search_operator = InOperator(value=c("Mus musculus", "Homo sapiens"),
                             attribute="rcsb_entity_source_organism.taxonomy_lineage.name")
return_type = "NONPOLYMER_ENTITY"
results = perform_search(search_operator, return_type)
head(results)


## ----faceted_queries, echo=TRUE-----------------------------------------------
# Create the ComparisonOperator for the date
operator_date <- ComparisonOperator(
    attribute = "rcsb_accession_info.initial_release_date",
    value = "2019-08-20",
    comparison_type = "GREATER"
)

# Define the facets for request options
request_options <- list(
    facets = list(
        list(
            name = "Methods",
            aggregation_type = "terms",
            attribute = "exptl.method"
        )
    )
)

# Specify the return type
return_type <- "ENTRY"

# Perform the search with the specified return type and request options
results <- perform_search(
    search_operator = operator_date,
    return_type = return_type,
    request_options = request_options
)

# Display the results
results


## ----protein kinase, echo=TRUE------------------------------------------------
# Load necessary libraries
library(rPDBapi)
library(Biostrings)
library(msa)
library(r3dmol)
library(gplots)

set.seed(123)
# Define the search operator for a full-text search using the keyword "protein kinase"
search_operator <- list(
  type = "terminal",
  service = "full_text",
  parameters = list(value = "protein kinase")
)

# Perform the search for PDB entries
protein_entities <- perform_search(
  search_operator = search_operator,
  return_type = "ENTRY"
)

# Display the first 10 PDB IDs retrieved
protein_entities <- protein_entities[1:10]
protein_entities


## ----get_protein_sequence, echo=TRUE------------------------------------------
# Function to retrieve and process protein sequences
get_protein_sequence <- function(pdb_id) {
  fasta <- get_fasta_from_rcsb_entry(pdb_id, chain_id = "A")
  AAString(fasta)
}

# Retrieve protein sequences for the selected PDB IDs
sequences <- lapply(protein_entities, get_protein_sequence)
names(sequences) <- protein_entities

# Perform multiple sequence alignment
alignment <- msa(AAStringSet(sequences), method = "ClustalW")

# Convert alignment to a matrix for pairwise sequence identity calculation
alignment_matrix <- as.matrix(alignment)



## ----figure3, out.width = "100%", out.height = "50%", echo=TRUE, fig.cap="Heatmap of sequence identity among kinase proteins."----
# Function to calculate pairwise sequence identity
pairwise_identity <- function(seq1, seq2) {
  sum(seq1 == seq2) / length(seq1) * 100
}

# Calculate pairwise sequence identity
n <- length(sequences)
identity_matrix <- matrix(NA, n, n)
rownames(identity_matrix) <- names(sequences)
colnames(identity_matrix) <- names(sequences)

for (i in 1:n) {
  for (j in i:n) {
    identity_matrix[i, j] <- pairwise_identity(alignment_matrix[i, ], 
                                               alignment_matrix[j, ])
    identity_matrix[j, i] <- identity_matrix[i, j]
  }
}

par(cex.main=1)

# Visualize the pairwise sequence identity as a heatmap
heatmap.2(identity_matrix, xlab = "PDB ID", ylab = "PDB ID", 
          col = colorRampPalette(c("blue", "white", "red"))(100),
          labRow = rownames(identity_matrix), labCol = colnames(identity_matrix),
          trace = "none", key = TRUE, key.title = "Identity", key.xlab = "Scale", 
          density.info = "none", scale = "none")



## ----visualize_structure, echo=TRUE-------------------------------------------
# Function to visualize the structures using r3dmol with color
visualize_structure <- function(pdb_id) {
  pdb_path <- get_pdb_file(pdb_id, filetype = "pdb", save = TRUE)$path

  viewer <- r3dmol() %>%
    m_add_model(pdb_path, format = "pdb") %>%
    m_set_style(style = m_style_cartoon(
      color = "spectrum"
    )) %>%
    m_zoom_to()

  return(viewer)
}



## ----figure4NotEval, echo=TRUE, eval=FALSE------------------------------------
# # Visualize the first protein structure
# visualize_structure(protein_entities[1])


## ----figure4, out.width = "100%", fig.align='center', fig.height=5, fig.width=5, fig.cap = "3D structure of the first kinase protein."----
 knitr::include_graphics("figures/figure4.jpg")


## ----figure5NotEval, echo=TRUE, eval=FALSE------------------------------------
# # Visualize the second protein structure
# visualize_structure(protein_entities[2])


## ----figure5, out.width = "100%", fig.align='center', fig.height=5, fig.width=5, fig.cap = "3D structure of the second kinase protein."----
 knitr::include_graphics("figures/figure5.jpg")


## ----query_search_CRISPR, echo=TRUE-------------------------------------------
properties <- list(rcsb_entry_info = c("molecular_weight"),
                    exptl = "method",
                    rcsb_accession_info = "deposit_date")

ids =  query_search("CRISPR")

head(ids)


## ----data_fetcher, echo=TRUE--------------------------------------------------
df = data_fetcher(
   id = ids,
   data_type = "ENTRY",
   properties = properties,
   return_as_dataframe = TRUE
 )

head(df)


## ----dataManuplation, echo=TRUE-----------------------------------------------
# Convert character vector to Date
df$deposit_date <- as.Date(df$deposit_date, "%Y-%m-%dT%H:%M:%SZ")

# Adding year column
df$year <- as.numeric(format(df$deposit_date, "%Y"))

# Counting entries per year
df_summary <- aggregate(ID ~ year, data = df, FUN = length)

head(df_summary)


## ----figure6, echo=TRUE, out.width = "100%", out.height = "40%", fig.cap = "Number of CRISPR Deposits by Year", fig.alt="Number of CRISPR Deposits by Year"----
ggplot(df_summary, aes(x = year, y = ID)) +
   geom_line(color = "red") +
   xlim(c(min(df_summary$year), max(df_summary$year)+1)) +
   geom_point() +
   labs( x = 'Year', y = 'Number of Deposits')


## ----POLYMER_ENTITY, echo=TRUE------------------------------------------------
properties <- list(rcsb_entity_source_organism =  c("ncbi_taxonomy_id", 
                                                    "ncbi_scientific_name"),
                   rcsb_cluster_membership =  c("cluster_id", "identity"))

ids =  c("4HHB_1", "12CA_1", "3PQR_1")

df = data_fetcher(
  id = ids,
  data_type = "POLYMER_ENTITY",
  properties = properties,
  return_as_dataframe = TRUE
)

df


## ----describe_chemical, echo=TRUE---------------------------------------------
chem_desc <- describe_chemical('ATP')
chem_desc$rcsb_chem_comp_descriptor$smiles


## ----get_pdb_file, echo=TRUE--------------------------------------------------
pdb_file <- get_pdb_file(pdb_id = "4HHB", filetype = "cif")


## ----pdb_file_atom, echo=TRUE-------------------------------------------------
head(pdb_file$atom)


## ----pdb_file_xyz, echo=TRUE--------------------------------------------------
head(pdb_file$xyz[1,])


## ----pdb_file_calpha, echo=TRUE-----------------------------------------------
head(pdb_file$calpha)


## ----figure7NotEval, echo=TRUE, eval=FALSE------------------------------------
# # Load necessary libraries
# library(rPDBapi)
# library(r3dmol)
# 
# # Retrieve and save a PDB structure
# pdb_path <- get_pdb_file("1XYZ", filetype = "pdb", save = TRUE)
# pdb_file <- pdb_path$path  # Use the path returned by get_pdb_file
# 
# # Load the structure into r3dmol and set visualization styles
# viewer <- r3dmol() %>%
#   m_add_model(pdb_file, format = "pdb") %>%
#   m_set_style(
#     sel = m_sel(ss = "helix"),  # Select alpha helices
#     style = m_style_cartoon(color = "red")  # Color helices red
#   ) %>%
#   m_set_style(
#     sel = m_sel(ss = "sheet"),  # Select beta sheets
#     style = m_style_cartoon(color = "yellow")  # Color sheets yellow
#   ) %>%
#   m_set_style(
#     sel = m_sel(ss = "coil"),  # Select coils/turns
#     style = m_style_cartoon(color = "blue")  # Color coils blue
#   ) %>%
#   m_zoom_to()
# 
# # Display the viewer with secondary structure
# viewer


## ----figure7, out.width = "100%", fig.align='center', fig.height=5, fig.width=5, fig.cap = "Secondary structure visualization of protein 1XYZ with color-coded elements."----
 knitr::include_graphics("figures/figure7.jpg")


## ----get_info, echo=TRUE------------------------------------------------------
hemoglobin_info <- get_info(pdb_id = "4HHB")


## ----audit_author, echo=TRUE--------------------------------------------------
hemoglobin_info$audit_author


## ----cell, echo=TRUE----------------------------------------------------------
hemoglobin_info$cell


## ----symmetry, echo=TRUE------------------------------------------------------
hemoglobin_info$symmetry


## ----structural_data, echo=TRUE-----------------------------------------------
# Load necessary libraries
library(rPDBapi)
library(Biostrings)
library(msa)
library(ggplot2)

# Step 1: Perform a search for kinase-related PDB entries
search_operator <- list(
  type = "terminal",
  service = "full_text",
  parameters = list(value = "kinase")
)

# Perform the search and limit the number of entries
protein_entities <- perform_search(
  search_operator = search_operator,
  return_type = "ENTRY"
)
protein_entities <- protein_entities[1:10]  # Select the first 10 entries

# Step 2: Fetch sequence data and perform multiple sequence alignment
get_protein_sequence <- function(pdb_id) {
  fasta <- get_fasta_from_rcsb_entry(pdb_id)
  AAString(fasta[[1]])
}

# Retrieve and align protein sequences
sequences <- lapply(protein_entities, get_protein_sequence)
names(sequences) <- protein_entities
alignment <- msa(AAStringSet(sequences), method = "ClustalW")
alignment_matrix <- as.matrix(alignment)

# Step 3: Calculate pairwise sequence similarity
pairwise_similarity <- function(seq1, seq2) {
  sum(seq1 == seq2) / length(seq1) * 100
}

n <- length(sequences)
similarity_matrix <- matrix(NA, n, n)
rownames(similarity_matrix) <- names(sequences)
colnames(similarity_matrix) <- names(sequences)
for (i in 1:n) {
  for (j in i:n) {
    similarity_matrix[i, j] <- pairwise_similarity(alignment_matrix[i, ], 
                                                   alignment_matrix[j, ])
    similarity_matrix[j, i] <- similarity_matrix[i, j]
  }
}

# Step 4: Fetch and analyze structural and experimental information using get_info
get_structural_info <- function(pdb_id) {
  info <- get_info(pdb_id)

  # Extract relevant structural and experimental data
  resolution <- info$rcsb_entry_info$diffrn_resolution_high$value
  r_free <- info$refine$ls_rfactor_rfree
  r_work <- info$refine$ls_rfactor_rwork
  molecular_weight <- info$rcsb_entry_info$molecular_weight
  citation_year <- info$rcsb_primary_citation$year

  return(list(
    pdb_id = pdb_id,
    resolution = resolution,
    r_free = r_free,
    r_work = r_work,
    molecular_weight = molecular_weight,
    citation_year = citation_year
  ))
}

structural_info <- lapply(protein_entities, get_structural_info)

# Step 5: Compile the structural information into a data frame
structural_data <- data.frame(
  PDB_ID = sapply(structural_info, function(x)
    if (!is.null(x$pdb_id))
      x$pdb_id
    else
      NA_character_),
  Resolution = sapply(structural_info, function(x)
    if (!is.null(x$resolution))
      x$resolution
    else
      NA_real_),
  R_free = sapply(structural_info, function(x)
    if (!is.null(x$r_free))
      x$r_free
    else
      NA_real_),
  R_work = sapply(structural_info, function(x)
    if (!is.null(x$r_work))
      x$r_work
    else
      NA_real_),
  Molecular_Weight = sapply(structural_info, function(x)
    if (!is.null(x$molecular_weight))
      x$molecular_weight
    else
      NA_real_),
  Citation_Year = sapply(structural_info, function(x)
    if (!is.null(x$citation_year))
      x$citation_year
    else
      NA_integer_)
)

structural_data


## ----get_fasta_from_rcsb_entry, echo=TRUE-------------------------------------
fasta_sequence <- get_fasta_from_rcsb_entry(rcsb_id = "4HHB", 
                                            chain_id = "A", 
                                            verbosity = FALSE)


## ----fasta_sequence, echo=TRUE------------------------------------------------
# Split the sequence into chunks of 60 characters
split_sequence <- strsplit(fasta_sequence, '(?<=.{60})', perl = TRUE)[[1]]

# Print the split sequence with line breaks
cat(split_sequence, sep = "\n") 


## ----retrieve_fasta, echo=TRUE------------------------------------------------
library(rPDBapi)
library(Biostrings)

# Retrieve the FASTA sequence for the first PDB entry (4HHB)
fasta_sequence_1 <- get_fasta_from_rcsb_entry("4HHB", chain_id = "B")
protein_sequence_1 <- fasta_sequence_1

# Convert the first sequence to an AAStringSet object for protein sequences
aa_sequence_1 <- AAStringSet(protein_sequence_1)

# Retrieve the FASTA sequence for a second PDB entry (1A6M)
fasta_sequence_2 <- get_fasta_from_rcsb_entry("1A6M", chain_id = "A")
protein_sequence_2 <- fasta_sequence_2

# Convert the second sequence to an AAString object for alignment
aa_sequence_2 <- AAString(protein_sequence_2)


## ----alignment, echo=TRUE-----------------------------------------------------
# Perform pairwise alignment between the two protein sequences
alignment <- pairwiseAlignment(
  aa_sequence_1,
  aa_sequence_2,
  substitutionMatrix = "BLOSUM62",
  gapOpening = 10,
  gapExtension = 0.5
)
alignment


## ----pattern, echo=TRUE-------------------------------------------------------
# Search for motifs (e.g., a specific amino acid pattern) in the first sequence
motif <- "VHLTPEEKS"
match_positions <- vmatchPattern(motif, aa_sequence_1)
match_positions


## ----score, echo=TRUE---------------------------------------------------------
# Extract the alignment score
alignment_score <- score(alignment)
cat("Alignment Score:", alignment_score, "\n")

# Calculate the percentage identity
identity <- pid(alignment)
cat("Percentage Identity:", identity, "%\n")



## ----phylogenetic, echo=TRUE--------------------------------------------------
# Load necessary libraries
library(rPDBapi)
library(Biostrings)
library(ape)
library(ggtree)
library(msa)
library(phangorn)

# Step 1: Use query_search to retrieve PDB IDs related to a specific keyword
pdb_ids <- query_search(search_term = "hemoglobin")

# Filter or limit to the first 50 PDB IDs for demonstration purposes
pdb_ids <- pdb_ids[1:50]

# Function to retrieve sequences
get_protein_sequence <- function(pdb_id) {
  fasta <- get_fasta_from_rcsb_entry(pdb_id, chain_id = "A")
  return(AAString(fasta))
}

# Retrieve sequences for all PDB IDs
sequences <- lapply(pdb_ids, get_protein_sequence)

# Combine sequences into a single AAStringSet object
combined_sequences <- AAStringSet(sequences)
names(combined_sequences) <- pdb_ids

# Perform multiple sequence alignment
alignment <- msa(combined_sequences, method = "ClustalW")
alignment



## ----dist_matrix, echo=TRUE---------------------------------------------------
# Convert the aligned sequences to a matrix
alignment_matrix <- as.matrix(alignment)

# Convert the alignment matrix to a phyDat object
alignment_phyDat <- phyDat(alignment_matrix, type = "AA")

# Construct a distance matrix using a protein distance measure
dist_matrix <- dist.ml(alignment_phyDat)

# Construct the tree using Neighbor-Joining method
tree <- NJ(dist_matrix)

tree


## ----figure8, echo=TRUE, out.width = "100%", out.height = "50%", fig.cap="Phylogenetic tree of hemoglobin-related proteins with styled nodes for clarity."----
# Visualize the phylogenetic tree using ggtree with enhanced styling
ggtree(tree) +
  geom_tiplab(aes(label = label), size = 2, fontface = "italic", align = TRUE) +
  geom_nodepoint(color = "blue", size = 3, shape = 21, fill = "lightblue") +
  geom_treescale(x = 0, y = -2, width = 0.05) +
  theme_tree2() +
  labs(title = "Phylogenetic Tree of Selected PDB Entries",
       subtitle = "Based on Multiple Sequence Alignment") +
  theme(plot.title = element_text(hjust = 0.5, size = 10, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5, size = 8),
        plot.caption = element_text(size = 8, face = "italic"))


## ----find_results, echo=TRUE--------------------------------------------------
crispr_citations <- find_results("CRISPR", field = "citation")
crispr_citations[[1]]


## ----find_papers, echo=TRUE---------------------------------------------------
covid_paper_titles <- find_papers("CRISPR", max_results = 5)

# Truncate paper titles to 50 characters
covid_paper_titles <- lapply(covid_paper_titles, function(title) {
  if(nchar(title) > 50) {
    paste0(substr(title, 1, 47), "...")
  } else {
    title
  }
})

# Display the truncated titles
covid_paper_titles


## ----search_operator, echo=TRUE-----------------------------------------------
# Load necessary libraries
library(rPDBapi)  
library(tm)       
library(wordcloud) 

# Define the search operator to find PDB entries related to "ligase"
search_operator <- list(
  type = "terminal",
  service = "full_text",
  parameters = list(value = "ligase")
)


## ----ligase_entries, echo=TRUE------------------------------------------------
# Perform the search with the return type set to "ENTRY"
ligase_entries <- perform_search(
  search_operator = search_operator,
  return_type = "ENTRY"
)


## ----ligase_entries_100, echo=TRUE--------------------------------------------
# Select a subset of entries for analysis (e.g., the first 100)
pdb_ids <- ligase_entries[1:100]


## ----fetch_pdb_info, echo=TRUE------------------------------------------------
# Function to fetch results and related papers for a given PDB ID
fetch_pdb_info <- function(pdb_id) {
  results <- find_results(pdb_id)  # Fetch structural data
  papers <- find_papers(pdb_id)    # Fetch related papers

  return(list(results = results, papers = papers))
}

# Apply the function to all selected PDB IDs
pdb_info <- lapply(pdb_ids, fetch_pdb_info)


## ----pdb_analysis, echo=TRUE--------------------------------------------------
# Function to analyze PDB info
analyze_pdb_info <- function(info) {
  # Extract the number of related papers
  num_papers <- length(info$papers[[1]])

  # Extract titles of related papers
  paper_titles <- paste(info$papers[[1]], collapse = "; ")

  return(list(num_papers = num_papers, paper_titles = paper_titles))
}

# Apply the analysis to each PDB ID
pdb_analysis <- lapply(pdb_info, analyze_pdb_info)


## ----pdb_analysis_df, echo=TRUE-----------------------------------------------
# Convert the list into a data frame for easier analysis
pdb_analysis_df <- data.frame(
  PDB_ID = pdb_ids,
  Number_of_Papers = sapply(pdb_analysis, function(x) x$num_papers),
  Paper_Titles = sapply(pdb_analysis, function(x) x$paper_titles)
)

# Truncate with ellipses if the title is longer than 50 characters
pdb_analysis_df_truncated <- pdb_analysis_df
pdb_analysis_df_truncated$Paper_Titles <-
  ifelse(
    nchar(pdb_analysis_df_truncated$Paper_Titles) > 50,
    paste0(substr(
      pdb_analysis_df_truncated$Paper_Titles, 1, 47
    ), "..."),
    pdb_analysis_df_truncated$Paper_Titles
  )

head(pdb_analysis_df_truncated)  


## ----corpus, echo=TRUE--------------------------------------------------------
# Combine all paper titles into a single string
all_titles <- paste(pdb_analysis_df$Paper_Titles, collapse = " ")

# Create a corpus and clean the text
corpus <- Corpus(VectorSource(all_titles))
corpus <- tm_map(corpus, content_transformer(tolower))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, removeNumbers)
corpus <- tm_map(corpus, removeWords, stopwords("en"))


## ----figure9, echo=TRUE, fig.width=2, fig.height=2, fig.cap="Word cloud showing frequent terms in paper titles related to ligase structures."----
# Create a term-document matrix
tdm <- TermDocumentMatrix(corpus)
m <- as.matrix(tdm)
word_freqs <- sort(rowSums(m), decreasing = TRUE)
word_freqs_df <- data.frame(word = names(word_freqs), freq = word_freqs)

# Generate a word cloud to visualize common themes
wordcloud(words = word_freqs_df$word, freq = word_freqs_df$freq, min.freq = 2,
          max.words = 100, random.order = FALSE, colors = brewer.pal(8, "Dark2"))


## ----generate_json_query, echo=TRUE-------------------------------------------
ids <- c("1XYZ", "2XYZ")
properties <- list(cell = c("volume", "angle_beta"), exptl = c("method"))
json_query <- generate_json_query(ids, "ENTRY", properties)

# Insert a single break line after "entry_ids: [\"1XYZ\", \"2XYZ\"]"
json_query <- gsub("(\\[\"1XYZ\", \"2XYZ\"\\])", "\\1\n", json_query)

# Display the modified output with one break line
json_query

