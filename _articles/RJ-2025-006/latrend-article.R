# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit latrend-article.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
options(
  knitr.purl.inline = TRUE,
  latrend.verbose = FALSE
)
options(latrend.id = "Patient", latrend.time = "Week") # rmarkdown sometimes forgets the options (cache issue?)

knitr::opts_chunk$set(
  warning = FALSE,
  cache = TRUE,
  cache.extra = list(R.version, sessionInfo()),
  fig.align = "center",
  fig.path = "figures/"
)

library("data.table")
library("ggplot2")
library("latrend")
library("kml")
library("dtwclust")
library("lcmm")
library("clValid")
library("mclustcomp")
library("caret")
library("igraph")
data(PAP.adh)
theme_set(theme_bw(base_size = 10))


ifelse(knitr::is_latex_output(), 'Table \\ref{tbl:compare}', 'the table below')
ifelse(knitr::is_latex_output(), 'Table \\ref{tbl:methods}', 'the table below')
uniqueN(PAP.adh$Patient)
max(PAP.adh$Week)
round(min(PAP.adh$UsageHours), 1)
round(max(PAP.adh$UsageHours), 1)
round(mean(PAP.adh$UsageHours), 1)
max(PAP.adh$Week)
## ----library------------------------------------------------------------------
library("latrend")
data("PAP.adh")
head(PAP.adh, n = 3)


## ----options------------------------------------------------------------------
options(latrend.id = "Patient", latrend.time = "Week")


ifelse(knitr::is_latex_output(), 'Figure \\ref{fig:data}', 'the figure below')
## ----data, fig.width=6, fig.height=2, fig.cap="The trajectories from the `PAP.adh` dataset, by reference group."----
plotTrajectories(PAP.adh, response = "UsageHours", cluster = "Group")


## ----kml, message=FALSE-------------------------------------------------------
kmlMethod <- lcMethodKML(response = "UsageHours", nClusters = 2)
kmlMethod


## ----kml-time-----------------------------------------------------------------
kmlMethod$time
kmlMethod[["time", eval = FALSE]]


## ----method-specs, message=FALSE, results='hide'------------------------------
dtwMethod <- lcMethodDtwclust(response = "UsageHours", distance = "dtw_basic")
lmkmMethod <- lcMethodLMKM(formula = UsageHours ~ Week)
gbtmMethod <- lcMethodLcmmGBTM(fixed = UsageHours ~ Week,
  mixture = ~ Week, idiag = TRUE)
gmmMethod <- lcMethodLcmmGMM(fixed = UsageHours ~ Week,
  mixture = ~ Week, random = ~ 1, idiag = TRUE)


## ----kml3---------------------------------------------------------------------
kml3Method <- update(kmlMethod, nClusters = 3)


## ----methods------------------------------------------------------------------
kmlMethods  <- lcMethods(kmlMethod,  nClusters = 1:6)
lmkmMethods <- lcMethods(lmkmMethod, nClusters = 1:6)
dtwMethods  <- lcMethods(dtwMethod,  nClusters = 2:6)
gbtmMethods <- lcMethods(gbtmMethod, nClusters = 1:4)
gmmMethods  <- lcMethods(gmmMethod,  nClusters = 1:4)
length(gmmMethods)


## ----lmkm2--------------------------------------------------------------------
lmkm2 <- latrend(lmkmMethod, data = PAP.adh)
summary(lmkm2)


## ----lmkm3--------------------------------------------------------------------
lmkm3 <- latrend(lmkmMethod, nClusters = 3, data = PAP.adh)


## ----lmkm3-update-------------------------------------------------------------
lmkm3 <- update(lmkm2, nClusters = 3)


## ----lmkm-batch---------------------------------------------------------------
lmkmList <- latrendBatch(lmkmMethods, data = PAP.adh, seed = 1)
lmkmList


## ----dtw-batch----------------------------------------------------------------
dtwList <- latrendBatch(dtwMethods, data = PAP.adh, seed = 1)


## ----parallel-setup, eval = FALSE---------------------------------------------
# nCores <- parallel::detectCores(logical = FALSE)
# if (.Platform$OS.type == "windows") {
#   doParallel::registerDoParallel(parallel::makeCluster(nCores))
# } else {
#   doMC::registerDoMC(nCores)
# }


## ----parallel-batch-----------------------------------------------------------
kmlList  <- latrendBatch(kmlMethods,
  data = PAP.adh, parallel = TRUE, seed = 1)
gbtmList <- latrendBatch(gbtmMethods,
  data = PAP.adh, parallel = TRUE, seed = 1)
gmmList  <- latrendBatch(gmmMethods,
  data = PAP.adh, parallel = TRUE, seed = 1)


ifelse(knitr::is_latex_output(), 'Figure \\ref{fig:trends}', 'the figure below')
## ----trends, fig.width=6, fig.height=2, fig.cap="The cluster trajectories of the three-cluster solution identified by LMKM, created by running plot(lmkm3)."----
plot(lmkm3, linewidth = 1)


## ----lmkm3-names--------------------------------------------------------------
clusterNames(lmkm3) <- c("Struggling", "Increasing", "Decreasing")


## ----lmkm3-predict, warning=FALSE---------------------------------------------
predict(lmkm3, newdata = data.frame(Week = c(1, 10), Cluster = "Decreasing"))


## ----lmkm3-metric-------------------------------------------------------------
metric(lmkm3, c("MAE", "RMSE", "Dunn", "ASW"))


## ----numclusmetrics, fig.cap="The Dunn index (higher is better), and WMAE (lower is better) metrics for each of the KmL solutions from 1 to 6 clusters", fig.height=1.5, fig.width=5, warning=FALSE----
plotMetric(kmlList, c("Dunn", "WMAE", "estimationTime"))


ifelse(knitr::is_latex_output(), 'Figure \\ref{fig:numclusmetrics}', 'the figure above')
## ----kmls-metric--------------------------------------------------------------
metric(kmlList, c("Dunn", "WMAE", "estimationTime"))


## ----kml-max------------------------------------------------------------------
kmlBest <- max(kmlList, "Dunn")


## ----kml-subset---------------------------------------------------------------
kmlBest <- subset(kmlList, nClusters == 5, drop = TRUE)


## ----numclus, fig.cap="The Dunn index (higher is better), WMAE (lower is better) and BIC (relatively lower is better) for each of the methods and number of clusters", fig.height=2, fig.width=5, warning=FALSE----
allList <- lcModels(lmkmList, kmlList, dtwList, gbtmList, gmmList)
plotMetric(allList, name = c("Dunn", "WMAE", "BIC", "estimationTime"), group = '.method')


## ----subsets------------------------------------------------------------------
kmlBest  <- subset(kmlList,  nClusters == 5, drop = TRUE)
dtwBest  <- subset(dtwList,  nClusters == 5, drop = TRUE)
gbtmBest <- subset(lmkmList, nClusters == 4, drop = TRUE)
lmkmBest <- subset(lmkmList, nClusters == 3, drop = TRUE)
gmmBest  <- subset(gmmList,  nClusters == 3, drop = TRUE)


## ----best-list----------------------------------------------------------------
bestList <- lcModels(KmL = kmlBest, DTW = dtwBest,
  LMKM = lmkmBest, GBTM = gbtmBest, GMM = gmmBest)
externalMetric(bestList, name = "adjustedRand") |> signif(2)


min(externalMetric(bestList, name = "adjustedRand")) |> signif(2)
signif(externalMetric(gmmBest, lmkmBest, 'adjustedRand'), 2)
## ----best-external-metric-----------------------------------------------------
externalMetric(bestList, name = "WMMAE") |> signif(2)


signif(externalMetric(gbtmBest, lmkmBest, 'WMMAE'), 2)
formatC(sigma(gbtmBest), format = 'f', digits = 1)
## ----rep----------------------------------------------------------------------
kmlRepList <- latrendRep(kmlMethod, data = PAP.adh,
  nClusters = 5, .rep = 5, .parallel = TRUE)
summary(metric(kmlRepList, c("Dunn", "WMAE")))


## ----boot---------------------------------------------------------------------
kmlMethodBest <- update(kmlMethod, nClusters = 5)
kmlBootModels <- latrendBoot(kmlMethodBest, data = PAP.adh,
  samples = 10, seed = 1, parallel = TRUE)
head(kmlBootModels, n = 3)


## ----boot-metric--------------------------------------------------------------
bootMetrics <- metric(kmlBootModels, c("converged", "Dunn", "WMAE"))
mean(bootMetrics$converged)
summary(bootMetrics$Dunn)
summary(bootMetrics$WMAE)


## ----wmmae--------------------------------------------------------------------
wmmaeDist <- externalMetric(kmlBootModels[1:10], name = "WMMAE")
summary(wmmaeDist)


## ----partition----------------------------------------------------------------
refAssignments <- aggregate(Group ~ Patient, data = PAP.adh, FUN = head, n = 1L)
refAssignments$Cluster = refAssignments$Group

refModel <- lcModelPartition(data = PAP.adh,
  trajectoryAssignments = refAssignments, response = "UsageHours")
refModel


## ----splitjoin----------------------------------------------------------------
externalMetric(bestList, refModel, name = "splitJoin.ref", drop = FALSE)


## ----stratify-----------------------------------------------------------------
stratMethod <- lcMethodStratify(response = "UsageHours", stratify = mean(UsageHours) > 4)
stratModel <- latrend(stratMethod, data = PAP.adh)
clusterProportions(stratModel)


## ----feature-rep--------------------------------------------------------------
repStep <- function(method, data, verbose) {
  repTraj <- function(trajData) {
    lm.rep <- lm(method$formula, data = trajData)
    coef(lm.rep)
  }
  dt <- as.data.table(data)
  coefData <- dt[, as.list(repTraj(.SD)), keyby = c(method$id)]
  coefMat <- as.matrix(subset(coefData, select = -1))
  rownames(coefMat) <- coefData[[method$id]]
  coefMat
}


## ----feature-clus-------------------------------------------------------------
clusStep <- function(method, data, repMat, envir, verbose) {
  km <- kmeans(repMat, centers = method$nClusters)
  lcModelPartition(response = responseVariable(method), method = method,
    data = data, trajectoryAssignments = km$cluster, center = mean)
}


## ----feature-est--------------------------------------------------------------
tsMethod <- lcMethodFeature(response = "UsageHours", formula = UsageHours ~ Week,
  representationStep = repStep, clusterStep = clusStep)
tsModel <- latrend(tsMethod, data = PAP.adh, nClusters = 5)
externalMetric(tsModel, kmlBest, "adjustedRand")
externalMetric(tsModel, kmlBest, "WMMAE")


paste(R.Version()[c('major', 'minor')], collapse = '.')
packageVersion('latrend')
packageVersion('ggplot2')
packageVersion('data.table')
packageVersion('kml')
packageVersion('dtwclust')
packageVersion('lcmm')
packageVersion('foreach')
