# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2025-009.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
run_level <- 3  # Pick 1 or 3

rda_dir <- 'data/'

# rda_dir <- paste0("rda",run_level,"/")
if(!dir.exists(rda_dir)) dir.create(rda_dir)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(knitr)
library(ggplot2)
library(pomp)
library(panelPomp)
library(foreach)
library(doParallel)
library(doRNG)
library(kableExtra)

stopifnot(packageVersion("pomp")>="6.2.1")
stopifnot(packageVersion("panelPomp")>="1.7")

cores <- 36

registerDoParallel(cores)
registerDoRNG(25880)

GOMP_U <- switch(run_level, 3, 5, 50)
GOMP_N <- switch(run_level, 10, 50, 100)
NP_EVAL <- switch(run_level, 50, 250, 1000)
NP_MIF <- switch(run_level, 100, 250, 1000)

myRound <- function (x, digits = 1) {
    # taken from the broman package
    if (digits < 1)
        stop("This is intended for the case digits >= 1.")
    if (length(digits) > 1) {
        digits <- digits[1]
        warning("Using only digits[1]")
    }
    tmp <- sprintf(paste("%.", digits, "f", sep = ""), x)
    zero <- paste0("0.", paste(rep("0", digits), collapse = ""))
    tmp[tmp == paste0("-", zero)] <- zero
    tmp
}


## ----texFunTab, eval = knitr::is_latex_output(), results='asis'---------------
cat("
\\begin{table}[ht]
\\begin{center}
\\begin{tabular}{llr}\\hline
Method            & Operation & Function\\\\\\hline
\\texttt{rprocess} & Simulate from Eq.~(\\ref{eq:proc}) & $f_{X_{u,n}\\vert X_{u,n-1}}(x_{u,n}\\,|\\, x_{u,n-1} \\,;\\, \\phi,\\psi_u)$\\\\
\\texttt{dprocess} & Evaluate Eq.~(\\ref{eq:proc}) & $f_{X_{u,n}\\vert X_{u,n-1}}(x_{u,n}\\,|\\, x_{u,n-1} \\,;\\, \\phi,\\psi_u)$\\\\
\\texttt{rmeasure} & Simulate from Eq.~(\\ref{eq:meas}) & $f_{Y_{u,n}|X_{u,n}}(y_{u,n}\\,|\\, x_{u,n} \\,;\\, \\phi,\\psi_u)$\\\\
\\texttt{dmeasure} & Evaluate Eq.~(\\ref{eq:meas}) & $f_{Y_{u,n}|X_{u,n}}(y_{u,n}\\,|\\, x_{u,n} \\,;\\, \\phi,\\psi_u)$\\\\
\\texttt{rinit}   & Simulate from Eq.~(\\ref{eq:init}) & $f_{X_{u,0}}(x_{u,0} \\,;\\, \\phi,\\psi_u)$\\\\
\\texttt{dinit}   & Evalutate Eq.~(\\ref{eq:init}) & $f_{X_{u,0}}(x_{u,0} \\,;\\, \\phi,\\psi_u)$\\\\\\hline
\\end{tabular}
\\end{center}
\\caption{\\label{tab:funs}Methods of a unit model in a \\texttt{panelPomp} object and their mathematical definitions.}
\\end{table}
")


## ----htmlFunTab, eval=knitr::is_html_output(), results='asis'-----------------
# tabl <- "
# | Method       | Operation                     | Function                 |
# |--------------|-------------------------------|-------------------------:|
# | \`rprocess\` | Simulate from \\@ref(eq:proc) | $f_{X_{u,n}\\vert X_{u,n-1}}(x_{u,n}\\,|\\, x_{u,n-1} \\,;\\, \\phi,\\psi_u)$ |
# | \`dprocess\` | Evaluate \\@ref(eq:proc)      | $f_{X_{u,n}\\vert X_{u,n-1}}(x_{u,n}\\,|\\, x_{u,n-1} \\,;\\, \\phi,\\psi_u)$ |
# | \`rmeasure\` | Simulate from \\@ref(eq:meas) | $f_{Y_{u,n}|X_{u,n}}(y_{u,n}\\,|\\, x_{u,n} \\,;\\, \\phi,\\psi_u)$ |
# | \`dmeasure\` | Evaluate \\@ref(eq:meas)      | $f_{Y_{u,n}|X_{u,n}}(y_{u,n}\\,|\\, x_{u,n} \\,;\\, \\phi,\\psi_u)$ |
# | \`rinit\`    | Slimuate from \\@ref(eq:init) | $f_{X_{u,0}}(x_{u,0} \\,;\\, \\phi,\\psi_u)$ |
# | \`dinit\`    | Evaluate \\@ref(eq:init)      | $f_{X_{u,0}}(x_{u,0} \\,;\\, \\phi,\\psi_u)$ |
# 
# Table: Methods of a unit model in a `panelPomp` object and their mathematical definitions.
# "
# cat(tabl) # output the table in a format good for HTML/PDF/docx conversion


## ----unitGompz, echo=TRUE-----------------------------------------------------
gomp_u1 <- pomp::gompertz(
  K = 1, r = 0.1, sigma = 0.1, tau = 0.1, X_0 = 1, times = 1:20, seed = 111
)

gomp_u2 <- pomp::gompertz(
  K = 1.5, r = 0.1, sigma = 0.1, tau = 0.07, X_0 = 1, times = 1:21, seed = 222
)

gomp_u3 <- pomp::gompertz(
  K = 1.2, r = 0.1, sigma = 0.1, tau = 0.15, X_0 = 1, times = 3:25, seed = 333
)


## ----panelPompConstructor, echo=TRUE------------------------------------------
gomp <- panelPomp(
  object = list(gomp_u1, gomp_u2, gomp_u3),
  shared = c("r" = 0.1, "sigma" = 0.1),
  specific = c("K", "tau", "X_0")
)


## ----coefGomp, echo=TRUE------------------------------------------------------
coef(gomp)['K[unit2]'] <- 0.9
coef(gomp)


## ----listCoef, echo=TRUE------------------------------------------------------
coef(gomp, format = 'list')
shared(gomp)


## ----setters, echo=TRUE-------------------------------------------------------
shared(gomp) <- c("tau" = 0.15)
shared(gomp)
specific(gomp)


## ----plotMeas, echo=TRUE, fig.width=5.5, fig.height=3.2, fig.align='center', cache=TRUE----
plot(panelMeasles(), units = c('Bradford', 'London'))


## ----pfGompSetup, echo=FALSE, include=FALSE-----------------------------------
pfGomp1_exp <- substitute(
  gomp <- panelGompertz(N = GOMP_N, U = GOMP_U),
  list(GOMP_N = GOMP_N, GOMP_U = GOMP_U)
)
pfGomp2_exp <- substitute(
  gomp_pfd <- pfilter(gomp, Np = NP_GOMP),
  list(GOMP_N = GOMP_N, GOMP_U = GOMP_U, NP_GOMP = NP_EVAL)
)
pfGompRep_exp <- substitute(
  pf_results <- foreach(i=1:10) %dopar% {
  pfilter(gomp, Np = NP_EVAL)
}, list(NP_EVAL = NP_EVAL)
)


## ----pfGomp1, code=pfGomp1_exp, eval=FALSE, echo=FALSE------------------------
# NA


## ----pfGomp2, code=pfGomp2_exp, eval=FALSE, echo=FALSE------------------------
# NA


## ----showGomp1, ref.label='pfGomp1', echo=TRUE, eval=FALSE--------------------
# NA


## ----showGomp, ref.label='pfGomp2', echo=TRUE, eval=FALSE---------------------
# NA


## ----pfGomp_eval, echo=FALSE, eval=TRUE---------------------------------------
stew(file = paste0(rda_dir, 'pfGomp.rda'),{
eval(pfGomp1_exp)
eval(pfGomp2_exp)
})


## ----pf_core, code=pfGompRep_exp, eval=FALSE, echo=TRUE-----------------------
# NA


## ----pf_loglik1, eval=FALSE, echo=FALSE---------------------------------------
# lambda_1 <- logmeanexp(
#   sapply(pf_results,logLik), se = TRUE
# )


## ----pf_loglik2, eval=FALSE, echo=FALSE---------------------------------------
# lambda_2 <- panel_logmeanexp(
#   sapply(pf_results,unitLogLik), MARGIN = 1, se = TRUE
# )


## ----loglik_exact, eval=TRUE, echo=FALSE--------------------------------------
lambda_exact <- panelGompertzLikelihood(
  coef(gomp), gomp, coef(gomp)
)


## ----pf_eval, echo=FALSE, eval=TRUE-------------------------------------------
stew(file=paste0(rda_dir,"pf.rda"),{
eval(pfGompRep_exp)
lambda_1 <- logmeanexp(
  sapply(pf_results,logLik), se = TRUE
)
lambda_2 <- panel_logmeanexp(
  sapply(pf_results,unitLogLik), MARGIN = 1, se = TRUE
)
})
load(paste0(rda_dir,"pf.rda")) # to access system time
pf_time <- .system.time


## ----echo=TRUE, eval=FALSE----------------------------------------------------
# lambda_1 <- logmeanexp(
#   sapply(pf_results,logLik), se = TRUE
# )


## ----echo=TRUE,eval=FALSE-----------------------------------------------------
# lambda_2 <- panel_logmeanexp(
#   sapply(pf_results,unitLogLik), MARGIN = 1, se = TRUE
# )


## ----mpif_alg, echo=FALSE, include=FALSE, eval=FALSE--------------------------
# texString <- "
# \\begin{algorithm}[t!]
#   \\caption{
# %    \\textbf{Panel iterated filtering}.
#     \\texttt{mif2$\\big($pp, Nmif\\,=\\,$M$, Np\\,=\\,$J$,
# start{\\,=\\,}$(\\phi^0_{a},\\psi^0_{b,u})$,
# rw\\_sd{\\,=\\,}$(\\sigma^\\Phi_{a,n},\\sigma^\\Psi_{b,u,n})$,
# cooling.factor.50{\\,=\\,}$\\rho^{50}\\big)$}, where \\texttt{pp} is a \\texttt{panelPomp} object containing data and defined \\texttt{rprocess}, \\texttt{dmeasure}, \\texttt{rinit} and \\texttt{partrans} components.
#     \\label{alg:pif}
#     }
# \\noindent\\begin{tabular}{ll}
# {\\bf input:}\\rule[-1.5mm]{0mm}{6mm}
# & Data, $y_{u,n}^*$, $u$ in $1\\,{:}\\,U$, $n$ in $1\\,{:}\\,N$\\\\
# & Simulator of initial density, $f_{X_{u,0}}(x_{u,0} {\\,;\\,} \\phi,\\psi_{u})$ \\\\
# & Simulator of transition density, $f_{X_{u,n}|X_{u,n-1}}(x_{u,n}\\,|\\, x_{u,n-1}{\\,;\\,} \\phi,\\psi_{u})$ \\\\
# & Evaluator of measurement density, $f_{Y_{u,n}|X_{u,n}}(y_{u,n}\\,|\\, x_{u,n}{\\,;\\,}\\phi,\\psi_{u})$ \\\\
# & Number of particles, $J$, and number of iterations, $M$\\\\
# & Starting shared parameter swarm, $\\Phi^0_{a,j}=\\phi^0_{a}$, $a$ in $1\\,{:}\\,A$, $j$ in $1\\,{:}\\,J$\\\\
# & Starting unit-specific parameter swarm, $\\Psi^0_{b,u,j}=\\psi^0_{b,u}$,  $b$ in  $1\\,{:}\\,B$, $j$ in $1\\,{:}\\,J$\\\\
# & Random walk intensities,
# $\\sigma^\\Phi_{a,n}$ and $\\sigma^\\Psi_{b,u,n}$ \\\\
# & Parameter transformations, $h^{\\Phi}_{a}$ and $h^{\\Psi}_{b}$, with inverses
#  $\\big(h^{\\Phi}_{a}\\big)^{-1}$ and $\\big(h^{\\Psi}_{b}\\big)^{-1}$
# \\\\
# &Logical variable determining marginalization, MARGINALIZE
# \\\\
# {\\bf output:}\\rule[-1.5mm]{0mm}{6mm}
# & Final parameter swarm, $\\Phi^M_{a,j}\\;$ and $\\;\\Psi^M_{b,u,j}$
# \\rule[-2mm]{0mm}{5mm}
# \\end{tabular}
# \\hrule
# 
# \\noindent\\begin{tabular}{l}
# For $m$ in $1: M$\\rule[0mm]{0mm}{5mm}\\\\
# \\hspace{6mm} $\\Phi^m_{a,0,j}=\\Phi^{m-1}_{a,j}$
# % and $\\Psi^m_{b,u,0,j}=\\Psi^{m-1}_{b,u,j}$
# \\rule[-2mm]{0mm}{5mm} \\\\
# \\hspace{6mm} For $u$ in $1:U$\\\\
# \\hspace{6mm} \\hspace{6mm} $\\Phi^{F,m}_{a,u,0,j} =\\big(h^{\\Phi}_{a}\\big)^{-1}
#   \\left(
#   h^\\Phi_a \\big(\\Phi^{m}_{a,u-1,j}\\big)+
#     \\rho^{m}\\sigma^{\\Phi}_{a,0} Z^{\\Phi,m}_{a,u,0,j}
#   \\right)$ for $ Z^{\\Phi,m}_{a,u,0,j}\\sim N[0,1]$ \\rule[-3mm]{0mm}{5mm} \\\\
# \\hspace{6mm} \\hspace{6mm} $\\Psi^{F,m}_{b,u,0,j} =\\big(h^{\\Psi}_{b}\\big)^{-1}
#   \\left(
#   h^\\Psi_b \\big(\\Psi^{m-1}_{b,u,j}\\big)+
#     \\rho^{m}\\sigma^{\\Psi}_{b,u,0} Z^{\\Psi,m}_{b,u,0,j}
#   \\right)$ for $ Z^{\\Psi,m}_{b,u,0,j}\\sim N[0,1]$ \\rule[-3mm]{0mm}{5mm} \\\\
# \\hspace{6mm} \\hspace{6mm} $X_{u,0,j}^{F,m}\\sim f_{X_{u,0}}
#   \\left(
#     x_{u,0} \\; \\big| \\; \\Phi^{F,m}_{a,u,0,j} \\, ,
#     \\Psi^{F,m}_{b,u,0,j}
#   \\right)$ \\rule[-3mm]{0mm}{5mm} \\\\
# \\hspace{6mm} \\hspace{6mm} For $n$ in $1: N_{u}$\\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Phi^{P,m}_{a,u,n,j} =\\big(h^{\\Phi}_{a}\\big)^{-1}
#   \\left(
#   h^\\Phi_a \\big(\\Phi^{F,m}_{a,u,n-1,j}\\big)+
#     \\rho^{m}\\sigma^{\\Phi}_{a,n} Z^{\\Phi,m}_{a,u,n,j}
#   \\right)$ for $ Z^{\\Phi,m}_{a,u,n,j}\\sim N[0,1]$ \\rule[-3mm]{0mm}{5mm} \\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Psi^{P,m}_{b,u,n,j} =\\big(h^{\\Psi}_{b}\\big)^{-1}
#   \\left(
#   h^\\Psi_b \\big(\\Psi^{F,m}_{b,u,n-1,j}\\big)+
#     \\rho^{m}\\sigma^{\\Psi}_{b,u,n} Z^{\\Psi,m}_{b,u,n,j}
#   \\right)$ for $ Z^{\\Psi,m}_{b,u,n,j}\\sim N[0,1]$ \\rule[-3mm]{0mm}{5mm} \\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $X_{u,n,j}^{P,m}\\sim f_{X_{u,n}|X_{u,n-1}}
#    \\left(
#      x_{u,n} \\; \\big| \\; X^{F,m}_{u,n-1,j} \\; {\\,;\\,} \\;
#      \\Phi^{P,m}_{a,u,n,j} \\, ,
#      \\Psi^{P,m}_{b,u,n,j}
#    \\right)$  \\rule[-3mm]{0mm}{5mm} \\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $w_{u,n,j}^m = f_{Y_{u,n}|X_{u,n}}
#     \\left(y^*_{u,n} \\; \\big| \\; X_{u,n,j}^{P,m} \\; {\\,;\\,} \\;
#        \\Phi^{P,m}_{a,u,n,j} \\, ,
#        \\Psi^{P,m}_{b,u,n,j}
#     \\right)$  \\rule[-3mm]{0mm}{5mm} \\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} Draw $k_{1:J}$ with $\\mathbb{P}(k_j=i)=  w_{u,n,i}^m\\Big/\\sum_{q=1}^J w_{u,n,q}^m$ \\rule[-3mm]{0mm}{5mm}  \\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Phi^{F,m}_{a,u,n,j}=\\Phi^{P,m}_{a,u,n,k_{j}}$\\,,  $\\;\\; \\Psi^{F,m}_{b,u,n,j}=\\Psi^{P,m}_{b,u,n,k_{j}} \\;$ and $\\; X^{F,m}_{u,n,j}=X^{P,m}_{u,n,k_j}$ \\rule[-3mm]{0mm}{5mm}  \\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} If MARGINALIZE then\\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Psi^{F,m}_{b,\\nu,n,j}=\\Psi^{P,m}_{b,\\nu,n,j}$ for all $\\nu \\neq u$\\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} Else\\\\
# \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Psi^{F,m}_{b,\\nu,n,j}=\\Psi^{P,m}_{b,\\nu,n,k_j}$ for all $\\nu \\neq u$\\\\
# \\hspace{6mm} \\hspace{6mm} End For \\\\ %%% end n loop
# \\hspace{6mm} \\hspace{6mm}  $\\Phi^{m}_{a,u,j}=\\Phi^{F,m}_{a,u,N_{u},j}$ and
#            $\\Psi^{m}_{b,u,j}=\\Psi^{F,m}_{b,u,N_{u},j}$
#  \\\\
# \\hspace{6mm} End For \\\\ %%% end u loop
# \\hspace{6mm} $\\Phi^{m}_{a,j}=\\Phi^m_{a,U,j}$
# \\\\
# End For \\\\ %%% end m loop
# \\end{tabular}
# \\end{algorithm}
# "


## ----eval=knitr::is_latex_output(), results='asis'----------------------------
texString <- "
\\begin{algorithm}[t!]
  \\caption{
%    \\textbf{Panel iterated filtering}.
    \\texttt{mif2$\\big($pp, Nmif\\,=\\,$M$, Np\\,=\\,$J$,
start{\\,=\\,}$(\\phi^0_{a},\\psi^0_{b,u})$,
rw\\_sd{\\,=\\,}$(\\sigma^\\Phi_{a,n},\\sigma^\\Psi_{b,u,n})$,
cooling.factor.50{\\,=\\,}$\\rho^{50}\\big)$}, where \\texttt{pp} is a \\texttt{panelPomp} object containing data and defined \\texttt{rprocess}, \\texttt{dmeasure}, \\texttt{rinit} and \\texttt{partrans} components.
    \\label{alg:pif}
    }
\\noindent\\begin{tabular}{ll}
{\\bf input:}\\rule[-1.5mm]{0mm}{6mm}
& Data, $y_{u,n}^*$, $u$ in $1\\,{:}\\,U$, $n$ in $1\\,{:}\\,N$\\\\
& Simulator of initial density, $f_{X_{u,0}}(x_{u,0} {\\,;\\,} \\phi,\\psi_{u})$ \\\\
& Simulator of transition density, $f_{X_{u,n}|X_{u,n-1}}(x_{u,n}\\,|\\, x_{u,n-1}{\\,;\\,} \\phi,\\psi_{u})$ \\\\
& Evaluator of measurement density, $f_{Y_{u,n}|X_{u,n}}(y_{u,n}\\,|\\, x_{u,n}{\\,;\\,}\\phi,\\psi_{u})$ \\\\
& Number of particles, $J$, and number of iterations, $M$\\\\
& Starting shared parameter swarm, $\\Phi^0_{a,j}=\\phi^0_{a}$, $a$ in $1\\,{:}\\,A$, $j$ in $1\\,{:}\\,J$\\\\
& Starting unit-specific parameter swarm, $\\Psi^0_{b,u,j}=\\psi^0_{b,u}$,  $b$ in  $1\\,{:}\\,B$, $j$ in $1\\,{:}\\,J$\\\\
& Random walk intensities,
$\\sigma^\\Phi_{a,n}$ and $\\sigma^\\Psi_{b,u,n}$ \\\\
& Parameter transformations, $h^{\\Phi}_{a}$ and $h^{\\Psi}_{b}$, with inverses
 $\\big(h^{\\Phi}_{a}\\big)^{-1}$ and $\\big(h^{\\Psi}_{b}\\big)^{-1}$
\\\\
&Logical variable determining marginalization, MARGINALIZE
\\\\
{\\bf output:}\\rule[-1.5mm]{0mm}{6mm}
& Final parameter swarm, $\\Phi^M_{a,j}\\;$ and $\\;\\Psi^M_{b,u,j}$
\\rule[-2mm]{0mm}{5mm}
\\end{tabular}
\\hrule

\\noindent\\begin{tabular}{l}
For $m$ in $1: M$\\rule[0mm]{0mm}{5mm}\\\\
\\hspace{6mm} $\\Phi^m_{a,0,j}=\\Phi^{m-1}_{a,j}$
% and $\\Psi^m_{b,u,0,j}=\\Psi^{m-1}_{b,u,j}$
\\rule[-2mm]{0mm}{5mm} \\\\
\\hspace{6mm} For $u$ in $1:U$\\\\
\\hspace{6mm} \\hspace{6mm} $\\Phi^{F,m}_{a,u,0,j} =\\big(h^{\\Phi}_{a}\\big)^{-1}
  \\left(
  h^\\Phi_a \\big(\\Phi^{m}_{a,u-1,j}\\big)+
    \\rho^{m}\\sigma^{\\Phi}_{a,0} Z^{\\Phi,m}_{a,u,0,j}
  \\right)$ for $ Z^{\\Phi,m}_{a,u,0,j}\\sim N[0,1]$ \\rule[-3mm]{0mm}{5mm} \\\\
\\hspace{6mm} \\hspace{6mm} $\\Psi^{F,m}_{b,u,0,j} =\\big(h^{\\Psi}_{b}\\big)^{-1}
  \\left(
  h^\\Psi_b \\big(\\Psi^{m-1}_{b,u,j}\\big)+
    \\rho^{m}\\sigma^{\\Psi}_{b,u,0} Z^{\\Psi,m}_{b,u,0,j}
  \\right)$ for $ Z^{\\Psi,m}_{b,u,0,j}\\sim N[0,1]$ \\rule[-3mm]{0mm}{5mm} \\\\
\\hspace{6mm} \\hspace{6mm} $X_{u,0,j}^{F,m}\\sim f_{X_{u,0}}
  \\left(
    x_{u,0} \\; \\big| \\; \\Phi^{F,m}_{a,u,0,j} \\, ,
    \\Psi^{F,m}_{b,u,0,j}
  \\right)$ \\rule[-3mm]{0mm}{5mm} \\\\
\\hspace{6mm} \\hspace{6mm} For $n$ in $1: N_{u}$\\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Phi^{P,m}_{a,u,n,j} =\\big(h^{\\Phi}_{a}\\big)^{-1}
  \\left(
  h^\\Phi_a \\big(\\Phi^{F,m}_{a,u,n-1,j}\\big)+
    \\rho^{m}\\sigma^{\\Phi}_{a,n} Z^{\\Phi,m}_{a,u,n,j}
  \\right)$ for $ Z^{\\Phi,m}_{a,u,n,j}\\sim N[0,1]$ \\rule[-3mm]{0mm}{5mm} \\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Psi^{P,m}_{b,u,n,j} =\\big(h^{\\Psi}_{b}\\big)^{-1}
  \\left(
  h^\\Psi_b \\big(\\Psi^{F,m}_{b,u,n-1,j}\\big)+
    \\rho^{m}\\sigma^{\\Psi}_{b,u,n} Z^{\\Psi,m}_{b,u,n,j}
  \\right)$ for $ Z^{\\Psi,m}_{b,u,n,j}\\sim N[0,1]$ \\rule[-3mm]{0mm}{5mm} \\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $X_{u,n,j}^{P,m}\\sim f_{X_{u,n}|X_{u,n-1}}
   \\left(
     x_{u,n} \\; \\big| \\; X^{F,m}_{u,n-1,j} \\; {\\,;\\,} \\;
     \\Phi^{P,m}_{a,u,n,j} \\, ,
     \\Psi^{P,m}_{b,u,n,j}
   \\right)$  \\rule[-3mm]{0mm}{5mm} \\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $w_{u,n,j}^m = f_{Y_{u,n}|X_{u,n}}
    \\left(y^*_{u,n} \\; \\big| \\; X_{u,n,j}^{P,m} \\; {\\,;\\,} \\;
       \\Phi^{P,m}_{a,u,n,j} \\, ,
       \\Psi^{P,m}_{b,u,n,j}
    \\right)$  \\rule[-3mm]{0mm}{5mm} \\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} Draw $k_{1:J}$ with $\\mathbb{P}(k_j=i)=  w_{u,n,i}^m\\Big/\\sum_{q=1}^J w_{u,n,q}^m$ \\rule[-3mm]{0mm}{5mm}  \\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Phi^{F,m}_{a,u,n,j}=\\Phi^{P,m}_{a,u,n,k_{j}}$\\,,  $\\;\\; \\Psi^{F,m}_{b,u,n,j}=\\Psi^{P,m}_{b,u,n,k_{j}} \\;$ and $\\; X^{F,m}_{u,n,j}=X^{P,m}_{u,n,k_j}$ \\rule[-3mm]{0mm}{5mm}  \\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} If MARGINALIZE then\\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Psi^{F,m}_{b,\\nu,n,j}=\\Psi^{P,m}_{b,\\nu,n,j}$ for all $\\nu \\neq u$\\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} Else\\\\
\\hspace{6mm} \\hspace{6mm} \\hspace{6mm} \\hspace{6mm} $\\Psi^{F,m}_{b,\\nu,n,j}=\\Psi^{P,m}_{b,\\nu,n,k_j}$ for all $\\nu \\neq u$\\\\
\\hspace{6mm} \\hspace{6mm} End For \\\\ %%% end n loop
\\hspace{6mm} \\hspace{6mm}  $\\Phi^{m}_{a,u,j}=\\Phi^{F,m}_{a,u,N_{u},j}$ and
           $\\Psi^{m}_{b,u,j}=\\Psi^{F,m}_{b,u,N_{u},j}$
 \\\\
\\hspace{6mm} End For \\\\ %%% end u loop
\\hspace{6mm} $\\Phi^{m}_{a,j}=\\Phi^m_{a,U,j}$
\\\\
End For \\\\ %%% end m loop
\\end{tabular}
\\end{algorithm}
"
cat(texString)


## ----eval=knitr::is_html_output(), echo=FALSE, results='asis'-----------------
# cat("
#   \\[
#   \\begin{aligned}
#   &\\large{\\textbf{Algorithm 1: } \\text{Panel Iterated Filtering (PIF)}}\\\\
#   &\\texttt{mif2(pp, Nmif=m, Np=J, start=(}\\phi^0_{a},\\psi^0_{b,u}\\texttt{),}\\\\
#   &\\quad\\texttt{rw_sd=(}\\sigma^\\Phi_{a,n},\\sigma^\\Psi_{b,u,n})\\texttt{, cooling.fraction.50=}\\rho^{1/50}\\texttt{)} \\\\\\hline
#   &\\textbf{Input: }  \\begin{array}[t]{@{}l@{}}
#   \\text{Data: }  y_{u,n}^*, \\, u \\text{ in }  1:U, \\, n \\text{ in } 1:N\\\\
#   \\text{Simulator of initial density: }  f_{X_{u,0}}(x_{u,0}{\\,;\\,} \\phi,\\psi_{u}) \\\\
#   \\text{Simulator of transition density: } f_{X_{u,n}|X_{u,n-1}}(x_{u,n}\\,|\\, x_{u,n-1}{\\,;\\,} \\phi,\\psi_{u})\\\\
#   \\text{Measurement density: } f_{X_{u,n}|X_{u,n-1}}(x_{u,n}\\,|\\, x_{u,n-1}{\\,;\\,} \\phi,\\psi_{u})\\\\
#   \\text{Number of particles, } J \\text{, and number of iterations, } M. \\\\
#   \\text{Starting shared parameter swarmm, } \\Phi^0_{a,j}=\\phi^0_{a}, \\, a \\text{ in } 1:A, \\, j \\text{ in } 1:J \\\\
#   \\text{Starting unit-specific parameter swarm, } \\Psi^0_{b,u,j}=\\psi^0_{b,u}, \\, b \\text{ in }  1:B, \\, j \\text{ in } 1:J\\\\
#   \\text{Random walk intensities, } \\sigma^\\Phi_{a,n} \\text{ and } \\sigma^\\Psi_{b,u,n} \\\\
#   \\text{Parameter transformations, } h^{\\Phi}_{a} \\text{ and } h^{\\Psi}_{b}, \\text{ with inverses } \\big(h^{\\Phi}_{a}\\big)^{-1} \\text{ and } \\big(h^{\\Psi}_{b}\\big)^{-1}\\\\
#   \\text{Logical variable determining marginalization, } \\text{MARGINALIZE}
#   \\end{array} \\\\
#   &\\textbf{Output: }  \\begin{array}[t]{@{}l@{}}
#   \\text{Final parameter swarm, } \\Phi^M_{a,j}\\; \\text{ and } \\;\\Psi^M_{b,u,j}
#   \\end{array}\\\\\\hline
#   &\\textbf{For } m \\text{ in } 1:M \\\\
#   &\\quad \\Phi^m_{a,0,j}=\\Phi^{m-1}_{a,j} \\\\
#   &\\quad \\quad \\textbf{For } u \\text{ in } 1:U \\\\
#   &\\quad\\quad\\quad \\Phi^{F,m}_{a,u,0,j} =\\big(h^{\\Phi}_{a}\\big)^{-1} \\left(h^\\Phi_a \\big(\\Phi^{m}_{a,u-1,j}\\big)+\\rho^{m}\\sigma^{\\Phi}_{a,0} Z^{\\Phi,m}_{a,u,0,j}
#   \\right) \\text{ for } Z^{\\Phi,m}_{a,u,0,j}\\sim N[0,1]\\\\
#   &\\quad\\quad\\quad \\Psi^{F,m}_{b,u,0,j} =\\big(h^{\\Psi}_{b}\\big)^{-1} \\left(h^\\Psi_b \\big(\\Psi^{m-1}_{b,u,j}\\big)+ \\rho^{m}\\sigma^{\\Psi}_{b,u,0} Z^{\\Psi,m}_{b,u,0,j} \\right) \\text{ for } Z^{\\Psi,m}_{b,u,0,j}\\sim N[0,1] \\\\
#   &\\quad\\quad\\quad  X_{u,0,j}^{F,m}\\sim f_{X_{u,0}}\\left(x_{u,0} \\; \\big| \\; \\Phi^{F,m}_{a,u,0,j} ,\\Psi^{F,m}_{b,u,0,j}\\right) \\\\
#   &\\quad\\quad\\quad \\textbf{For } n \\text{ in } 1:N_u \\\\
#   &\\quad\\quad\\quad\\quad \\Phi^{P,m}_{a,u,n,j} =\\big(h^{\\Phi}_{a}\\big)^{-1} \\left( h^\\Phi_a \\big(\\Phi^{F,m}_{a,u,n-1,j}\\big)+ \\rho^{m}\\sigma^{\\Phi}_{a,n} Z^{\\Phi,m}_{a,u,n,j} \\right) \\text{ for } Z^{\\Phi,m}_{a,u,n,j}\\sim N[0,1] \\\\
#   &\\quad\\quad\\quad\\quad \\Psi^{P,m}_{b,u,n,j} =\\big(h^{\\Psi}_{b}\\big)^{-1} \\left(h^\\Psi_b \\big(\\Psi^{F,m}_{b,u,n-1,j}\\big)+\\rho^{m}\\sigma^{\\Psi}_{b,u,n} Z^{\\Psi,m}_{b,u,n,j}\\right) \\text{ for } Z^{\\Psi,m}_{b,u,n,j}\\sim N[0,1] \\\\
#   &\\quad\\quad\\quad\\quad X_{u,n,j}^{P,m}\\sim f_{X_{u,n}|X_{u,n-1}} \\left(x_{u,n} \\; \\big| \\; X^{F,m}_{u,n-1,j} \\; {\\,;\\,} \\; \\Phi^{P,m}_{a,u,n,j} \\, , \\Psi^{P,m}_{b,u,n,j} \\right)  \\\\
#   &\\quad\\quad\\quad\\quad w_{u,n,j}^m = f_{Y_{u,n}|X_{u,n}} \\left(y^*_{u,n} \\; \\big| \\; X_{u,n,j}^{P,m} \\; {\\,;\\,} \\;\\Phi^{P,m}_{a,u,n,j} \\, ,\\Psi^{P,m}_{b,u,n,j}\\right)  \\\\
#   &\\quad\\quad\\quad\\quad \\text{Draw } k_{1:J} \\text{ with }  \\mathbb{P}(k_j=i)=  w_{u,n,i}^m\\Big/\\sum_{q=1}^J w_{u,n,q}^m \\\\
#   &\\quad\\quad\\quad\\quad \\Phi^{F,m}_{a,u,n,j}=\\Phi^{P,m}_{a,u,n,k_{j}},  \\;\\; \\Psi^{F,m}_{b,u,n,j}=\\Psi^{P,m}_{b,u,n,k_{j}} \\; \\text{ and } \\; X^{F,m}_{u,n,j}=X^{P,m}_{u,n,k_j}  \\\\
#   &\\quad\\quad\\quad\\quad \\textbf{If} \\text{ MARGINALIZE } \\textbf{then} \\\\
#   &\\quad\\quad\\quad\\quad\\quad \\Psi^{F,m}_{b,\\nu,n,j}=\\Psi^{P,m}_{b,\\nu,n,j} \\; \\text{ for all } \\; \\nu \\neq u \\\\
#   &\\quad\\quad\\quad\\quad \\textbf{Else} \\\\
#   &\\quad\\quad\\quad\\quad\\quad \\Psi^{F,m}_{b,\\nu,n,j}=\\Psi^{P,m}_{b,\\nu,n,k_{j}} \\; \\text{ for all } \\; \\nu \\neq u \\\\
#   &\\quad\\quad\\quad \\textbf{End For}\\\\
#   &\\quad\\quad\\quad \\Phi^{m}_{a,u,j}=\\Phi^{F,m}_{a,u,N_{u},j} \\text{ and } \\Psi^{m}_{b,u,j}=\\Psi^{F,m}_{b,u,N_{u},j} \\\\
#   &\\quad\\quad \\textbf{End For}\\\\
#   &\\quad\\quad \\Phi^{m}_{a,j}=\\Phi^m_{a,U,j}\\\\
#   &\\quad \\textbf{End For}\\\\\\hline
#   \\end{aligned}
#   \\]
#   ")


## ----gompTrans, echo=TRUE, eval=FALSE-----------------------------------------
# parameter_trans(log = c("K", "r", "sigma", "tau", "X.0"))


## ----gomp1Mif, eval=FALSE, echo=TRUE------------------------------------------
# gomp_mif2d <- mif2(
#   gomp,  # panelPomp model, which contains parameter transformations and values.
#   Nmif = 25,  # Number of Iterations (M)
#   Np = 250,  # Number of Particles (J)
#   cooling.fraction.50 = 0.5,  # Cooling intensity, after 50 iterations
#   cooling.type = "geometric",  # Cooling Style
#   rw.sd = rw_sd(r = 0.02, sigma = 0.02, tau = 0.02)  # Random Walk SD
# )


## ----gomp1Mif_eval, echo=FALSE, eval=TRUE-------------------------------------
stew(file=paste0(rda_dir,"gomp1mif.rda"), {
  gomp_mif2d <- mif2(
    gomp,  # panelPomp model, which contains parameter transformations and values.
    Nmif = 25,  # Number of Iterations (M)
    Np = 250,  # Number of Particles (J)
    cooling.fraction.50 = 0.5,  # Cooling intensity, after 50 iterations
    cooling.type = "geometric",  # Cooling Style
    rw.sd = rw_sd(r = 0.02, sigma = 0.02, tau = 0.02)  # Random Walk SD
  )
})
load(paste0(rda_dir,"gomp1mif.rda")) # to access system time
mif1_time <- .system.time


## ----sharedEst, echo=TRUE, eval=TRUE------------------------------------------
shared(gomp_mif2d)






## ----mifRL1, echo=run_level==1, eval=FALSE------------------------------------
# mif_results <- foreach(start=iter(starts,"row")) %dopar% {
#   mif2(
#     gomp, start = unlist(start),
#     Nmif = 25,
#     Np = 250,
#     cooling.fraction.50 = 0.5,
#     cooling.type = "geometric",
#     transform = TRUE,
#     rw.sd = rw_sd(r = 0.02, sigma = 0.02, tau = 0.02)
#   )
# }


## ----mifRL3, echo=run_level==3, eval=FALSE------------------------------------
# mif_results <- foreach(start=iter(starts,"row")) %dopar% {
#   mif2(
#     gomp, start = unlist(start),
#     Nmif = 150,
#     Np = 1500,
#     cooling.fraction.50 = 0.5,
#     cooling.type = "geometric",
#     transform = TRUE,
#     rw.sd = rw_sd(r = 0.02, sigma = 0.02, tau = 0.02)
#   )
# }


## ----mif_eval, echo=FALSE, eval=TRUE------------------------------------------
stew(file=paste0(rda_dir,"mif.rda"),{
  if (run_level == 1) {
mif_results <- foreach(start=iter(starts,"row")) %dopar% {
  mif2(
    gomp, start = unlist(start),
    Nmif = 25,
    Np = 250,
    cooling.fraction.50 = 0.5,
    cooling.type = "geometric",
    transform = TRUE,
    rw.sd = rw_sd(r = 0.02, sigma = 0.02, tau = 0.02)
  )
}
  } else if (run_level == 3) {
mif_results <- foreach(start=iter(starts,"row")) %dopar% {
  mif2(
    gomp, start = unlist(start),
    Nmif = 150,
    Np = 1500,
    cooling.fraction.50 = 0.5,
    cooling.type = "geometric",
    transform = TRUE,
    rw.sd = rw_sd(r = 0.02, sigma = 0.02, tau = 0.02)
  )
}
  }
})
load(file=paste0(rda_dir,"mif.rda"))
mif_time <- .system.time






## ----block_core, eval=FALSE, echo=TRUE----------------------------------------
# mif_block <- foreach(mf=mif_results) %dopar% {
#   mf@specific["tau",] <- sapply(1:length(mf), mif_unit, mifd_gomp = mf)
#   mf
# }


## ----block_eval, echo=FALSE, eval=TRUE----------------------------------------
stew(file=paste0(rda_dir,"block.rda"),{
mif_block <- foreach(mf=mif_results) %dopar% {
  mf@specific["tau",] <- sapply(1:length(mf), mif_unit, mifd_gomp = mf)
  mf
}
})
load(file=paste0(rda_dir,"block.rda"))
block_time <- .system.time


## ----profile_coreRL1, echo=run_level==1, eval=FALSE---------------------------
# # Names of the estimated parameters
# estimated <- c(
#   "r", "sigma", paste0("tau[unit", 1:length(gomp), "]")
# )
# 
# # Names of the fixed parameters (not estimated)
# fixed <- names(coef(gomp))[!names(coef(gomp)) %in% estimated]
# 
# profile_starts <- profile_design(
#   r = seq(0.05, 0.2, length = 8),
#   lower = c(coef(gomp)[estimated] / 2, coef(gomp)[fixed])[-1],
#   upper = c(coef(gomp)[estimated] * 2, coef(gomp)[fixed])[-1],
#   nprof = 2, type = "runif"
# )
# 
# profile_results <- foreach(start = iter(profile_starts, "row")) %dopar% {
#   mf <- mif2(
#     mif_results[[1]],
#     start = unlist(start),
#     rw.sd = rw_sd(sigma = 0.02, tau = 0.02)
#   )
#   mf@specific["tau", ] <- sapply(1:length(mf), mif_unit, mifd_gomp = mf)
#   mf
# }


## ----profile_coreRL3, echo=run_level==3, eval=FALSE---------------------------
# # Names of the estimated parameters
# estimated <- c(
#   "r", "sigma", paste0("tau[unit", 1:length(gomp), "]")
# )
# 
# # Names of the fixed parameters (not estimated)
# fixed <- names(coef(gomp))[!names(coef(gomp)) %in% estimated]
# 
# profile_starts <- profile_design(
#   r = seq(0.05, 0.2, length = 20),
#   lower = c(coef(gomp)[estimated] / 2, coef(gomp)[fixed])[-1],
#   upper = c(coef(gomp)[estimated] * 2, coef(gomp)[fixed])[-1],
#   nprof = 5, type = "runif"
# )
# 
# profile_results <- foreach(start = iter(profile_starts, "row")) %dopar% {
#   mf <- mif2(
#     mif_results[[1]],
#     start = unlist(start),
#     rw.sd = rw_sd(sigma = 0.02, tau = 0.02)
#   )
#   mf@specific["tau", ] <- sapply(1:length(mf), mif_unit, mifd_gomp = mf)
#   mf
# }


## ----profile_eval, echo=FALSE, eval=TRUE--------------------------------------
stew(file=paste0(rda_dir,"profile.rda"),{
  if (run_level == 1) {
# Names of the estimated parameters
estimated <- c(
  "r", "sigma", paste0("tau[unit", 1:length(gomp), "]")
)

# Names of the fixed parameters (not estimated)
fixed <- names(coef(gomp))[!names(coef(gomp)) %in% estimated]

profile_starts <- profile_design(
  r = seq(0.05, 0.2, length = 8),
  lower = c(coef(gomp)[estimated] / 2, coef(gomp)[fixed])[-1],
  upper = c(coef(gomp)[estimated] * 2, coef(gomp)[fixed])[-1],
  nprof = 2, type = "runif"
)

profile_results <- foreach(start = iter(profile_starts, "row")) %dopar% {
  mf <- mif2(
    mif_results[[1]],
    start = unlist(start),
    rw.sd = rw_sd(sigma = 0.02, tau = 0.02)
  )
  mf@specific["tau", ] <- sapply(1:length(mf), mif_unit, mifd_gomp = mf)
  mf
}
  } else if (run_level == 3) {
# Names of the estimated parameters
estimated <- c(
  "r", "sigma", paste0("tau[unit", 1:length(gomp), "]")
)

# Names of the fixed parameters (not estimated)
fixed <- names(coef(gomp))[!names(coef(gomp)) %in% estimated]

profile_starts <- profile_design(
  r = seq(0.05, 0.2, length = 20),
  lower = c(coef(gomp)[estimated] / 2, coef(gomp)[fixed])[-1],
  upper = c(coef(gomp)[estimated] * 2, coef(gomp)[fixed])[-1],
  nprof = 5, type = "runif"
)

profile_results <- foreach(start = iter(profile_starts, "row")) %dopar% {
  mf <- mif2(
    mif_results[[1]],
    start = unlist(start),
    rw.sd = rw_sd(sigma = 0.02, tau = 0.02)
  )
  mf@specific["tau", ] <- sapply(1:length(mf), mif_unit, mifd_gomp = mf)
  mf
}
  }
})
load(file=paste0(rda_dir,"profile.rda"))
profile_time <- .system.time


## ----profile_table_coreRL1, eval=FALSE, echo=run_level==1---------------------
# profile_table <- foreach(mf=profile_results,.combine=rbind) %dopar% {
#   LL <- replicate(2, logLik(pfilter(mf, Np = 50)))
#   LL <- logmeanexp(LL, se = TRUE)
#   data.frame(t(coef(mf)), loglik = LL[1], loglik.se = LL[2])
# }


## ----profile_table_coreRL3, eval=FALSE, echo=run_level==3---------------------
# profile_table <- foreach(mf=profile_results,.combine=rbind) %dopar% {
#   LL <- replicate(10, logLik(pfilter(mf, Np = 2500)))
#   LL <- logmeanexp(LL, se = TRUE)
#   data.frame(t(coef(mf)), loglik = LL[1], loglik.se = LL[2])
# }


## ----profile_table_eval, echo=FALSE, eval=TRUE--------------------------------
stew(file=paste0(rda_dir,"profile_table.rda"),{
  if (run_level == 1) {
profile_table <- foreach(mf=profile_results,.combine=rbind) %dopar% {
  LL <- replicate(2, logLik(pfilter(mf, Np = 50)))
  LL <- logmeanexp(LL, se = TRUE)
  data.frame(t(coef(mf)), loglik = LL[1], loglik.se = LL[2])
}
  } else if (run_level == 3) {
profile_table <- foreach(mf=profile_results,.combine=rbind) %dopar% {
  LL <- replicate(10, logLik(pfilter(mf, Np = 2500)))
  LL <- logmeanexp(LL, se = TRUE)
  data.frame(t(coef(mf)), loglik = LL[1], loglik.se = LL[2])
}
  }
})
load(file=paste0(rda_dir,"profile_table.rda"))
profile_table_time <- .system.time


## ----profile_kalman, echo=FALSE, eval=TRUE------------------------------------
profile_r <- unique(profile_starts[,"r"])
start_matrix <- matrix(coef(gomp),ncol=length(coef(gomp)),
  nrow=length(profile_r),byrow=T,dimnames=list(NULL,names(coef(gomp))))
start_matrix[,"r"] <- profile_r
estNames <- c("sigma",paste0("tau[unit",1:length(gomp),"]"))
stew(file=paste0(rda_dir,"profile_kalman.rda"),{
  exact_profile <- foreach(start=iter(start_matrix,"row")) %dopar% {
    x <- as.vector(start)
    names(x) <- colnames(start)
    optim(
      par=x[estNames],
      fn=panelGompertzLikelihood,
      panelPompObject=gomp,
      params=x,
      hessian=FALSE,
      control=list(trace=0,fnscale=-1)
    )
  }
})
load(file=paste0(rda_dir,"profile_kalman.rda"))
exact_profile_time <- .system.time
exact_profile_table <- cbind(r=profile_r,
  logLik=sapply(exact_profile,function(x) x$value))


## ----mcap, echo=TRUE, eval=TRUE-----------------------------------------------
profile_table <- profile_table |>
  as.data.frame() |>
  dplyr::group_by(r) |>
  dplyr::slice_max(n = 1, order_by = loglik)

gomp_mcap <- pomp::mcap(
  logLik = profile_table$loglik,
  parameter = profile_table$r,
  level = 0.95
)


## ----mcap-plot, echo=FALSE, fig.width=5.5,fig.height=3.2,fig.cap="The Monte Carlo adjusted profile confidence interval (solid red lines, evaluation points shown as circles). Construction using deterministic optimization of the likelihood calculated by the Kalman filter (dashed lines, evaluation points show as squares).",fig.align='center'----
gomp_mc <- data.frame('logLik' = gomp_mcap$logLik, 'parameter' = gomp_mcap$parameter,
                      'method' = 'pf')

optim_mcap <- pomp::mcap(
  logLik=exact_profile_table[,"logLik"],
  parameter=exact_profile_table[,"r"],
  level=0.95
)

kalm_mc <- data.frame('logLik' = optim_mcap$logLik, 'parameter' = optim_mcap$parameter,
                      'method' = 'kalman')

full_mc <- dplyr::bind_rows(gomp_mc, kalm_mc)

full_smooth <- dplyr::bind_rows(
  gomp_mcap$fit |> dplyr::mutate('method' = 'pf'),
  optim_mcap$fit |> dplyr::mutate('method' = 'kalman')
)

full_ci <- rbind(gomp_mcap$ci, optim_mcap$ci)
colnames(full_ci) <- c("low", "high")
full_ci <- as.data.frame(full_ci) |> dplyr::mutate(method = c("pf", "kalman"))

bounds <- data.frame(
  method = c('pf', 'kalman'),
  limit = c(
    max(gomp_mcap$fit$smoothed, na.rm = TRUE) - gomp_mcap$delta,
    max(optim_mcap$fit$smoothed, na.rm = TRUE) - optim_mcap$delta
    )
)

ggplot() +
  geom_point(
    data = full_mc,
    aes(x = parameter, y = logLik, shape = method, col = method)
  ) +
  geom_line(
    data = full_smooth,
    aes(x = parameter, y = smoothed, linetype = method, col = method)
  ) +
  geom_vline(
    data = full_ci,
    aes(xintercept = low, linetype = method, col = method)
  ) +
  geom_vline(
    data = full_ci,
    aes(xintercept = high, linetype = method, col = method)
  ) +
  geom_hline(
    data = bounds, aes(yintercept = limit, linetype = method, col = method)
  ) +
  theme_bw() +
  scale_color_manual(
    values = c("pf" = "red", "kalman" = "grey10"),
    labels = c("pf" = "PIF +\nParticle Filter", "kalman" = "Kalman\nFilter")
  ) +
  scale_linetype_manual(
    values = c("pf" = "solid", "kalman" = "dashed"),
    labels = c("pf" = "PIF +\nParticle Filter", "kalman" = "Kalman\nFilter")
  ) +
  scale_shape_manual(
    values = c("pf" = 1, "kalman" = 0),
    labels = c("pf" = "PIF +\nParticle Filter", "kalman" = "Kalman\nFilter")
  ) +
  theme(legend.title = element_blank(), legend.key.spacing.y = unit(15, 'pt'), legend.position = c(0.85, 0.75)) +
  ylab('Profile log-likelihood') +
  xlab('r')

