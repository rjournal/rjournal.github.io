---
title: 'rmonad: pipelines you can compute on'
abstract: The [rmonad](https://CRAN.R-project.org/package=rmonad) package presents
  a monadic pipeline toolset for chaining functions into stateful, branching pipelines.
  As functions in the pipeline are run, their results are merged into a graph of all
  past operations. The resulting structure allows downstream computation on node documentation,
  intermediate data, performance stats, and any raised messages, warnings or errors,
  as well as the final results. [rmonad](https://CRAN.R-project.org/package=rmonad)
  is a novel approach to designing reproducible, well-documented, and maintainable
  workflows in R.
author:
- name: Zebulun Arendsee
  affiliation: Iowa State University
  email: |
    zbwrnz@gmail.com
  address:
  - Ames IA, USA
  - https://orcid.org/0000-0002-5833-798X
- name: Jennifer Chang
  affiliation: Iowa State University
  email: |
    jennifer.chang.bioinform@gmail.com
  address:
  - Ames IA, USA
  - https://orcid.org/0000-0002-8381-3765
- name: Eve Wurtele
  affiliation: Iowa State University
  email: |
    eve@iastate.edu
  address:
  - Ames IA, USA
  - https://orcid.org/0000-0003-1552-9495
date: '2022-06-21'
date_received: '2020-04-04'
journal:
  firstpage: 22
  lastpage: 33
volume: 14
issue: 1
slug: RJ-2022-007
packages:
  cran: ~
  bioc: ~
preview: preview.png
bibliography: rmonad.bib
CTV: ~
output:
  rjtools::rjournal_article:
    self_contained: no
    toc: no
    legacy_pdf: yes
draft: no

---














# Background

Pipeline programming is common practice in the R community, with
[magrittr](https://CRAN.R-project.org/package=magrittr),
[pipeR](https://CRAN.R-project.org/package=pipeR), and
[wrapr](https://CRAN.R-project.org/package=wrapr) packages offering
infix pipe operators [@magrittr2014; @pipeR2016; @mount2018dot]. The
value on the left of the pipe operator is passed as the first argument
to the right-hand function. This style of programming simplifies code by
removing the need to name intermediate values or write deeply nested
function calls. For example, using the
[magrittr](https://CRAN.R-project.org/package=magrittr) pipe operator,
%\>%, the expression x %\>% f %\>% g is equivalent to g(f(x)). These
pipelines are equivalent to applied function compositions and termed
function *composition* pipelines.

A *monadic* [@wadler1990comprehending] pipeline extends composition
pipelines by allowing *context* to be threaded through the pipeline.
Each function call in the pipeline produces both a new value (assuming
successful evaluation) and a computational context surrounding that new
value. This new value and context is then merged with the context of the
prior node in the pipeline, allowing past context to be stored. In this
way, monadic pipelines can be automatically self-describing by returning
both the result and a description of the process that created it.

In this paper, we present
[rmonad](https://CRAN.R-project.org/package=rmonad), the first
explicitly monadic pipeline program developed for the R language.
[rmonad](https://CRAN.R-project.org/package=rmonad) captures the history
of a pipeline as a graph of all past operations. Each node in the graph
represents either an input or a function. These nodes store the source
code, documentation, any raised messages/warnings/errors, benchmarking
info, and arbitrary additional metadata.
[rmonad](https://CRAN.R-project.org/package=rmonad) also generalizes the
standard linear pipeline to a directed graph with support for branching
and looping pipelines.

[rmonad](https://CRAN.R-project.org/package=rmonad) is one of many
graph-based workflow tools available to R programmers. The
[drake](https://CRAN.R-project.org/package=drake) package [@drake]
allows specification of R workflows using Make-family semantics
[@stallman2002gnu]. The R packages
[tidycwl](https://CRAN.R-project.org/package=tidycwl) [@tidycwl2020] and
[sevenbridges](https://CRAN.R-project.org/package=sevenbridges)
[@sevenbridges2020] wrap the Common Workflow Language which allows
specification of DAG-based workflows that can be easily run on
high-performance platforms. Many build systems allow execution of R code
snippets, such as Snakemake [@koster2012snakemake], Nextflow
[@di2017nextflow] and Cuneiform [@brandt2017computation]. Like these
programs, [rmonad](https://CRAN.R-project.org/package=rmonad) specifies
a graph of dependent operations and can handle large, complex projects.
However, [rmonad](https://CRAN.R-project.org/package=rmonad) offers a
lighter solution, with no dependencies outside R. In the simplest case,
[rmonad](https://CRAN.R-project.org/package=rmonad) has no more
syntactic complexity than a composition pipeline like
[magrittr](https://CRAN.R-project.org/package=magrittr).

Since [rmonad](https://CRAN.R-project.org/package=rmonad) can annotate
and summarize intermediate data, it can serve as a provenance tracking
tool. Provenance tracking of data generated through a pipeline is
critical for research reproducibility [@Gentleman2007StatisticalAA]. For
example, the provenance manager VisTrails builds directed acyclic graphs
(DAG) of workflows and stores intermediate data objects as external XML
files in an external database [@Silva2010ProvenanceEnabledDE]. It also
provides a visualization of the workflow (or provenance trail) as it is
being run. By visualizing the workflow in a DAG-like structure, the user
can perform exploratory analysis and retooling on the fly. The R
provenance tracking packages
[archivist](https://CRAN.R-project.org/package=archivist)
[@przemyslaw2017archivist],
[trackr](https://CRAN.R-project.org/package=trackr) [@becker2019trackr],
and [adapr](https://CRAN.R-project.org/package=adapr) [@Gelfond2018ASF]
store manual annotations (metadata) of data objects as hooks to an
external binary or JSON database.

In the following sections, we introduce the
[rmonad](https://CRAN.R-project.org/package=rmonad) monadic pipeline
operator, show how [rmonad](https://CRAN.R-project.org/package=rmonad)
generalizes linear pipelines to support branching and nesting, describe
how [rmonad](https://CRAN.R-project.org/package=rmonad) evaluation
allows pipeline debugging and annotation, tie these ideas together with
a case study, and provide an overview of the application of
[rmonad](https://CRAN.R-project.org/package=rmonad) to a large-scale
project.

# The monadic pipe operator

A pipeline consists of a series of expressions that are evaluated using
upstream data as input. The context that is passed through an
[rmonad](https://CRAN.R-project.org/package=rmonad) pipeline is stored
as an "Rmonad" S4 object. This object consists of a directed graph of
the relationships between nodes in the pipelines, a list containing the
information about each node (including the output if it is cached), and
a unique identifier for the *head* node---the node whose output will be
passed to the next operation in the pipeline. Each expression in the
pipeline is evaluated by the special
[rmonad](https://CRAN.R-project.org/package=rmonad) function, evalwrap,
that takes an R expression and returns an "Rmonad" object. After each
new expression in a pipeline is evaluated, the past "Rmonad" object is
merged with the new one (see Algorithm
[\[alg:eval\]](#alg:eval){reference-type="ref" reference="alg:eval"}).

::: algorithm
:::

The [rmonad](https://CRAN.R-project.org/package=rmonad) function
evalwrap evaluates an R expression and returns an "Rmonad" object. The
*type signature* of evalwrap is:

$$\text{evalwrap} :: R \rightarrow M\ a$$

The evalwrap function takes the R expression, $R$, and returns $M\ a$,
which is the "Rmonad" object $M$ wrapping the value returned from the
evaluation of $R$. On success, the returned value has type $a$. Thus,
whereas a composition pipeline would consist of chained functions of
type $a \rightarrow
b$, $b \rightarrow c$, $c \rightarrow d$, etc, an
[rmonad](https://CRAN.R-project.org/package=rmonad) pipeline consists of
$a \rightarrow M\ b$, $b \rightarrow M\ c$, $c \rightarrow M\ d$.

Each evaluation step in an
[rmonad](https://CRAN.R-project.org/package=rmonad) pipeline creates a
contextualized object. However, including the context in the output
causes a type conflict. For example, suppose there are functions $f$ and
$g$ with types ($a \rightarrow
M\ b$) and ($b \rightarrow M\ c$), respectively. Function $f$ produces
an output of type $M\ b$, but function $g$ requires an input of type
$b$. This conflict is resolved through the special evaluation performed
within the monadic pipe operator.

The monadic pipe operator, or the *bind* operator, has the type
signature [@wadler1990comprehending]:

$$bind\ ::
  \underbrace{m\ b}_{\text{output of $f$}} \rightarrow
  \underbrace{(b \rightarrow m\ c)}_{\text{the function $g$}} \rightarrow
  \underbrace{m\ c}_{\text{output of $g$}}$$

where $m$ is a generic monad. The function bind takes an input of type
$m\ b$ and the function $g$ of type ($b \rightarrow m\ c$). It returns
the output of $g$ which has type $m\ c$. Many functions of the general
type $a
\rightarrow m\ b$ can be chained together using this bind function. For
example, the call bind(bind(f(x), g),h) would chain the contextualized
results of $f$ through $g$ and then $h$. The implementation of the bind
function defines how context from $m\ b$ is passed through the monadic
chain to $m\ c$.

The simplest possible implementation of the bind function passes no
state and is identical to applied functional composition (e.g., as done
in [magrittr](https://CRAN.R-project.org/package=magrittr)):

::: algorithm
:::

The monadic pipeline operator of
[rmonad](https://CRAN.R-project.org/package=rmonad), %\>\>%, has the
type signature:

$$\underbrace{M\ a}_{lhs} \rightarrow \underbrace{(a \rightarrow \ b)}_{rhs} \rightarrow \underbrace{M\ b}_{output}$$

%\>\>% is a binary operator where the left hand side ( lhs) is an
"Rmonad" object ($M$) wrapping a value of type $a$. The right hand side
( rhs) is a normal R function that takes an input of type $a$ and, if
successful, returns a value of type $b$. If lhs stores a failing state
(i.e., a prior node in the pipeline raised an error), then the rhs
function is not evaluated and the failed state is propagated. Otherwise,
the value is extracted from lhs and evalwrap then evaluates the rhs
function with the lhs value as its first argument yielding a new
"Rmonad" object. Finally, this new object is merged with the prior, lhs
"Rmonad" object. Merging involves joining the node graphs of the old and
new "Rmonad" objects, setting the head of the resulting graph to the
head of the new graph, and removing the value stored in the prior head
(see Algorithm [\[alg:bind\]](#alg:bind){reference-type="ref"
reference="alg:bind"}). The "head" of a graph is critical for branching
pipelines (see the Branching and Nesting section).

::: algorithm
:::

The difference between %\>\>% and a true monadic bind operator is that
the rhs of a monadic bind operator is a function ($a \rightarrow M\
b$), whereas the rhs of %\>\>% is a normal R function. The %\>\>%
operator essentially transforms the rhs R function into a function that
yields the monadic object. This is carried out within the monadic bind
function through the special evaluation offered by evalwrap.

While the primary [rmonad](https://CRAN.R-project.org/package=rmonad)
operator is the monadic pipe operator, %\>\>%, several additional
operators are provided for operating on "Rmonad" objects using pipeline
syntax (listed in Table [1](#tab:operators){reference-type="ref"
reference="tab:operators"}).

::: {#tab:operators}
  Operator   Description
  ---------- ---------------------------------------------------
  %\>\>%     pass lhs as initial argument of rhs function
  %v\>%      like %\>\>% but caches the lhs value
  %\*\>%     pass list of arguments from lhs to rhs
  %\_\_%     rhs starts a new chain that preserves lhs history
  %\|\|%     use rhs value if lhs is failing
  %\|\>%     call rhs on lhs if lhs failed

  : A partial list of the supported operators. lhs and rhs refer to the
  left-hand and right-hand sides of the given binary operator. %\>\>% is
  the primary monadic chain operator. %v\>% is a variant of the monadic
  chain operator that always caches its input even on a successful run.
  The %\*\>% operator takes a list of "Rmonad" objects on the left and
  feeds the values of each as arguments into the function on the right,
  linking the history of each input "Rmonad" object to the final
  "Rmonad" object. This operator is important in building branching
  pipelines. The %\_\_% operator is like a semicolon in a programming
  language, separating independent pipelines but passing on context. The
  %\|\|% and %\|\>%, operators are used in error recovery.
:::

The %\>\>% operator by itself can only create linear chains of
operations. Mechanisms for lifting this limitation are introduced in the
next section.

# Branching and Nesting

In a linear pipeline, the output of each internal function is piped to
just one downstream function. In contrast,
[rmonad](https://CRAN.R-project.org/package=rmonad) allows branching to
be formed in one of two main ways: 1) the pipeline's head may be reset
to an internal node and the pipeline can continue growing from there or
2) multiple pipelines may be merged.

The first branching method uses the tag function to attach a label to
the current head node and the view function to change the head node to a
previously tagged node. An example of a branched pipeline using these
function is shown in Figure
[\[fig:rmonad-branch\]](#fig:rmonad-branch){reference-type="ref"
reference="fig:rmonad-branch"}. A node may be associated with one or
more tags.

The second branching method allows multiple pipelines to merged into
one. The most direct merge method uses the %\*\>% operator to pass the
head value from each "Rmonad" object in the left-hand side list as
arguments to the right-hand side function.
[rmonad](https://CRAN.R-project.org/package=rmonad) also offers a
dedicated loop function that takes an "Rmonad" object containing a list
of values, passes each into monadic function, and connects the histories
and final results of each pipeline into a new "Rmonad" node.

The example below demonstrates a loop where nodes where individual
elements are dynamically tagged for later access:

The elements of the first argument to the loop function (the letters
'a', 'b', and 'c') are passed to loop's second argument. The second
argument is an anonymous function that adds an exclamation mark to the
input and tags the resulting value. The tags are hierarchical, thus
get_value(m, tag=\"letters\") returns all values with the initial tag
'letters'. Specific values can be accessed like files in a path (e.g.,
\"letters/b\").

Since [rmonad](https://CRAN.R-project.org/package=rmonad) pipelines are
branched, there is in general no single output value of the pipeline.
Rather, the data contained in the "Rmonad" object is queried using a
family of vectorized getter functions. For example, get_value will
return a list containing the value stored in each node (or NULL if no
value is stored); get_error returns a list of all error messages,
get_warning returns a list of all warnings, get_code returns a list of
all code strings, etc. The code below fails on the 'sqrt' call and the
failing node can be found by searching for code blocks that were not
successfully executed.

::: example
m \<- \"a\" get_code(m)\[!get_OK(m)\] #\> \[\[1\]\] #\> \[1\] \"sqrt\"
:::

+--------------------------------------------------:+
| ::: example                                       |
| \"x\" paste(\"b\") log                            |
| :::                                               |
+---------------------------------------------------+
| ![image](Images/rmonad_unbranch.pdf){width="50%"} |
+---------------------------------------------------+
| ::: example                                       |
| \"x\" paste(\"b\") log paste(\"c\")               |
| :::                                               |
+---------------------------------------------------+
| ![image](Images/rmonad_branch.pdf){width="50%"}   |
+---------------------------------------------------+

In addition to branching,
[rmonad](https://CRAN.R-project.org/package=rmonad) allows complex
pipelines to be built from smaller nested pipelines defined in normal R
functions (see Figure
[\[fig:rmonad-nest\]](#fig:rmonad-nest){reference-type="ref"
reference="fig:rmonad-nest"}). When data is piped into a function that
wraps a nested [rmonad](https://CRAN.R-project.org/package=rmonad)
pipeline, the input values will be linked to the nodes in the nested
pipeline that use the input. In this way,
[rmonad](https://CRAN.R-project.org/package=rmonad) enables multilevel
debugging. Storing the input to each failed function at each nest level
allows a programmer to step through the code in the failed node using
the input data, without having to rerun the entire pipeline.

+-----------------------------------------------------:+
| ::: example                                          |
| \# Level 2 f \<- function(x) \"\<\" \# Level 1 \"A\" |
| :::                                                  |
+------------------------------------------------------+
| ![image](Images/rmonad_nest.pdf){width="70%"}        |
+------------------------------------------------------+

# Evaluation: error handling, metadata, and post-processing

In this section, we expound on how errors are handled in
[rmonad](https://CRAN.R-project.org/package=rmonad), how nodes are
documented and annotated, and how post-processing functionality is added
to specify log messages, summarize node output and clean up raised
messages.

## Exception handling and tracebacks

The core functionality of
[rmonad](https://CRAN.R-project.org/package=rmonad) is the stateful data
piping provided by the monadic operator %\>\>%. Linear chains of
operations can be constructed with this operator, where each successful
node stores information about the function and results. In the case of
an error, [rmonad](https://CRAN.R-project.org/package=rmonad) provides
access to the traceback and to the inputs to each failing function.
Knowing the error messages and the function inputs allows the programmer
to step through the failed function and easily diagnose the problem. All
information is stored within the "Rmonad" object, rather than in the
ephemeral state of an R session.

Here is a concrete example:

::: example
m \<- \"a cat\" get_error(m) #\> \[\[1\]\] #\> character(0) #\> #\>
\[\[2\]\] #\> \[1\] \"non-numeric argument to mathematical function\"
get_code(m)\[\[2\]\] #\> \"log\" get_value(m)\[\[2\]\] #\> \[1\] \"a
cat\"
:::

Here an illegal value is passed into the natural log function.
[rmonad](https://CRAN.R-project.org/package=rmonad) catches this error
and saves the first failing input and error message. The node index and
error message of the failing function can be found with get_error(m),
the failing expression can be accessed with get_code, and the inputs to
the failing function can be retrieved with get_value. This approach
scales cleanly to large and deeply nested pipelines.

## Parsing code strings, docstrings and metadata lists

[rmonad](https://CRAN.R-project.org/package=rmonad) leverages R
non-standard evaluation to parse the abstract syntax tree of pipeline
functions at runtime, prior to evaluation of the functions.
[rmonad](https://CRAN.R-project.org/package=rmonad) extracts 1) the
function's code as a string, 2) an optional documentation string, and 3)
an optional list of metadata. All three items are stored in the "Rmonad"
node. For example:

::: example
foo \<- function(x) \"This is a docstring\" list(sysinfo =
sessionInfo()) return(x)
:::

The first two lines in the function body are the docstring and metadata
list, respectively. Each must 1) be of the appropriate type (string and
list, respectively), 2) not be assigned to a variable, and 3) not be the
final line in the function body. Thus foo is a legal R function that can
be used naturally outside of the
[rmonad](https://CRAN.R-project.org/package=rmonad) context. The
docstring and metadata would be "dead" lines of code that are evaluated
but that are not assigned to any variable or returned. When
[rmonad](https://CRAN.R-project.org/package=rmonad) parses the function
before evaluation, the first two lines will be removed and stored,
yielding the following function for evaluation:

::: example
function(x) return(x)
:::

The docstring and the function code are stored as simple strings. The
metadata list is evaluated within the function environment, giving it
access to function input, and then stored.

The metadata is any list associated with a node. It can be used to store
static data such as the author's name, a version for the function,
arbitrary notes. It can also store report generation parameters (like
code chunks in [knitr](https://CRAN.R-project.org/package=knitr))
[@knitr]. Because the list is evaluated, its contents are dynamic,
allowing, for example, session info to be stored or
[knitr](https://CRAN.R-project.org/package=knitr) parameters to be a
function of the input. Whereas
[knitr](https://CRAN.R-project.org/package=knitr) nests code chunks and
their parameters in a text document,
[rmonad](https://CRAN.R-project.org/package=rmonad) nests text and
parameters within the code.

The metadata can be modified freely even *after* the pipeline is run, to
enable the user to store notes that are a function of the pipeline
results, as well as personal annotations, reminders, or comments on the
results.

## Post-processing functions: formatting, summarizing, and logging

A built-in use of the metadata is to add formatters, summarizers, and
loggers, which are executed automatically after a node is run. For
example, a pipeline developer might write the following wrapper around a
base 10 log function:

::: example
fancy_log10 \<- function(x) list( format_warnings = function(x, xs)
sprintf(\" , format_log = function(x, passing) if(passing) cat(\"pass\")
else cat(\"fail\") , summarize = list(len = length) ) log10(x)
:::

When run, the captured warnings are processed by format_warnings and log
messages by format_log, with the following result:

In the first case, an illegal value is passed to the fancy_log10
function. This leads to a failure in the second node, and the logger
prints "fail". In the second case, the user passes the integers between
-2 and 2, storing the result in m. Since these are legal values (from
R's perspective), the logger prints the message "pass" after evaluation.
When the returned object is printed, the post-processed warning message
"2 NaNs produced" is shown. The result of the summarizing function is
accessed through the get_summary function.

# Case Study: the Iris data

As an example of a simple branching
[rmonad](https://CRAN.R-project.org/package=rmonad) pipeline with error,
warning and run time handling we analyzed the Iris dataset
[@anderson1936species; @fisher1936use]. The Iris dataset is often used
for case studies of statistics and machine learning workflows, and
consists of features of three species of flowers: *Iris setosa*,
*Iris virginia*, and *Iris versicolor*. Among these features is petal
length. We used three statistical methods, (1) ANOVA, (2)
Kruskal-Wallis, and (3) t-test, to determine if petal length is
significantly different across the three *Iris* species. Some
statistical methods are not appropriate for this dataset without data
pre-processing. This case study provides an example of running multiple
methods using a branching
[rmonad](https://CRAN.R-project.org/package=rmonad) pipeline, while
comparing the output and running times of each method.

Normally, a programmer would run the three methods separately using an R
script similar to the following:

::: example
\# === Load data data(iris)

\# === 3 Statistical Tests (run one at a time) \# (1) Anova res.aov \<-
aov(Petal.Length   Species, data = iris) summary(res.aov)

\# (2) Kruskal-Wallis res.kr \<- kruskal.test(Petal.Length   Species,
data = iris) res.kr

\# (3) T-Test t.test(Petal.Length Species, data=iris)
:::

Using [rmonad](https://CRAN.R-project.org/package=rmonad) tags, data can
be branched out to encompass the three statistical tests. Here, the R
variable $m$ stores the output "Rmonad" S4 object. We must initially tag
the branch point node (in this case, the original Iris dataset). Since
we gave the first node the tag ("indata"), its value will be cached and
can be accessed with the command get_value(m, tag=\"indata\"). From
here, we can access and pipe ( %\>\>%) the viewed "indata" tag into the
different statistical tests, as scripted below and visualized in
**Figure 3**.

The above code could have been chained together using %\>%
get_value(tag=\"indata\") %\>% commands, but instead was separately
added to the $m$ rmonad object for ease of reading. From the $m$ rmonad
objects, we can plot the pipeline. In the following command we label the
nodes by node id, documentation, running time, and any errors if they
exists.

::: example
plot(m, label = function(m)paste(get_id(m), get_doc(m), get_time(m),
gsub(\"character\
(0\
)\", \"\", get_error(m)), sep=\":\"))
:::

![Using [rmonad](https://CRAN.R-project.org/package=rmonad) for three
statistical tests. The Iris dataset is piped to (1) ANOVA, (2)
Kruskul-Wallis, and (3) t-test. Node color reflects whether the test ran
(green) or threw an error (red). Time in seconds is shown next to the
test name. Errors are annotated on the node. Notice how t-test has the
error: \"grouping factor must have exactly 2 levels\". Of the two tests
without errors, ANOVA ran slightly slower than
Kruskal-Wallis.](Images/rmonad_threetests.png){#fig:rmonad-irispipeline
width="60%"}

In Figure [1](#fig:rmonad-irispipeline){reference-type="ref"
reference="fig:rmonad-irispipeline"}, the center node is the iris
dataset and has three arrows going outwards toward one red and two green
nodes. Of those, the red node near the top represents the t-test and
shows the expected error "grouping factor must have exactly 2 levels".
Since we are testing the petal length among the three species, this
error is expected. Any errors of the pipeline can also be obtained in a
table:

::: example
missues(m) #\> id type issue #\> 1 4 error grouping factor must have
exactly 2 levels
:::

Going clockwise, ANOVA and Kruskal-Wallis are represented by nodes 2 and
3. The green nodes indicate that both ran although their running times
were different. From their node labels, Kruskal-Wallis ran in 0.001 ms,
slightly faster than ANOVA (0.002). Also note that green nodes only
indicate that the method ran successfully, not the results of that
method or statistical significance. The results of the ANOVA and
Kruskal-Wallis test can be pulled out of the pipeline using their Node
ID number and the following commands.

::: example
\> id=c(2,3) \# place id(s) of end result(s) here \> get_value(m)\[id\]
#\> \[\[1\]\] #\> Df Sum Sq Mean Sq F value Pr(\>F) #\> Species 2 437.1
218.55 1180 \<2e-16 \*\*\* #\> Residuals 147 27.2 0.19 #\> --- #\>
Signif. codes: 0 '\*\*\*' 0.001 '\*\*' 0.01 '\*' 0.05 '.' 0.1 ' ' 1 #\>
#\> \[\[2\]\] #\> Kruskal-Wallis rank sum test #\> #\> data:
Petal.Length by Species #\> Kruskal-Wallis chi-squared = 130.41, df = 2,
p-value \< 2.2e-16
:::

Both tests agree that there is a significant difference between
Petal.Length across the three Iris species. ANOVA ran on the dataset,
which means that petal length follows a normal distribution within each
species. Kruskal-Wallis does not assume a normal distribution. The
analyst can decide which method to use; in this case the conclusion is
the same. Figure [1](#fig:rmonad-irispipeline){reference-type="ref"
reference="fig:rmonad-irispipeline"} is an example of a branched
[rmonad](https://CRAN.R-project.org/package=rmonad) pipeline comparing
three different statistical methods applied to the iris dataset to test
a hypothesis.

# [rmonad](https://CRAN.R-project.org/package=rmonad) in the wild: a comparative genomics case study

An example of a large and complex pipeline that uses
[rmonad](https://CRAN.R-project.org/package=rmonad) is the orphan gene
classification R pipeline, `fagin` [@arendsee2019fagin] (Figure
[2](#fig:rmonad-fagin){reference-type="ref"
reference="fig:rmonad-fagin"}). This pipeline compares genes from one
species of interest (the focal species) to genomes of several related
species. The first step in the pipeline is to store the user's session
information, which can be used in debugging if needed. Next, the
pipeline loops across each species, where, for each species, genomes and
annotation data are loaded and validated. Then secondary data (e.g.,
protein sequences) are derived, and diagnostic summaries are produced
and stored. Next, each of the orphan genes in the focal species is
compared to each of the related species genomes to create 12 features
that are used to classify potential evolutionary relatives of each the
focal gene in the target species. Finally, all data for each focal gene
is compiled into a description.

The output of this pipeline is a single "Rmonad" object. Further
analysis of the pipeline entails a series of queries against this
returned object. Warnings and messages are tabulated into an HTML
report. Tagged summary data is extracted and used to build diagnostic
figures. The primary results are extracted as tabular data and
visualized in the final report. Issues with a pipeline can be identified
by searching through the raised warnings stored in the "Rmonad" object.
Debugging consists of identifying the node of failure, extracting the
stored inputs to the failing node, and then stepping through the failing
code.

![[rmonad](https://CRAN.R-project.org/package=rmonad) can handle large
projects. Here, [rmonad](https://CRAN.R-project.org/package=rmonad)
analysis of the `fagin` pipeline is shown. Green nodes represent
passing; orange nodes raise warnings. The four symmetric subtrees on the
right represent a loop that loads and validates the input data for four
plant species. The two sets of three symmetric subtrees on the left are
loops comparing each of the four species (*A. thaliana*) to the other
three.](Images/rmonad_fagin.png){#fig:rmonad-fagin width="80%"}

# Conclusion

We implemented a monadic pipeline in R via the
[rmonad](https://CRAN.R-project.org/package=rmonad) package.
[rmonad](https://CRAN.R-project.org/package=rmonad) provides an
infrastructure for data analysis and report generation.
[rmonad](https://CRAN.R-project.org/package=rmonad) stores pipeline
results and metadata that can be easily explored interactively and
collated into reports using tools such as the literate programming
package [knitr](https://CRAN.R-project.org/package=knitr) [@knitr] or
the HTML report generator
[Nozzle.R1](https://CRAN.R-project.org/package=Nozzle.R1)
[@gehlenborg2013nozzle].

[rmonad](https://CRAN.R-project.org/package=rmonad) integrates a simple
profiler into the workflows by automatically capturing the runtime and
memory usage of each node. This feature makes it easier for the pipeline
developer to identify bottlenecks in the code or potential culprits of
memory overflow. Often, a coder must add benchmarking code to key
locations in a pipeline.
[rmonad](https://CRAN.R-project.org/package=rmonad) has *built-in*
benchmarking, such that all locations in the pipeline are automatically
tested and performance can be checked post-run.

[rmonad](https://CRAN.R-project.org/package=rmonad) provides a powerful
tool for creating and resolving issue reports. If an
[rmonad](https://CRAN.R-project.org/package=rmonad) pipeline fails, the
resulting object will store all failing functions, their raised
error/warning messages and also their inputs. This object can be used to
find the error messages, load all inputs to the failing function, and
proceed to step through the code until the bug is found. If the user
prepends a node that stores the local session data (e.g., sessionInfo()
%\_\_% \...), the debugger gains access to the state of the user's
machine (an often-requested item in a bug report). An "Rmonad" object
with session info attached contains everything needed to debug the
issue. This streamlines issue resolution by improving automation and
simplifying submission.

Performance has not been a focus of
[rmonad](https://CRAN.R-project.org/package=rmonad) up to this point.
The package currently lacks support for the re-use of cached values when
pipelines are re-run. Also each evaluation step has a high overhead cost
relative to lighter pipeline tools like
[magrittr](https://CRAN.R-project.org/package=magrittr).
[rmonad](https://CRAN.R-project.org/package=rmonad) pipelines tend to be
memory intensive, since they store many intermediate results and
metadata in the "Rmonad" objects. Addressing these performance issues is
a major goal for future work.

In summary, [rmonad](https://CRAN.R-project.org/package=rmonad)
integrates the concepts of a pipeline, a build system, a data structure,
and an low-level report-generating engine. An
[rmonad](https://CRAN.R-project.org/package=rmonad) project consists of
incremental piped operations (like a pipeline program), supports complex
branching projects (like a build system), and produces a data structure
that can be computed on to generate dynamic reports.

# Availability

[rmonad](https://CRAN.R-project.org/package=rmonad) is published under
the GPL-3 license and is available on the Comprehensive R Archive
Network (CRAN) and on GitHub at <https://github.com/arendsee/rmonad>.
Systematic documentation of the features with simple examples can be
found in the vignettes, available through CRAN.

# Funding

This material is based upon work supported by the National Science
Foundation under Grant No. IOS 1546858.
