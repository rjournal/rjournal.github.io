<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/>
  <meta name="generator" content="distill" />

  <style type="text/css">
  /* Hide doc at startup (prevent jankiness while JS renders/transforms) */
  body {
    visibility: hidden;
  }
  </style>

 <!--radix_placeholder_import_source-->
 <!--/radix_placeholder_import_source-->

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { color: #00769e; background-color: #f1f3f5; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { color: #00769e; } /* Normal */
code span.al { color: #ad0000; } /* Alert */
code span.an { color: #5e5e5e; } /* Annotation */
code span.at { color: #657422; } /* Attribute */
code span.bn { color: #ad0000; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #00769e; } /* ControlFlow */
code span.ch { color: #20794d; } /* Char */
code span.cn { color: #8f5902; } /* Constant */
code span.co { color: #5e5e5e; } /* Comment */
code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
code span.dt { color: #ad0000; } /* DataType */
code span.dv { color: #ad0000; } /* DecVal */
code span.er { color: #ad0000; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #ad0000; } /* Float */
code span.fu { color: #4758ab; } /* Function */
code span.im { } /* Import */
code span.in { color: #5e5e5e; } /* Information */
code span.kw { color: #00769e; } /* Keyword */
code span.op { color: #5e5e5e; } /* Operator */
code span.ot { color: #00769e; } /* Other */
code span.pp { color: #ad0000; } /* Preprocessor */
code span.sc { color: #5e5e5e; } /* SpecialChar */
code span.ss { color: #20794d; } /* SpecialString */
code span.st { color: #20794d; } /* String */
code span.va { color: #111111; } /* Variable */
code span.vs { color: #20794d; } /* VerbatimString */
code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
</style>

<style>
  div.csl-bib-body { }
  div.csl-entry {
    clear: both;
      margin-bottom: 0em;
    }
  .hanging div.csl-entry {
    margin-left:2em;
    text-indent:-2em;
  }
  div.csl-left-margin {
    min-width:2em;
    float:left;
  }
  div.csl-right-inline {
    margin-left:2em;
    padding-left:1em;
  }
  div.csl-indent {
    margin-left: 2em;
  }
</style>

  <!--radix_placeholder_meta_tags-->
  <title>spheresmooth: An R Package for Penalized Piecewise Geodesic Curve Fitting on a Sphere</title>

  <meta property="description" itemprop="description" content="This paper introduces an R package \CRANpkg{spheresmooth}, which implements a penalized piecewise geodesic curve fitting method on a sphere. Spherical data observed over a continuum arise frequently in various fields including cardiology, computer vision, physiology, and geophysics. We propose an adaptive smoothing method by extending the linear spline approach to spherical data. Penalization based on differences of velocity vectors endows sparsity among control points of the spherical curve, which enables data-adaptive curve fitting. The proposed method is implemented with a Riemannian block coordinate descent algorithm. Illustrations on Triassic and Jurassic polar wander data and tropical cyclone data demonstrate practicality of the proposed method and the associated \CRANpkg{spheresmooth} package."/>

  <link rel="license" href="https://creativecommons.org/licenses/by/4.0/"/>

  <!--  https://schema.org/Article -->
  <meta property="article:published" itemprop="datePublished" content="2025-08-07"/>
  <meta property="article:created" itemprop="dateCreated" content="2025-08-07"/>
  <meta name="article:author" content="Jae-Hwan Jhong"/>
  <meta name="article:author" content="Seyoung Lee"/>
  <meta name="article:author" content="Ja-Yong Koo"/>
  <meta name="article:author" content="Kwan-Young Bak"/>

  <!--  https://developers.facebook.com/docs/sharing/webmasters#markup -->
  <meta property="og:title" content="spheresmooth: An R Package for Penalized Piecewise Geodesic Curve Fitting on a Sphere"/>
  <meta property="og:type" content="article"/>
  <meta property="og:description" content="This paper introduces an R package \CRANpkg{spheresmooth}, which implements a penalized piecewise geodesic curve fitting method on a sphere. Spherical data observed over a continuum arise frequently in various fields including cardiology, computer vision, physiology, and geophysics. We propose an adaptive smoothing method by extending the linear spline approach to spherical data. Penalization based on differences of velocity vectors endows sparsity among control points of the spherical curve, which enables data-adaptive curve fitting. The proposed method is implemented with a Riemannian block coordinate descent algorithm. Illustrations on Triassic and Jurassic polar wander data and tropical cyclone data demonstrate practicality of the proposed method and the associated \CRANpkg{spheresmooth} package."/>
  <meta property="og:locale" content="en_US"/>

  <!--  https://dev.twitter.com/cards/types/summary -->
  <meta property="twitter:card" content="summary"/>
  <meta property="twitter:title" content="spheresmooth: An R Package for Penalized Piecewise Geodesic Curve Fitting on a Sphere"/>
  <meta property="twitter:description" content="This paper introduces an R package \CRANpkg{spheresmooth}, which implements a penalized piecewise geodesic curve fitting method on a sphere. Spherical data observed over a continuum arise frequently in various fields including cardiology, computer vision, physiology, and geophysics. We propose an adaptive smoothing method by extending the linear spline approach to spherical data. Penalization based on differences of velocity vectors endows sparsity among control points of the spherical curve, which enables data-adaptive curve fitting. The proposed method is implemented with a Riemannian block coordinate descent algorithm. Illustrations on Triassic and Jurassic polar wander data and tropical cyclone data demonstrate practicality of the proposed method and the associated \CRANpkg{spheresmooth} package."/>

  <!--  https://scholar.google.com/intl/en/scholar/inclusion.html#indexing -->
  <meta name="citation_title" content="spheresmooth: An R Package for Penalized Piecewise Geodesic Curve Fitting on a Sphere"/>
  <meta name="citation_fulltext_html_url" content="https://doi.org/10.32614/RJ-2025-004"/>
  <meta name="citation_pdf_url" content="RJ-2025-004.pdf"/>
  <meta name="citation_volume" content="17"/>
  <meta name="citation_issue" content="1"/>
  <meta name="citation_doi" content="10.32614/RJ-2025-004"/>
  <meta name="citation_journal_title" content="The R Journal"/>
  <meta name="citation_issn" content="2073-4859"/>
  <meta name="citation_firstpage" content="67"/>
  <meta name="citation_lastpage" content="87"/>
  <meta name="citation_fulltext_world_readable" content=""/>
  <meta name="citation_online_date" content="2025/08/07"/>
  <meta name="citation_publication_date" content="2025/08/07"/>
  <meta name="citation_author" content="Jae-Hwan Jhong"/>
  <meta name="citation_author_institution" content="ChungBuk National University"/>
  <meta name="citation_author" content="Seyoung Lee"/>
  <meta name="citation_author_institution" content="Sungshin Women&#39;s University"/>
  <meta name="citation_author" content="Ja-Yong Koo"/>
  <meta name="citation_author_institution" content="Korea University"/>
  <meta name="citation_author" content="Kwan-Young Bak"/>
  <meta name="citation_author_institution" content="Sungshin Women&#39;s University"/>
  <!--/radix_placeholder_meta_tags-->
  
  <meta name="citation_reference" content="citation_title=rgl: 3D visualization using OpenGL (R package version 1.3.1);citation_author=Duncan Murdoch;citation_author=Daniel Adler"/>
  <meta name="citation_reference" content="citation_title=sphereplot: Spherical plotting (R package version 1.5.1);citation_author=Aaron Robotham"/>
  <meta name="citation_reference" content="citation_title=ggplot2: Elegant graphics for data analysis;citation_publisher=Springer-Verlag New York;citation_author=Hadley Wickham"/>
  <meta name="citation_reference" content="citation_title=rworldmap: A new R package for mapping global data;citation_volume=3;citation_doi=10.32614/RJ-2011-006;citation_author=Andy South"/>
  <meta name="citation_reference" content="citation_title=Differential geometry of curves and surfaces;citation_publisher=Prentice-Hall, Englewood Cliffs, New Jersey;citation_author=Manfredo Perdigão Carmo"/>
  <meta name="citation_reference" content="citation_title=Influence of inclination error in sedimentary rocks on the Triassic and Jurassic apparent pole wander path for North America and implications for Cordilleran tectonics;citation_publisher=Wiley Online Library;citation_volume=115;citation_author=Dennis V Kent;citation_author=Edward Irving"/>
  <meta name="citation_reference" content="citation_title=Riemannian geometry;citation_publisher=Birkhäuser;citation_author=Manfredo Perdigão Carmo"/>
  <meta name="citation_reference" content="citation_title=A regression technique for angular variates;citation_publisher=JSTOR;citation_author=A Lawrence Gould"/>
  <meta name="citation_reference" content="citation_title=A robust least-squares Gondwanan apparent polar wander path and the question of palaeomagnetic assessment of Gondwanan reconstruction;citation_publisher=Elsevier;citation_volume=57;citation_author=R Thompson;citation_author=R M Clark"/>
  <meta name="citation_reference" content="citation_title=Fitting smooth paths to spherical data;citation_publisher=Wiley Online Library;citation_volume=36;citation_author=Peter E Jupp;citation_author=John T Kent"/>
  <meta name="citation_reference" content="citation_title=Fitting smoothing splines to time-indexed, noisy points on nonlinear manifolds;citation_publisher=Elsevier;citation_volume=30;citation_author=Jingyong Su;citation_author=Ian L Dryden;citation_author=Eric Klassen;citation_author=Huiling Le;citation_author=Anuj Srivastava"/>
  <meta name="citation_reference" content="citation_title=Shape-space smoothing splines for planar landmark data;citation_publisher=Oxford University Press;citation_volume=94;citation_author=Alfred Kume;citation_author=Ian L Dryden;citation_author=Huiling Le"/>
  <meta name="citation_reference" content="citation_title=Smoothing splines on Riemannian manifolds, with applications to 3D shape space;citation_publisher=Oxford University Press;citation_volume=83;citation_author=Kwang-Rae Kim;citation_author=Ian L Dryden;citation_author=Huiling Le;citation_author=Katie E Severn"/>
  <meta name="citation_reference" content="citation_title=A gradient-descent method for curve fitting on Riemannian manifolds;citation_publisher=Springer;citation_volume=12;citation_author=Chafik Samir;citation_author=P A Absil;citation_author=Anuj Srivastava;citation_author=Eric Klassen"/>
  <meta name="citation_reference" content="citation_title=Splines of class $C^k$ on non-Euclidean spaces;citation_publisher=Oxford University Press;citation_volume=12;citation_author=M Camarinha;citation_author=F Silva Leite;citation_author=P Crouch"/>
  <meta name="citation_reference" content="citation_title=Cubic splines on curved spaces;citation_publisher=Oxford University Press;citation_volume=6;citation_author=Lyle Noakes;citation_author=Greg Heinzinger;citation_author=Brad Paden"/>
  <meta name="citation_reference" content="citation_title=Riemannian means as solutions of variational problems;citation_publisher=Cambridge University Press;citation_volume=9;citation_author=Luís Machado;citation_author=F Silva Leite;citation_author=Knut Hüper"/>
  <meta name="citation_reference" content="citation_title=Estimating the dimension of a model;citation_publisher=The Institute of Mathematical Statistics;citation_volume=6;citation_author=Gideon Schwarz"/>
  <meta name="citation_reference" content="citation_title=Intrinsic spherical smoothing method based on generalized Bézier curves and sparsity inducing penalization;citation_publisher=Taylor &amp; Francis;citation_volume=50;citation_author=Kwan-Young Bak;citation_author=Jae-Kyung Shin;citation_author=Ja-Yong Koo"/>
  <meta name="citation_reference" content="citation_title=HEALPix: A framework for high-resolution discretization and fast analysis of data distributed on the sphere;citation_publisher=IOP Publishing;citation_volume=622;citation_author=Krzysztof M Górski;citation_author=Eric Hivon;citation_author=Anthony J Banday;citation_author=Benjamin D Wandelt;citation_author=Frode K Hansen;citation_author=M Reinecke;citation_author=Matthias Bartelmann"/>
  <!--radix_placeholder_rmarkdown_metadata-->

  <script type="text/json" id="radix-rmarkdown-metadata">
  {"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["title","date","description","draft","author","type","header-includes","output","bibliography","link-citations","date_received","volume","issue","slug","journal","pdf_url","citation_url","doi","creative_commons","packages","CTV","csl"]}},"value":[{"type":"character","attributes":{},"value":["spheresmooth: An R Package for Penalized Piecewise Geodesic Curve Fitting on a Sphere"]},{"type":"character","attributes":{},"value":["2025-08-07"]},{"type":"character","attributes":{},"value":["This paper introduces an R package \\CRANpkg{spheresmooth}, which implements a penalized piecewise geodesic curve fitting method on a sphere. Spherical data observed over a continuum arise frequently in various fields including cardiology, computer vision, physiology, and geophysics. We propose an adaptive smoothing method by extending the linear spline approach to spherical data. Penalization based on differences of velocity vectors endows sparsity among control points of the spherical curve, which enables data-adaptive curve fitting. The proposed method is implemented with a Riemannian block coordinate descent algorithm. Illustrations on Triassic and Jurassic polar wander data and tropical cyclone data demonstrate practicality of the proposed method and the associated \\CRANpkg{spheresmooth} package.\n"]},{"type":"logical","attributes":{},"value":[false]},{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address","orcid_id"]}},"value":[{"type":"character","attributes":{},"value":["Jae-Hwan Jhong"]},{"type":"character","attributes":{},"value":["ChungBuk National University"]},{"type":"character","attributes":{},"value":["Department of Information Statistics","1, Chungdae-ro, Seowon-gu, Cheongju-si, Chungcheongbuk-do, Republic of Korea"]},{"type":"character","attributes":{},"value":["0000-0003-2266-4986"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address"]}},"value":[{"type":"character","attributes":{},"value":["Seyoung Lee"]},{"type":"character","attributes":{},"value":["Sungshin Women's University"]},{"type":"character","attributes":{},"value":["School of Mathematics, Statistics and Data Science","2, Bomun-ro 34da-gil, Seongbuk-gu, Seoul 02844,  Republic of Korea"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address"]}},"value":[{"type":"character","attributes":{},"value":["Ja-Yong Koo"]},{"type":"character","attributes":{},"value":["Korea University"]},{"type":"character","attributes":{},"value":["Department of Statistics","145, Anam-ro, Seongbuk-gu, Seoul 02841, Republic of Korea"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address","email","orcid_id"]}},"value":[{"type":"character","attributes":{},"value":["Kwan-Young Bak"]},{"type":"character","attributes":{},"value":["Sungshin Women's University"]},{"type":"character","attributes":{},"value":["School of Mathematics, Statistics and Data Science","Data Science Center","2, Bomun-ro 34da-gil, Seongbuk-gu, Seoul 02844,  Republic of Korea"]},{"type":"character","attributes":{},"value":["kybak@sungshin.ac.kr"]},{"type":"character","attributes":{},"value":["0000-0002-4541-160X"]}]}]},{"type":"character","attributes":{},"value":["package"]},{"type":"character","attributes":{},"value":["\\usepackage{subcaption}"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["distill::distill_article"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["self_contained","toc"]}},"value":[{"type":"logical","attributes":{},"value":[true]},{"type":"logical","attributes":{},"value":[false]}]}]},{"type":"character","attributes":{},"value":["RJreferences.bib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2024-05-17"]},{"type":"integer","attributes":{},"value":[17]},{"type":"integer","attributes":{},"value":[1]},{"type":"character","attributes":{},"value":["RJ-2025-004"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["title","issn","firstpage","lastpage"]}},"value":[{"type":"character","attributes":{},"value":["The R Journal"]},{"type":"character","attributes":{},"value":["2073-4859"]},{"type":"integer","attributes":{},"value":[67]},{"type":"integer","attributes":{},"value":[87]}]},{"type":"character","attributes":{},"value":["RJ-2025-004.pdf"]},{"type":"character","attributes":{},"value":["https://doi.org/10.32614/RJ-2025-004"]},{"type":"character","attributes":{},"value":["10.32614/RJ-2025-004"]},{"type":"character","attributes":{},"value":["CC BY"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["cran","bioc"]}},"value":[{"type":"character","attributes":{},"value":["spheresmooth","sphereplot","rgl","rworldmap","ggplot2","sf"]},{"type":"list","attributes":{},"value":[]}]},{"type":"character","attributes":{},"value":["ChemPhys","DynamicVisualizations","NetworkAnalysis","OfficialStatistics","Phylogenetics","Spatial","SpatioTemporal","TeachingStatistics"]},{"type":"character","attributes":{},"value":["/home/mitchell/R/x86_64-pc-linux-gnu-library/4.5/rjtools/rjournal.csl"]}]}
  </script>
  <!--/radix_placeholder_rmarkdown_metadata-->
  
  <script type="text/json" id="radix-resource-manifest">
  {"type":"character","attributes":{},"value":["code/spheresmooth.R","figures/APWdata_worldmap_old.png","figures/APWdata_worldmap.png","figures/APWdata_zoommap_old.png","figures/APWdata_zoommap.png","figures/exponential_map.pdf","figures/exponential_map.png","figures/geodesic_dist.pdf","figures/geodesic_dist.png","figures/geodesic.pdf","figures/geodesic.png","figures/Gonidata_worldmap_old.png","figures/Gonidata_worldmap.png","figures/Gonidata_zoommap_old.png","figures/Gonidata_zoommap.png","figures/penalized_geo.pdf","figures/penalized_geo.png","figures/penalized_geo2_1.pdf","figures/penalized_geo2_1.png","figures/penalized_geo2.pdf","figures/penalized_geo2.png","figures/piecewise_geo1.png","figures/piecewise_geo2.png","figures/Riemannian_grad.pdf","figures/Riemannian_grad.png","RJ-2025-004.log","RJ-2025-004.pdf","RJ-2025-004.tex","RJ-2025-004.zip","RJournal.sty","RJreferences.bib","RJwrapper.log","RJwrapper.tex","Rlogo-5.png","spheresmooth.tex"]}
  </script>
  <!--radix_placeholder_navigation_in_header-->
  <!--/radix_placeholder_navigation_in_header-->
  <!--radix_placeholder_distill-->

  <style type="text/css">

  body {
    background-color: white;
  }

  .pandoc-table {
    width: 100%;
  }

  .pandoc-table>caption {
    margin-bottom: 10px;
  }

  .pandoc-table th:not([align]) {
    text-align: left;
  }

  .pagedtable-footer {
    font-size: 15px;
  }

  d-byline .byline {
    grid-template-columns: 2fr 2fr;
  }

  d-byline .byline h3 {
    margin-block-start: 1.5em;
  }

  d-byline .byline .authors-affiliations h3 {
    margin-block-start: 0.5em;
  }

  .authors-affiliations .orcid-id {
    width: 16px;
    height:16px;
    margin-left: 4px;
    margin-right: 4px;
    vertical-align: middle;
    padding-bottom: 2px;
  }

  d-title .dt-tags {
    margin-top: 1em;
    grid-column: text;
  }

  .dt-tags .dt-tag {
    text-decoration: none;
    display: inline-block;
    color: rgba(0,0,0,0.6);
    padding: 0em 0.4em;
    margin-right: 0.5em;
    margin-bottom: 0.4em;
    font-size: 70%;
    border: 1px solid rgba(0,0,0,0.2);
    border-radius: 3px;
    text-transform: uppercase;
    font-weight: 500;
  }

  d-article table.gt_table td,
  d-article table.gt_table th {
    border-bottom: none;
    font-size: 100%;
  }

  .html-widget {
    margin-bottom: 2.0em;
  }

  .l-screen-inset {
    padding-right: 16px;
  }

  .l-screen .caption {
    margin-left: 10px;
  }

  .shaded {
    background: rgb(247, 247, 247);
    padding-top: 20px;
    padding-bottom: 20px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  }

  .shaded .html-widget {
    margin-bottom: 0;
    border: 1px solid rgba(0, 0, 0, 0.1);
  }

  .shaded .shaded-content {
    background: white;
  }

  .text-output {
    margin-top: 0;
    line-height: 1.5em;
  }

  .hidden {
    display: none !important;
  }

  hr.section-separator {
    border: none;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    margin: 0px;
  }


  d-byline {
    border-top: none;
  }

  d-article {
    padding-top: 2.5rem;
    padding-bottom: 30px;
    border-top: none;
  }

  d-appendix {
    padding-top: 30px;
  }

  d-article>p>img {
    width: 100%;
  }

  d-article h2 {
    margin: 1rem 0 1.5rem 0;
  }

  d-article h3 {
    margin-top: 1.5rem;
  }

  d-article iframe {
    border: 1px solid rgba(0, 0, 0, 0.1);
    margin-bottom: 2.0em;
    width: 100%;
  }

  /* Tweak code blocks */

  d-article div.sourceCode code,
  d-article pre code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  d-article pre,
  d-article div.sourceCode,
  d-article div.sourceCode pre {
    overflow: auto;
  }

  d-article div.sourceCode {
    background-color: white;
  }

  d-article div.sourceCode pre {
    padding-left: 10px;
    font-size: 12px;
    border-left: 2px solid rgba(0,0,0,0.1);
  }

  d-article pre {
    font-size: 12px;
    color: black;
    background: none;
    margin-top: 0;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  d-article pre a {
    border-bottom: none;
  }

  d-article pre a:hover {
    border-bottom: none;
    text-decoration: underline;
  }

  d-article details {
    grid-column: text;
    margin-bottom: 0.8em;
  }

  @media(min-width: 768px) {

  d-article pre,
  d-article div.sourceCode,
  d-article div.sourceCode pre {
    overflow: visible !important;
  }

  d-article div.sourceCode pre {
    padding-left: 18px;
    font-size: 14px;
  }

  /* tweak for Pandoc numbered line within distill */
  d-article pre.numberSource code > span {
      left: -2em;
  }

  d-article pre {
    font-size: 14px;
  }

  }

  figure img.external {
    background: white;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
    padding: 18px;
    box-sizing: border-box;
  }

  /* CSS for d-contents */

  .d-contents {
    grid-column: text;
    color: rgba(0,0,0,0.8);
    font-size: 0.9em;
    padding-bottom: 1em;
    margin-bottom: 1em;
    padding-bottom: 0.5em;
    margin-bottom: 1em;
    padding-left: 0.25em;
    justify-self: start;
  }

  @media(min-width: 1000px) {
    .d-contents.d-contents-float {
      height: 0;
      grid-column-start: 1;
      grid-column-end: 4;
      justify-self: center;
      padding-right: 3em;
      padding-left: 2em;
    }
  }

  .d-contents nav h3 {
    font-size: 18px;
    margin-top: 0;
    margin-bottom: 1em;
  }

  .d-contents li {
    list-style-type: none
  }

  .d-contents nav > ul {
    padding-left: 0;
  }

  .d-contents ul {
    padding-left: 1em
  }

  .d-contents nav ul li {
    margin-top: 0.6em;
    margin-bottom: 0.2em;
  }

  .d-contents nav a {
    font-size: 13px;
    border-bottom: none;
    text-decoration: none
    color: rgba(0, 0, 0, 0.8);
  }

  .d-contents nav a:hover {
    text-decoration: underline solid rgba(0, 0, 0, 0.6)
  }

  .d-contents nav > ul > li > a {
    font-weight: 600;
  }

  .d-contents nav > ul > li > ul {
    font-weight: inherit;
  }

  .d-contents nav > ul > li > ul > li {
    margin-top: 0.2em;
  }


  .d-contents nav ul {
    margin-top: 0;
    margin-bottom: 0.25em;
  }

  .d-article-with-toc h2:nth-child(2) {
    margin-top: 0;
  }


  /* Figure */

  .figure {
    position: relative;
    margin-bottom: 2.5em;
    margin-top: 1.5em;
  }

  .figure .caption {
    color: rgba(0, 0, 0, 0.6);
    font-size: 12px;
    line-height: 1.5em;
  }

  .figure img.external {
    background: white;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
    padding: 18px;
    box-sizing: border-box;
  }

  .figure .caption a {
    color: rgba(0, 0, 0, 0.6);
  }

  .figure .caption b,
  .figure .caption strong, {
    font-weight: 600;
    color: rgba(0, 0, 0, 1.0);
  }

  /* Citations */

  d-article .citation {
    color: inherit;
    cursor: inherit;
  }

  div.hanging-indent{
    margin-left: 1em; text-indent: -1em;
  }

  /* Citation hover box */

  .tippy-box[data-theme~=light-border] {
    background-color: rgba(250, 250, 250, 0.95);
  }

  .tippy-content > p {
    margin-bottom: 0;
    padding: 2px;
  }


  /* Tweak 1000px media break to show more text */

  @media(min-width: 1000px) {
    .base-grid,
    distill-header,
    d-title,
    d-abstract,
    d-article,
    d-appendix,
    distill-appendix,
    d-byline,
    d-footnote-list,
    d-citation-list,
    distill-footer {
      grid-template-columns: [screen-start] 1fr [page-start kicker-start] 80px [middle-start] 50px [text-start kicker-end] 65px 65px 65px 65px 65px 65px 65px 65px [text-end gutter-start] 65px [middle-end] 65px [page-end gutter-end] 1fr [screen-end];
      grid-column-gap: 16px;
    }

    .grid {
      grid-column-gap: 16px;
    }

    d-article {
      font-size: 1.06rem;
      line-height: 1.7em;
    }
    figure .caption, .figure .caption, figure figcaption {
      font-size: 13px;
    }
  }

  @media(min-width: 1180px) {
    .base-grid,
    distill-header,
    d-title,
    d-abstract,
    d-article,
    d-appendix,
    distill-appendix,
    d-byline,
    d-footnote-list,
    d-citation-list,
    distill-footer {
      grid-template-columns: [screen-start] 1fr [page-start kicker-start] 60px [middle-start] 60px [text-start kicker-end] 60px 60px 60px 60px 60px 60px 60px 60px [text-end gutter-start] 60px [middle-end] 60px [page-end gutter-end] 1fr [screen-end];
      grid-column-gap: 32px;
    }

    .grid {
      grid-column-gap: 32px;
    }
  }


  /* Get the citation styles for the appendix (not auto-injected on render since
     we do our own rendering of the citation appendix) */

  d-appendix .citation-appendix,
  .d-appendix .citation-appendix {
    font-size: 11px;
    line-height: 15px;
    border-left: 1px solid rgba(0, 0, 0, 0.1);
    padding-left: 18px;
    border: 1px solid rgba(0,0,0,0.1);
    background: rgba(0, 0, 0, 0.02);
    padding: 10px 18px;
    border-radius: 3px;
    color: rgba(150, 150, 150, 1);
    overflow: hidden;
    margin-top: -12px;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  /* Include appendix styles here so they can be overridden */

  d-appendix {
    contain: layout style;
    font-size: 0.8em;
    line-height: 1.7em;
    margin-top: 60px;
    margin-bottom: 0;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    color: rgba(0,0,0,0.5);
    padding-top: 60px;
    padding-bottom: 48px;
  }

  d-appendix h3 {
    grid-column: page-start / text-start;
    font-size: 15px;
    font-weight: 500;
    margin-top: 1em;
    margin-bottom: 0;
    color: rgba(0,0,0,0.65);
  }

  d-appendix h3 + * {
    margin-top: 1em;
  }

  d-appendix ol {
    padding: 0 0 0 15px;
  }

  @media (min-width: 768px) {
    d-appendix ol {
      padding: 0 0 0 30px;
      margin-left: -30px;
    }
  }

  d-appendix li {
    margin-bottom: 1em;
  }

  d-appendix a {
    color: rgba(0, 0, 0, 0.6);
  }

  d-appendix > * {
    grid-column: text;
  }

  d-appendix > d-footnote-list,
  d-appendix > d-citation-list,
  d-appendix > distill-appendix {
    grid-column: screen;
  }

  /* Include footnote styles here so they can be overridden */

  d-footnote-list {
    contain: layout style;
  }

  d-footnote-list > * {
    grid-column: text;
  }

  d-footnote-list a.footnote-backlink {
    color: rgba(0,0,0,0.3);
    padding-left: 0.5em;
  }



  /* Anchor.js */

  .anchorjs-link {
    /*transition: all .25s linear; */
    text-decoration: none;
    border-bottom: none;
  }
  *:hover > .anchorjs-link {
    margin-left: -1.125em !important;
    text-decoration: none;
    border-bottom: none;
  }

  /* Social footer */

  .social_footer {
    margin-top: 30px;
    margin-bottom: 0;
    color: rgba(0,0,0,0.67);
  }

  .disqus-comments {
    margin-right: 30px;
  }

  .disqus-comment-count {
    border-bottom: 1px solid rgba(0, 0, 0, 0.4);
    cursor: pointer;
  }

  #disqus_thread {
    margin-top: 30px;
  }

  .article-sharing a {
    border-bottom: none;
    margin-right: 8px;
  }

  .article-sharing a:hover {
    border-bottom: none;
  }

  .sidebar-section.subscribe {
    font-size: 12px;
    line-height: 1.6em;
  }

  .subscribe p {
    margin-bottom: 0.5em;
  }


  .article-footer .subscribe {
    font-size: 15px;
    margin-top: 45px;
  }


  .sidebar-section.custom {
    font-size: 12px;
    line-height: 1.6em;
  }

  .custom p {
    margin-bottom: 0.5em;
  }

  /* Styles for listing layout (hide title) */
  .layout-listing d-title, .layout-listing .d-title {
    display: none;
  }

  /* Styles for posts lists (not auto-injected) */


  .posts-with-sidebar {
    padding-left: 45px;
    padding-right: 45px;
  }

  .posts-list .description h2,
  .posts-list .description p {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
  }

  .posts-list .description h2 {
    font-weight: 700;
    border-bottom: none;
    padding-bottom: 0;
  }

  .posts-list h2.post-tag {
    border-bottom: 1px solid rgba(0, 0, 0, 0.2);
    padding-bottom: 12px;
  }
  .posts-list {
    margin-top: 60px;
    margin-bottom: 24px;
  }

  .posts-list .post-preview {
    text-decoration: none;
    overflow: hidden;
    display: block;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    padding: 24px 0;
  }

  .post-preview-last {
    border-bottom: none !important;
  }

  .posts-list .posts-list-caption {
    grid-column: screen;
    font-weight: 400;
  }

  .posts-list .post-preview h2 {
    margin: 0 0 6px 0;
    line-height: 1.2em;
    font-style: normal;
    font-size: 24px;
  }

  .posts-list .post-preview p {
    margin: 0 0 12px 0;
    line-height: 1.4em;
    font-size: 16px;
  }

  .posts-list .post-preview .thumbnail {
    box-sizing: border-box;
    margin-bottom: 24px;
    position: relative;
    max-width: 500px;
  }
  .posts-list .post-preview img {
    width: 100%;
    display: block;
  }

  .posts-list .metadata {
    font-size: 12px;
    line-height: 1.4em;
    margin-bottom: 18px;
  }

  .posts-list .metadata > * {
    display: inline-block;
  }

  .posts-list .metadata .publishedDate {
    margin-right: 2em;
  }

  .posts-list .metadata .dt-authors {
    display: block;
    margin-top: 0.3em;
    margin-right: 2em;
  }

  .posts-list .dt-tags {
    display: block;
    line-height: 1em;
  }

  .posts-list .dt-tags .dt-tag {
    display: inline-block;
    color: rgba(0,0,0,0.6);
    padding: 0.3em 0.4em;
    margin-right: 0.2em;
    margin-bottom: 0.4em;
    font-size: 60%;
    border: 1px solid rgba(0,0,0,0.2);
    border-radius: 3px;
    text-transform: uppercase;
    font-weight: 500;
  }

  .posts-list img {
    opacity: 1;
  }

  .posts-list img[data-src] {
    opacity: 0;
  }

  .posts-more {
    clear: both;
  }


  .posts-sidebar {
    font-size: 16px;
  }

  .posts-sidebar h3 {
    font-size: 16px;
    margin-top: 0;
    margin-bottom: 0.5em;
    font-weight: 400;
    text-transform: uppercase;
  }

  .sidebar-section {
    margin-bottom: 30px;
  }

  .categories ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }

  .categories li {
    color: rgba(0, 0, 0, 0.8);
    margin-bottom: 0;
  }

  .categories li>a {
    border-bottom: none;
  }

  .categories li>a:hover {
    border-bottom: 1px solid rgba(0, 0, 0, 0.4);
  }

  .categories .active {
    font-weight: 600;
  }

  .categories .category-count {
    color: rgba(0, 0, 0, 0.4);
  }


  @media(min-width: 768px) {
    .posts-list .post-preview h2 {
      font-size: 26px;
    }
    .posts-list .post-preview .thumbnail {
      float: right;
      width: 30%;
      margin-bottom: 0;
    }
    .posts-list .post-preview .description {
      float: left;
      width: 45%;
    }
    .posts-list .post-preview .metadata {
      float: left;
      width: 20%;
      margin-top: 8px;
    }
    .posts-list .post-preview p {
      margin: 0 0 12px 0;
      line-height: 1.5em;
      font-size: 16px;
    }
    .posts-with-sidebar .posts-list {
      float: left;
      width: 75%;
    }
    .posts-with-sidebar .posts-sidebar {
      float: right;
      width: 20%;
      margin-top: 60px;
      padding-top: 24px;
      padding-bottom: 24px;
    }
  }


  /* Improve display for browsers without grid (IE/Edge <= 15) */

  .downlevel {
    line-height: 1.6em;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
    margin: 0;
  }

  .downlevel .d-title {
    padding-top: 6rem;
    padding-bottom: 1.5rem;
  }

  .downlevel .d-title h1 {
    font-size: 50px;
    font-weight: 700;
    line-height: 1.1em;
    margin: 0 0 0.5rem;
  }

  .downlevel .d-title p {
    font-weight: 300;
    font-size: 1.2rem;
    line-height: 1.55em;
    margin-top: 0;
  }

  .downlevel .d-byline {
    padding-top: 0.8em;
    padding-bottom: 0.8em;
    font-size: 0.8rem;
    line-height: 1.8em;
  }

  .downlevel .section-separator {
    border: none;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
  }

  .downlevel .d-article {
    font-size: 1.06rem;
    line-height: 1.7em;
    padding-top: 1rem;
    padding-bottom: 2rem;
  }


  .downlevel .d-appendix {
    padding-left: 0;
    padding-right: 0;
    max-width: none;
    font-size: 0.8em;
    line-height: 1.7em;
    margin-bottom: 0;
    color: rgba(0,0,0,0.5);
    padding-top: 40px;
    padding-bottom: 48px;
  }

  .downlevel .footnotes ol {
    padding-left: 13px;
  }

  .downlevel .base-grid,
  .downlevel .distill-header,
  .downlevel .d-title,
  .downlevel .d-abstract,
  .downlevel .d-article,
  .downlevel .d-appendix,
  .downlevel .distill-appendix,
  .downlevel .d-byline,
  .downlevel .d-footnote-list,
  .downlevel .d-citation-list,
  .downlevel .distill-footer,
  .downlevel .appendix-bottom,
  .downlevel .posts-container {
    padding-left: 40px;
    padding-right: 40px;
  }

  @media(min-width: 768px) {
    .downlevel .base-grid,
    .downlevel .distill-header,
    .downlevel .d-title,
    .downlevel .d-abstract,
    .downlevel .d-article,
    .downlevel .d-appendix,
    .downlevel .distill-appendix,
    .downlevel .d-byline,
    .downlevel .d-footnote-list,
    .downlevel .d-citation-list,
    .downlevel .distill-footer,
    .downlevel .appendix-bottom,
    .downlevel .posts-container {
    padding-left: 150px;
    padding-right: 150px;
    max-width: 900px;
  }
  }

  .downlevel pre code {
    display: block;
    border-left: 2px solid rgba(0, 0, 0, .1);
    padding: 0 0 0 20px;
    font-size: 14px;
  }

  .downlevel code, .downlevel pre {
    color: black;
    background: none;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  .downlevel .posts-list .post-preview {
    color: inherit;
  }



  </style>

  <script type="application/javascript">

  function is_downlevel_browser() {
    if (bowser.isUnsupportedBrowser({ msie: "12", msedge: "16"},
                                   window.navigator.userAgent)) {
      return true;
    } else {
      return window.load_distill_framework === undefined;
    }
  }

  // show body when load is complete
  function on_load_complete() {

    // add anchors
    if (window.anchors) {
      window.anchors.options.placement = 'left';
      window.anchors.add('d-article > h2, d-article > h3, d-article > h4, d-article > h5');
    }


    // set body to visible
    document.body.style.visibility = 'visible';

    // force redraw for leaflet widgets
    if (window.HTMLWidgets) {
      var maps = window.HTMLWidgets.findAll(".leaflet");
      $.each(maps, function(i, el) {
        var map = this.getMap();
        map.invalidateSize();
        map.eachLayer(function(layer) {
          if (layer instanceof L.TileLayer)
            layer.redraw();
        });
      });
    }

    // trigger 'shown' so htmlwidgets resize
    $('d-article').trigger('shown');
  }

  function init_distill() {

    init_common();

    // create front matter
    var front_matter = $('<d-front-matter></d-front-matter>');
    $('#distill-front-matter').wrap(front_matter);

    // create d-title
    $('.d-title').changeElementType('d-title');

    // separator
    var separator = '<hr class="section-separator" style="clear: both"/>';
    // prepend separator above appendix
    $('.d-byline').before(separator);
    $('.d-article').before(separator);

    // create d-byline
    var byline = $('<d-byline></d-byline>');
    $('.d-byline').replaceWith(byline);

    // create d-article
    var article = $('<d-article></d-article>');
    $('.d-article').wrap(article).children().unwrap();

    // move posts container into article
    $('.posts-container').appendTo($('d-article'));

    // create d-appendix
    $('.d-appendix').changeElementType('d-appendix');

    // flag indicating that we have appendix items
    var appendix = $('.appendix-bottom').children('h3').length > 0;

    // replace footnotes with <d-footnote>
    $('.footnote-ref').each(function(i, val) {
      appendix = true;
      var href = $(this).attr('href');
      var id = href.replace('#', '');
      var fn = $('#' + id);
      var fn_p = $('#' + id + '>p');
      fn_p.find('.footnote-back').remove();
      var text = fn_p.html();
      var dtfn = $('<d-footnote></d-footnote>');
      dtfn.html(text);
      $(this).replaceWith(dtfn);
    });
    // remove footnotes
    $('.footnotes').remove();

    // move refs into #references-listing
    $('#references-listing').replaceWith($('#refs'));

    $('h1.appendix, h2.appendix').each(function(i, val) {
      $(this).changeElementType('h3');
    });
    $('h3.appendix').each(function(i, val) {
      var id = $(this).attr('id');
      $('.d-contents a[href="#' + id + '"]').parent().remove();
      appendix = true;
      $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('d-appendix'));
    });

    // show d-appendix if we have appendix content
    $("d-appendix").css('display', appendix ? 'grid' : 'none');

    // localize layout chunks to just output
    $('.layout-chunk').each(function(i, val) {

      // capture layout
      var layout = $(this).attr('data-layout');

      // apply layout to markdown level block elements
      var elements = $(this).children().not('details, div.sourceCode, pre, script');
      elements.each(function(i, el) {
        var layout_div = $('<div class="' + layout + '"></div>');
        if (layout_div.hasClass('shaded')) {
          var shaded_content = $('<div class="shaded-content"></div>');
          $(this).wrap(shaded_content);
          $(this).parent().wrap(layout_div);
        } else {
          $(this).wrap(layout_div);
        }
      });


      // unwrap the layout-chunk div
      $(this).children().unwrap();
    });

    // remove code block used to force  highlighting css
    $('.distill-force-highlighting-css').parent().remove();

    // remove empty line numbers inserted by pandoc when using a
    // custom syntax highlighting theme, except when numbering line
    // in code chunk
    $('pre:not(.numberLines) code.sourceCode a:empty').remove();

    // load distill framework
    load_distill_framework();

    // wait for window.distillRunlevel == 4 to do post processing
    function distill_post_process() {

      if (!window.distillRunlevel || window.distillRunlevel < 4)
        return;

      // hide author/affiliations entirely if we have no authors
      var front_matter = JSON.parse($("#distill-front-matter").html());
      var have_authors = front_matter.authors && front_matter.authors.length > 0;
      if (!have_authors)
        $('d-byline').addClass('hidden');

      // article with toc class
      $('.d-contents').parent().addClass('d-article-with-toc');

      // strip links that point to #
      $('.authors-affiliations').find('a[href="#"]').removeAttr('href');

      // add orcid ids
      $('.authors-affiliations').find('.author').each(function(i, el) {
        var orcid_id = front_matter.authors[i].orcidID;
        var author_name = front_matter.authors[i].author
        if (orcid_id) {
          var a = $('<a></a>');
          a.attr('href', 'https://orcid.org/' + orcid_id);
          var img = $('<img></img>');
          img.addClass('orcid-id');
          img.attr('alt', author_name ? 'ORCID ID for ' + author_name : 'ORCID ID');
          img.attr('src','data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg==');
          a.append(img);
          $(this).append(a);
        }
      });

      // hide elements of author/affiliations grid that have no value
      function hide_byline_column(caption) {
        $('d-byline').find('h3:contains("' + caption + '")').parent().css('visibility', 'hidden');
      }

      // affiliations
      var have_affiliations = false;
      for (var i = 0; i<front_matter.authors.length; ++i) {
        var author = front_matter.authors[i];
        if (author.affiliation !== "&nbsp;") {
          have_affiliations = true;
          break;
        }
      }
      if (!have_affiliations)
        $('d-byline').find('h3:contains("Affiliations")').css('visibility', 'hidden');

      // published date
      if (!front_matter.publishedDate)
        hide_byline_column("Published");

      // document object identifier
      var doi = $('d-byline').find('h3:contains("DOI")');
      var doi_p = doi.next().empty();
      if (!front_matter.doi) {
        // if we have a citation and valid citationText then link to that
        if ($('#citation').length > 0 && front_matter.citationText) {
          doi.html('Citation');
          $('<a href="#citation"></a>')
            .text(front_matter.citationText)
            .appendTo(doi_p);
        } else {
          hide_byline_column("DOI");
        }
      } else {
        $('<a></a>')
           .attr('href', "https://doi.org/" + front_matter.doi)
           .html(front_matter.doi)
           .appendTo(doi_p);
      }

       // change plural form of authors/affiliations
      if (front_matter.authors.length === 1) {
        var grid = $('.authors-affiliations');
        grid.children('h3:contains("Authors")').text('Author');
        grid.children('h3:contains("Affiliations")').text('Affiliation');
      }

      // remove d-appendix and d-footnote-list local styles
      $('d-appendix > style:first-child').remove();
      $('d-footnote-list > style:first-child').remove();

      // move appendix-bottom entries to the bottom
      $('.appendix-bottom').appendTo('d-appendix').children().unwrap();
      $('.appendix-bottom').remove();

      // hoverable references
      $('span.citation[data-cites]').each(function() {
        const citeChild = $(this).children()[0]
        // Do not process if @xyz has been used without escaping and without bibliography activated
        // https://github.com/rstudio/distill/issues/466
        if (citeChild === undefined) return true

        if (citeChild.nodeName == "D-FOOTNOTE") {
          var fn = citeChild
          $(this).html(fn.shadowRoot.querySelector("sup"))
          $(this).id = fn.id
          fn.remove()
        }
        var refs = $(this).attr('data-cites').split(" ");
        var refHtml = refs.map(function(ref) {
          // Could use CSS.escape too here, we insure backward compatibility in navigator
          return "<p>" + $('div[id="ref-' + ref + '"]').html() + "</p>";
        }).join("\n");
        window.tippy(this, {
          allowHTML: true,
          content: refHtml,
          maxWidth: 500,
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start'
        });
      });

      // fix footnotes in tables (#411)
      // replacing broken distill.pub feature
      $('table d-footnote').each(function() {
        // we replace internal showAtNode methode which is triggered when hovering a footnote
        this.hoverBox.showAtNode = function(node) {
          // ported from https://github.com/distillpub/template/pull/105/files
          calcOffset = function(elem) {
              let x = elem.offsetLeft;
              let y = elem.offsetTop;
              // Traverse upwards until an `absolute` element is found or `elem`
              // becomes null.
              while (elem = elem.offsetParent && elem.style.position != 'absolute') {
                  x += elem.offsetLeft;
                  y += elem.offsetTop;
              }

              return { left: x, top: y };
          }
          // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop
          const bbox = node.getBoundingClientRect();
          const offset = calcOffset(node);
          this.show([offset.left + bbox.width, offset.top + bbox.height]);
        }
      })

      // clear polling timer
      clearInterval(tid);

      // show body now that everything is ready
      on_load_complete();
    }

    var tid = setInterval(distill_post_process, 50);
    distill_post_process();

  }

  function init_downlevel() {

    init_common();

     // insert hr after d-title
    $('.d-title').after($('<hr class="section-separator"/>'));

    // check if we have authors
    var front_matter = JSON.parse($("#distill-front-matter").html());
    var have_authors = front_matter.authors && front_matter.authors.length > 0;

    // manage byline/border
    if (!have_authors)
      $('.d-byline').remove();
    $('.d-byline').after($('<hr class="section-separator"/>'));
    $('.d-byline a').remove();

    // remove toc
    $('.d-contents').remove();

    // move appendix elements
    $('h1.appendix, h2.appendix').each(function(i, val) {
      $(this).changeElementType('h3');
    });
    $('h3.appendix').each(function(i, val) {
      $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('.d-appendix'));
    });


    // inject headers into references and footnotes
    var refs_header = $('<h3></h3>');
    refs_header.text('References');
    $('#refs').prepend(refs_header);

    var footnotes_header = $('<h3></h3');
    footnotes_header.text('Footnotes');
    $('.footnotes').children('hr').first().replaceWith(footnotes_header);

    // move appendix-bottom entries to the bottom
    $('.appendix-bottom').appendTo('.d-appendix').children().unwrap();
    $('.appendix-bottom').remove();

    // remove appendix if it's empty
    if ($('.d-appendix').children().length === 0)
      $('.d-appendix').remove();

    // prepend separator above appendix
    $('.d-appendix').before($('<hr class="section-separator" style="clear: both"/>'));

    // trim code
    $('pre>code').each(function(i, val) {
      $(this).html($.trim($(this).html()));
    });

    // move posts-container right before article
    $('.posts-container').insertBefore($('.d-article'));

    $('body').addClass('downlevel');

    on_load_complete();
  }


  function init_common() {

    // jquery plugin to change element types
    (function($) {
      $.fn.changeElementType = function(newType) {
        var attrs = {};

        $.each(this[0].attributes, function(idx, attr) {
          attrs[attr.nodeName] = attr.nodeValue;
        });

        this.replaceWith(function() {
          return $("<" + newType + "/>", attrs).append($(this).contents());
        });
      };
    })(jQuery);

    // prevent underline for linked images
    $('a > img').parent().css({'border-bottom' : 'none'});

    // mark non-body figures created by knitr chunks as 100% width
    $('.layout-chunk').each(function(i, val) {
      var figures = $(this).find('img, .html-widget');
      // ignore leaflet img layers (#106)
      figures = figures.filter(':not(img[class*="leaflet"])')
      if ($(this).attr('data-layout') !== "l-body") {
        figures.css('width', '100%');
      } else {
        figures.css('max-width', '100%');
        figures.filter("[width]").each(function(i, val) {
          var fig = $(this);
          fig.css('width', fig.attr('width') + 'px');
        });

      }
    });

    // auto-append index.html to post-preview links in file: protocol
    // and in rstudio ide preview
    $('.post-preview').each(function(i, val) {
      if (window.location.protocol === "file:")
        $(this).attr('href', $(this).attr('href') + "index.html");
    });

    // get rid of index.html references in header
    if (window.location.protocol !== "file:") {
      $('.distill-site-header a[href]').each(function(i,val) {
        $(this).attr('href', $(this).attr('href').replace(/^index[.]html/, "./"));
      });
    }

    // add class to pandoc style tables
    $('tr.header').parent('thead').parent('table').addClass('pandoc-table');
    $('.kable-table').children('table').addClass('pandoc-table');

    // add figcaption style to table captions
    $('caption').parent('table').addClass("figcaption");

    // initialize posts list
    if (window.init_posts_list)
      window.init_posts_list();

    // implmement disqus comment link
    $('.disqus-comment-count').click(function() {
      window.headroom_prevent_pin = true;
      $('#disqus_thread').toggleClass('hidden');
      if (!$('#disqus_thread').hasClass('hidden')) {
        var offset = $(this).offset();
        $(window).resize();
        $('html, body').animate({
          scrollTop: offset.top - 35
        });
      }
    });
  }

  document.addEventListener('DOMContentLoaded', function() {
    if (is_downlevel_browser())
      init_downlevel();
    else
      window.addEventListener('WebComponentsReady', init_distill);
  });

  </script>

  <!--/radix_placeholder_distill-->
  <script src="RJ-2025-004_files/header-attrs-2.30/header-attrs.js"></script>
  <script src="RJ-2025-004_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
  <script src="RJ-2025-004_files/popper-2.6.0/popper.min.js"></script>
  <link href="RJ-2025-004_files/tippy-6.2.7/tippy.css" rel="stylesheet" />
  <link href="RJ-2025-004_files/tippy-6.2.7/tippy-light-border.css" rel="stylesheet" />
  <script src="RJ-2025-004_files/tippy-6.2.7/tippy.umd.min.js"></script>
  <script src="RJ-2025-004_files/anchor-4.2.2/anchor.min.js"></script>
  <script src="RJ-2025-004_files/bowser-1.9.3/bowser.min.js"></script>
  <script src="RJ-2025-004_files/webcomponents-2.0.0/webcomponents.js"></script>
  <script src="RJ-2025-004_files/distill-2.2.21/template.v2.js"></script>
  <!--radix_placeholder_site_in_header-->
  <!--/radix_placeholder_site_in_header-->
  <script>
    $(function() {
      console.log("Starting...")

      // Mathjax config (add automatic linebreaks when supported)
      // MathJax = {
      //    tex: {
      //        inlineMath: [['$', '$'], ['\\(', '\\)']],
      //        displayMath: [['$$', '$$'], ['\\[', '\\]']],
      //        tags: 'ams',
      //        multline: true,
      //    },
      //    options: {
      //        linebreaks: { automatic: true },
      //    },
      // };

      // Always show Published - distill hides it if not set
      function show_byline_column(caption) {
        $('d-byline').find('h3:contains("' + caption + '")').parent().css('visibility', 'visible');
      }

      show_byline_column('Published')

      // tweak function
      var rmd_meta = JSON.parse($("#radix-rmarkdown-metadata").html());
      function get_meta(name, meta) {
        var ind = meta.attributes.names.value.findIndex((e) => e == name)
        var val = meta.value[ind]
        if (val.type != 'list') {
          return val.value.toString()
        }
        return val
      }

      // tweak description
      // Add clickable tags
      const slug = get_meta('slug', rmd_meta)
      const cite_url = get_meta('citation_url', rmd_meta)

      var title = $("d-title").text

      const buttons = $('<div class="dt-tags" style="grid-column: page;">')
      buttons.append('<a href="#citation" class="dt-tag"><i class="fas fa-quote-left"></i> Cite</a>')
      buttons.append('<a href="' + slug + '.pdf" class="dt-tag"><i class="fas fa-file-pdf"></i> PDF</a>')
      
      // Conditionally add supplementary files button
      if (document.getElementById('supplementary-materials')) {
        // create element safely
        const btn_suppl = document.createElement('a');
        btn_suppl.href = slug + '.zip';
        btn_suppl.className = 'dt-tag';
        btn_suppl.innerHTML = '<i class="fas fa-file-zipper"></i> Supplement';
        buttons.append(btn_suppl);
      }

      // adds Abstract: in front of the first <p> in the title section --
      // unless it happens to be the subtitle (FIXME: this is a bad hack - can't distill do this?)
      var tpar = $("d-title p:not(:empty)").filter(function() {
        return !$(this).hasClass("subtitle");
      }).first();
      if (tpar) {
        const abstract = $('<d-abstract>')
        abstract.append('<b>Abstract:</b><br>')
        abstract.append(tpar) // Move description to d-abstract
        $("d-title p:empty").remove() // Remove empty paragraphs after title
        abstract.append(buttons)
        abstract.insertAfter($('d-title')) // Add abstract section after title */
      }

      // tweak by-line
      var byline = $("d-byline div.byline")
      ind = rmd_meta.attributes.names.value.findIndex((e) => e == "journal")
      const journal = get_meta('journal', rmd_meta)
      const volume = get_meta('volume', rmd_meta)
      const issue = get_meta('issue', rmd_meta)
      const jrtitle = get_meta('title', journal)
      const year = ((jrtitle == "R News") ? 2000 : 2008) + parseInt(volume)
      const firstpage = get_meta('firstpage', journal)
      const lastpage = get_meta('lastpage', journal)
      byline.append('<div class="rjournal grid">')
      $('div.rjournal').append('<h3>Volume</h3>')
      $('div.rjournal').append('<h3>Pages</h3>')
      $('div.rjournal').append('<a class="volume" href="../../issues/'+year+'-'+issue+'">'+volume+'/'+issue+'</a>')
      $('div.rjournal').append('<p class="pages">'+firstpage+' - '+lastpage+'</p>')

      const received_date = new Date(get_meta('date_received', rmd_meta))
      byline.find('h3:contains("Published")').parent().append('<h3>Received</h3><p>'+received_date.toLocaleDateString('en-US', {month: 'short'})+' '+received_date.getDate()+', '+received_date.getFullYear()+'</p>')

    })
  </script>

  <style>
      /*
    .nav-dropdown-content .nav-dropdown-header {
      text-transform: lowercase;
    }
    */

    d-byline .byline {
      grid-template-columns: 2fr 2fr 2fr 2fr;
    }

    d-byline .rjournal {
      grid-column-end: span 2;
      grid-template-columns: 1fr 1fr;
      margin-bottom: 0;
    }

    d-title h1, d-title p, d-title figure,
    d-abstract p, d-abstract b {
      grid-column: page;
    }

    d-title .dt-tags {
      grid-column: page;
    }

    .dt-tags .dt-tag {
      text-transform: lowercase;
    }

    d-article h1 {
      line-height: 1.1em;
    }

    d-abstract p, d-article p {
      text-align: justify;
    }

    @media(min-width: 1000px) {
      .d-contents.d-contents-float {
        justify-self: end;
      }

      nav.toc {
        border-right: 1px solid rgba(0, 0, 0, 0.1);
        border-right-width: 1px;
        border-right-style: solid;
        border-right-color: rgba(0, 0, 0, 0.1);
      }
    }

    .posts-list .dt-tags .dt-tag {
      text-transform: lowercase;
    }

    @keyframes highlight-target {
      0% {
        background-color: #ffa;
      }
      66% {
        background-color: #ffa;
      }
      100% {
        background-color: none;
      }
    }

    d-article :target, d-appendix :target {
       animation: highlight-target 3s;
    }

    .header-section-number {
      margin-right: 0.5em;
    }
    
    d-appendix .citation-appendix,
    .d-appendix .citation-appendix {
      color: rgb(60, 60, 60);
    }

    d-article h2 {
      border-bottom: 0px solid rgba(0, 0, 0, 0.1);
      padding-bottom: 0rem;
    }
    d-article h3 {
      font-size: 20px;
    }
    d-article h4 {
      font-size: 18px;
      text-transform: none;
    }

    @media (min-width: 1024px) {
      d-article h2 {
        font-size: 32px;
      }
      d-article h3 {
        font-size: 24px;
      }
      d-article h4 {
        font-size: 20px;
      }
    }
  </style>


</head>

<body>

<!--radix_placeholder_front_matter-->

<script id="distill-front-matter" type="text/json">
{"title":"spheresmooth: An R Package for Penalized Piecewise Geodesic Curve Fitting on a Sphere","description":"This paper introduces an R package \\CRANpkg{spheresmooth}, which implements a penalized piecewise geodesic curve fitting method on a sphere. Spherical data observed over a continuum arise frequently in various fields including cardiology, computer vision, physiology, and geophysics. We propose an adaptive smoothing method by extending the linear spline approach to spherical data. Penalization based on differences of velocity vectors endows sparsity among control points of the spherical curve, which enables data-adaptive curve fitting. The proposed method is implemented with a Riemannian block coordinate descent algorithm. Illustrations on Triassic and Jurassic polar wander data and tropical cyclone data demonstrate practicality of the proposed method and the associated \\CRANpkg{spheresmooth} package.","doi":"10.32614/RJ-2025-004","authors":[{"author":"Jae-Hwan Jhong","authorURL":"#","affiliation":"ChungBuk National University","affiliationURL":"#","orcidID":"0000-0003-2266-4986"},{"author":"Seyoung Lee","authorURL":"#","affiliation":"Sungshin Women's University","affiliationURL":"#","orcidID":""},{"author":"Ja-Yong Koo","authorURL":"#","affiliation":"Korea University","affiliationURL":"#","orcidID":""},{"author":"Kwan-Young Bak","authorURL":"#","affiliation":"Sungshin Women's University","affiliationURL":"#","orcidID":"0000-0002-4541-160X"}],"publishedDate":"2025-08-07T00:00:00.000+10:00","citationText":"Jhong, et al., 2025"}
</script>

<!--/radix_placeholder_front_matter-->
<!--radix_placeholder_navigation_before_body-->
<!--/radix_placeholder_navigation_before_body-->
<!--radix_placeholder_site_before_body-->
<!--/radix_placeholder_site_before_body-->

<div class="d-title">
<h1>spheresmooth: An R Package for Penalized Piecewise Geodesic Curve Fitting on a Sphere</h1>

<!--radix_placeholder_categories-->
<!--/radix_placeholder_categories-->
<p><p>This paper introduces an R package <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a>, which implements a penalized piecewise geodesic curve fitting method on a sphere. Spherical data observed over a continuum arise frequently in various fields including cardiology, computer vision, physiology, and geophysics. We propose an adaptive smoothing method by extending the linear spline approach to spherical data. Penalization based on differences of velocity vectors endows sparsity among control points of the spherical curve, which enables data-adaptive curve fitting. The proposed method is implemented with a Riemannian block coordinate descent algorithm. Illustrations on Triassic and Jurassic polar wander data and tropical cyclone data demonstrate practicality of the proposed method and the associated <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package.</p></p>
</div>

<div class="d-byline">
  Jae-Hwan Jhong  (ChungBuk National University)
  
,   Seyoung Lee  (Sungshin Women’s University)
  
,   Ja-Yong Koo  (Korea University)
  
,   Kwan-Young Bak  (Sungshin Women’s University)
  
<br/>2025-08-07
</div>

<div class="d-article">
<h2 data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>This paper aims to introduce an R package <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a>, which implements a penalization method for fitting piecewise geodesic curves to spherical data. Spherical data observed over a continuum arise frequently in various fields including cardiology, computer vision, physiology, and geophysics; see, for example, <span class="citation" data-cites="gould1969regression">Gould (<a href="#ref-gould1969regression" role="doc-biblioref">1969</a>)</span>, <span class="citation" data-cites="jupp1987fitting">Jupp and Kent (<a href="#ref-jupp1987fitting" role="doc-biblioref">1987</a>)</span>, <span class="citation" data-cites="kume2007shape">Kume et al. (<a href="#ref-kume2007shape" role="doc-biblioref">2007</a>)</span>, <span class="citation" data-cites="su2012fitting">Su et al. (<a href="#ref-su2012fitting" role="doc-biblioref">2012</a>)</span>, <span class="citation" data-cites="thompson1982robust">Thompson and Clark (<a href="#ref-thompson1982robust" role="doc-biblioref">1982</a>)</span>, and the references therein. We propose an adaptive curve fitting method based on sparsity-inducing penalization, and develop an R package to enable researchers from various fields to easily utilize it for their applications.</p>
<p>Smoothing methods for data observed on a manifold can be broadly categorized into two categories. The methods falling into the first category utilize conventional techniques applied to Euclidean data after mapping the data to the tangent space. Examples include the smoothing spline method based on the rolling and wrapping procedures introduced by <span class="citation" data-cites="jupp1987fitting">Jupp and Kent (<a href="#ref-jupp1987fitting" role="doc-biblioref">1987</a>)</span> and related works employing parallel transport as in <span class="citation" data-cites="kume2007shape">Kume et al. (<a href="#ref-kume2007shape" role="doc-biblioref">2007</a>)</span> and <span class="citation" data-cites="kim2021smoothing">Kim et al. (<a href="#ref-kim2021smoothing" role="doc-biblioref">2021</a>)</span>. The second category involves performing intrinsic optimization on the manifold without explicitly mapping the data to a plane. Approaches based on variational calculus with regularizing constraints fall into this category; for details, refer to <span class="citation" data-cites="camarinha1995splines">Camarinha et al. (<a href="#ref-camarinha1995splines" role="doc-biblioref">1995</a>)</span>, <span class="citation" data-cites="noakes1989cubic">Noakes et al. (<a href="#ref-noakes1989cubic" role="doc-biblioref">1989</a>)</span>, <span class="citation" data-cites="samir2012gradient">Samir et al. (<a href="#ref-samir2012gradient" role="doc-biblioref">2012</a>)</span>, <span class="citation" data-cites="su2012fitting">Su et al. (<a href="#ref-su2012fitting" role="doc-biblioref">2012</a>)</span>, <span class="citation" data-cites="machado2006riemannian">Machado et al. (<a href="#ref-machado2006riemannian" role="doc-biblioref">2006</a>)</span>. More recently, <span class="citation" data-cites="bak2023intrinsic">Bak et al. (<a href="#ref-bak2023intrinsic" role="doc-biblioref">2023</a>)</span> introduced an intrinsic curve fitting method based on the generalized Bézier curve and a local penalization scheme on the unit sphere.</p>
<p>The penalized intrinsic Bézier curve fitting method proposed by <span class="citation" data-cites="bak2023intrinsic">Bak et al. (<a href="#ref-bak2023intrinsic" role="doc-biblioref">2023</a>)</span> has the advantage of adaptively detecting local trends in the data. Furthermore, it takes a form that is easily understandable for researchers in applied fields, akin to an extension of polynomial regression models to the sphere. Spherical spline smoothing methods provide a natural extension of Bézier curve-based approaches. By utilizing spherical splines, one can flexibly model local changes in the data without compromising the overall smoothness. Developing intrinsic spline methods for smoothing spherical data is expected to facilitate the easy understanding and analysis of intricate and dynamically changing patterns of spherical data.</p>
<p>Spherical coordinates and the analysis of spherical data are also highly relevant in astronomy. Many methods and tools for spherical data analysis have been developed and motivated by astronomical observations, such as the Cosmic Microwave Background (CMB) maps produced by the Wilkinson Microwave Anisotropy Probe (WMAP) and Planck satellites. The popular HEALPix (Hierarchical Equal Area isoLatitude Pixelization) scheme was specifically developed by astronomers for the analysis of CMB data from WMAP <span class="citation" data-cites="gorski2005healpix">(<a href="#ref-gorski2005healpix" role="doc-biblioref">Górski et al. 2005</a>)</span>. Such tools have been foundational in handling all-sky observations and have inspired further developments in the field of spherical data analysis. The methods introduced in this paper can be viewed as contributing to this broader context of spherical data applications in fields including astronomy.</p>
<p>In this paper, we consider an intrinsic curve fitting method based on the piecewise geodesic curve and a local penalization scheme on a sphere. The proposed method can be understood as an extension of the linear spline method for spherical data. The performance of the spline-type method is determined by the number and location of the control points. We develop a penalization scheme based on the velocity of the curve to ensure sparsity among the corresponding control points. This allows for the data-adaptive selection of the control points, which guarantees that the curve fits the given spherical data well and identifies the change points on the sphere. The proposed method is implemented with a Riemannian block coordinate descent algorithm.</p>
<p>To the best of our knowledge, no available R packages offer methods for fitting a smooth path to a given set of noisy spherical data observed at known times. We introduce the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package that implements the proposed piecewise geodesic curve fitting method. This package includes a main function for smoothing spherical data along with several auxiliary functions necessary for data processing. The usages of these functions are explained with examples in detail. Piecewise geodesic curves can be understood as piecewise linear methods on manifolds, making them intuitive and easily applicable for researchers in various fields. Moreover, all processes including the selection of complexity parameters are automatically handled so that users can readily apply the method to data even in exploratory stages. To illustrate the practical utility of the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package, we provide examples of applying the proposed methodology to Triassic and Jurassic polar wander data for North America <span class="citation" data-cites="kent2010influence">(<a href="#ref-kent2010influence" role="doc-biblioref">Kent and Irving 2010</a>)</span> and tropical cyclone data provided by the Regional Specialized Meteorological Center (RSMC) Tokyo Typhoon Center.</p>
<p>Visualization of the generated curve requires loading <a href="https://cran.r-project.org/package=sphereplot">sphereplot</a> <span class="citation" data-cites="sphereplot-ref">(<a href="#ref-sphereplot-ref" role="doc-biblioref">Robotham 2022</a>)</span>, which includes the packages <a href="https://cran.r-project.org/package=rgl">rgl</a> <span class="citation" data-cites="rgl-ref">(<a href="#ref-rgl-ref" role="doc-biblioref">Murdoch and Adler 2024</a>)</span>. These packages are used for generating and manipulating 3D graphics for spherical data. To visualize the fitted curve on a map, we load the packages <a href="https://cran.r-project.org/package=rworldmap">rworldmap</a> <span class="citation" data-cites="rworldmap-ref">(<a href="#ref-rworldmap-ref" role="doc-biblioref">South 2011</a>)</span> and <a href="https://cran.r-project.org/package=ggplot2">ggplot2</a> <span class="citation" data-cites="ggplot2-ref">(<a href="#ref-ggplot2-ref" role="doc-biblioref">Wickham 2016</a>)</span>.
The <a href="https://cran.r-project.org/package=sf">sf</a> package provides a standardized and efficient way to handle spatial data using simple features, making it easy to perform geographic operations and analyses within the R environment.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='kw'><a href='https://rdrr.io/r/base/library.html'>library</a></span><span class='op'>(</span><span class='va'><a href='https://kybak90.github.io/spheresmooth/'>spheresmooth</a></span><span class='op'>)</span></span>
<span><span class='kw'><a href='https://rdrr.io/r/base/library.html'>library</a></span><span class='op'>(</span><span class='va'>sphereplot</span><span class='op'>)</span></span>
<span><span class='kw'><a href='https://rdrr.io/r/base/library.html'>library</a></span><span class='op'>(</span><span class='va'><a href='https://github.com/AndySouth/rworldmap/'>rworldmap</a></span><span class='op'>)</span></span>
<span><span class='kw'><a href='https://rdrr.io/r/base/library.html'>library</a></span><span class='op'>(</span><span class='va'><a href='https://ggplot2.tidyverse.org'>ggplot2</a></span><span class='op'>)</span></span>
<span><span class='kw'><a href='https://rdrr.io/r/base/library.html'>library</a></span><span class='op'>(</span><span class='va'><a href='https://r-spatial.github.io/sf/'>sf</a></span><span class='op'>)</span></span></code></pre>
</div>
</div>
<p>The remainder of this paper is organized as follows. <a href="#prelim">Section 2</a> collects mathematical preliminaries related to the spherical geometry. <a href="#ppgc">Section 3</a> defines the penalized piecewise curve fitting method and summarizes the implementation scheme based on the Riemannian block coordinate descent algorithm. <a href="#package">Section 4</a> outlines the structure and usage of the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package, followed by practical application examples in <a href="#application">Section 5</a>. <a href="#conclusion">Section 6</a> provides a summary of the results presented in this paper.</p>
<h2 data-number="2" id="prelim"><span class="header-section-number">2</span> Preliminaries</h2>
<p>This section reviews some basic concepts of Riemannian geometry used in this paper. One may refer to, for example, <span class="citation" data-cites="carmo1976differential">Carmo (<a href="#ref-carmo1976differential" role="doc-biblioref">1976</a>)</span> and <span class="citation" data-cites="carmo1992riemannian">Carmo (<a href="#ref-carmo1992riemannian" role="doc-biblioref">1992</a>)</span> for a detailed overview of the relevant mathematical backgrounds.</p>
<h3 class="unnumbered" id="spherical-distance-and-geodesic-segment">Spherical distance and geodesic segment</h3>
<p>In this work, the term ‘geodesic segment’ is equivalent to a ‘great circle segment’ on a sphere. This distinction is made due to differences in terminology preferences across various academic disciplines.</p>
<p>Let <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> be points on the unit sphere and <span class="math inline">\(\theta, 0\leq\theta\leq\pi\)</span>, be the angle formed by <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> relative to the origin of the sphere. Define the spherical distance between two points <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> as
<span class="math display">\[\text{d}(u, v) = \arccos(u^{\top}v).\]</span>
Observe <span class="math inline">\(\text{d}(u, v) = \theta\)</span> on the unit sphere.</p>
<p>Let <span class="math inline">\(\mathbb{S}\)</span> be the two-dimensional unit sphere embedded in <span class="math inline">\(\mathbb{R}^3\)</span>.
A geodesic segment <span class="math inline">\(\alpha: I = [0, 1] \rightarrow \mathbb{S}\)</span> between two points <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> on <span class="math inline">\(\mathbb{S}\)</span> is defined as
<span class="math display">\[
\alpha(t; u, v) =
\frac{\sin((1-t)\theta)}{\sin(\theta)}u
+ \frac{\sin(t \theta)}{\sin(\theta)}v,\quad t \in I
\]</span>
where <span class="math inline">\(\theta = \text{d}(u, v)\)</span>. Figure <a href="#fig:dist-geodesic">1</a> illustrates a geodesic segment between <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> on <span class="math inline">\(\mathbb{S}\)</span> in the red line. Here, the length of the red line represents the spherical distance between <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:dist-geodesic"></span>
<img src="figures/geodesic_dist.png" alt="Illustration of geodesic segment between $u$ and $v$ and spherical distance." width="40%" />
<p class="caption">
Figure 1: Illustration of geodesic segment between <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> and spherical distance.
</p>
</div>
</div>
<h3 class="unnumbered" id="piecewise-geodesic-curve">Piecewise geodesic curve</h3>
<p>The methodology proposed in this paper aims to fit a linear spherical spline or piecewise geodesic curve to spherical data observed over time in a data-adaptive way. To define a piecewise geodesic curve, the time interval needs to be divided into subintervals, and corresponding control points on the sphere should be determined. Given a time interval <span class="math inline">\(I\)</span>, we consider a sequence of knots <span class="math inline">\(\tau_0 &lt; \tau_1 &lt; \tau_2 &lt; \dots &lt; \tau_J\)</span> that defines subintervals
<span class="math display">\[
I_0 = [\tau_0, \tau_1), \quad
I_1 = [\tau_1, \tau_2),\quad  \cdots \quad , \quad I_{J-1} = [\tau_{J-1}, \tau_J).
\]</span>
Let <span class="math inline">\(\xi = (\xi_0,\ldots, \xi_J)\)</span> be a set of control points in <span class="math inline">\(\mathbb{S}\)</span> corresponding to the knot sequence <span class="math inline">\(\tau_1, \ldots, \tau_J\)</span>. The associated piecewise geodesic (linear spherical spline) curve is defined as
<span class="math display">\[
\gamma(t;\xi_1, \ldots, \xi_J) = \sum_{j=0}^{J-1}\alpha\left(\dfrac{t-\tau_j}{\tau_{j+1}-\tau_j}; \xi_j, \xi_{j+1}\right) \mathsf{ind}(t\in I_j),
\]</span>
where <span class="math inline">\(\mathsf{ind}(\cdot)\)</span> denotes the indicator function.
The sequence of points on the sphere need not necessarily correspond to different time instances.
Rather, they represent a collection of spatial locations that may or may not be observed sequentially in time.
This is further discussed in Section 4.</p>
<h3 class="unnumbered" id="riemannian-gradient-and-exponential-map">Riemannian gradient and exponential map</h3>
<p>A blockwise gradient descent algorithm is employed as the algorithm for implementing the spherical smoothing method. The key elements in deriving the algorithm are the Riemannian gradient and the exponential map. The Riemannian gradient is a projection of the Euclidean gradient onto the tangent space. Define the Euclidean gradient as
<span class="math display">\[
\partial_x \bar{h}(x) = \left[ \frac{\partial\bar{h}(x)}{x_j}(x) \right] \quad \text{for} \quad x \in \mathbb{S}, \quad j \leq J
\]</span>
where <span class="math inline">\(h:\mathbb{S} \to \mathbb{R}\)</span> and <span class="math inline">\(\bar{h}\)</span> is a differentiable extension of <span class="math inline">\(h\)</span> to <span class="math inline">\(\mathbb{R}^3\)</span>. Denote <span class="math inline">\(P_x = I - xx^\top\)</span> as a projection operation onto the tangent space at <span class="math inline">\(x\)</span>. The Riemannian gradient of <span class="math inline">\(h\)</span> with respect to <span class="math inline">\(x\)</span> is defined as
<span class="math display">\[
\mathsf{grad}_x h(x) = P_x \partial_x \bar{h}(x).
\]</span></p>
<p>The exponential map is a map from a subset of a tangent space <span class="math inline">\(T_u(\mathbb{S})\)</span>, <span class="math inline">\(u \in \mathbb{S}\)</span> to <span class="math inline">\(\mathbb {S}\)</span> itself.
If <span class="math inline">\(w \in T_u(\mathbb{S})\)</span> is a nonzero vector, a point on <span class="math inline">\(\mathbb{S}\)</span> corresponding to <span class="math inline">\(w\)</span> is denoted as <span class="math inline">\(\mathsf{Exp}_u(w)\)</span>. When <span class="math inline">\(w = 0\)</span>, then <span class="math inline">\(\mathsf{Exp}_u(w) = u\)</span>. The exponential map is a distance-preserving map in the sense that <span class="math inline">\(\vert{u-w}\vert = d(u, \mathsf{Exp}_u(w))\)</span> for <span class="math inline">\(u, w \in \mathbb{S}\)</span>, where <span class="math inline">\(\vert{\cdot}\vert\)</span> is the Euclidean <span class="math inline">\(\ell_2\)</span> norm. Figure <a href="#fig:riemann">2</a> illustrates the Riemannian gradient and exponential map.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:riemann"></span>
<img src="figures/Riemannian_grad.png" alt="Illustration of (left) Riemannian gradient and (right) exponential map." width="49%" /><img src="figures/exponential_map.png" alt="Illustration of (left) Riemannian gradient and (right) exponential map." width="49%" />
<p class="caption">
Figure 2: Illustration of (left) Riemannian gradient and (right) exponential map.
</p>
</div>
</div>
<h2 data-number="3" id="ppgc"><span class="header-section-number">3</span> Penalized piecewise geodesic curve fitting</h2>
<h3 class="unnumbered" id="penalized-piecewise-geodesic-curve">Penalized piecewise geodesic curve</h3>
<p>Let <span class="math inline">\(\{(t_n, y_n)\}_{n=1}^N\)</span> be a set of data, where <span class="math inline">\(t_n \in I\)</span> are the given time points and <span class="math inline">\(y_n\)</span> are the associated data points on <span class="math inline">\(\mathbb{S}\)</span>. Our goal is to find a piecewise geodesic curve that fits the data well. To this end, we adopt the squared distance loss function
<span class="math display">\[
\ell(\xi) = \sum_{n = 1}^N d^2(y_n, \gamma(t_n; \xi)) \quad \text{for} \quad \xi \in \mathbb{S}^{J+1}
\]</span>
where <span class="math inline">\(\mathbb{S}^{J+1}\)</span> is the <span class="math inline">\(J+1\)</span> product of <span class="math inline">\(\mathbb{S}\)</span>.</p>
<p>The most important aspect of fitting a piecewise curve is selecting the appropriate number of pieces. The number of pieces is determined by the number of knots and the corresponding control points. To avoid the issues of oversmoothing and undersmoothing, we propose a penalty function that allows us to select the number of control points in a data-adaptive way. This enables the fitted spherical curve to capture local trends in the data without compromising the overall smoothness. We introduce a smoothness penalty function
<span class="math display">\[
\mathsf{p}(\xi)
=
\sum_{j=1}^{J-1}
\lvert D_j(\xi) \rvert \quad \text{for} \quad D_j(\xi) = \frac{1}{\tau_{j+1} - \tau_j} \dot{\alpha}(0; \xi_j, \xi_{j+1}) - \frac{1}{\tau_j - \tau_{j-1}} \dot{\alpha}(1; \xi_{j-1}, \xi_j),
\]</span>
which regularizes the number of geodesic segments needed to fit the data. Here, <span class="math inline">\(\cdot\)</span> above a curve denotes its derivative with respect to <span class="math inline">\(t\)</span> and <span class="math inline">\(|\cdot|\)</span> denotes the Euclidean <span class="math inline">\(\ell_2\)</span>-norm of a vector.</p>
<p>The velocity-based penalty function induces sparsity on the control points. As <span class="math inline">\(\lambda\)</span> increases, the difference <span class="math inline">\(\lvert D_j(\xi) \rvert\)</span> in the penalty term tends to zero.
Suppose that <span class="math inline">\(\lvert D_j(\xi) \rvert = 0\)</span> for some <span class="math inline">\(1 \le j \le J-1\)</span> and <span class="math inline">\(\lambda\)</span>. This implies that the geodesic segments <span class="math inline">\(\alpha(\cdot; \xi_{j-1}, \xi_j)\)</span> and <span class="math inline">\(\alpha(\cdot; \xi_j, \xi_{j+1})\)</span> are on the same great circle. Then, we eliminate the inactive control point <span class="math inline">\(\xi_j\)</span> and replace the two geodesic segments with <span class="math inline">\(\alpha(\cdot; \xi_{j-1}, \xi_{j+1})\)</span>. The elimination process reduces the number of the control points by one. Figure <a href="#fig:elimination">3</a> illustrates the elimination process that starts with two geodesic segments.</p>
<p>The objective function to minimize is given by
<span class="math display">\[
\ell^\lambda(\xi) = \ell(\xi) + \lambda\mathsf{p}(\xi) \quad \text{for} \quad \xi \in \mathbb{S}^{J+1},
\]</span>
where <span class="math inline">\(\lambda &gt; 0\)</span> is the complexity parameter.
For a fixed <span class="math inline">\(\lambda\)</span>, the penalized piecewise geodesic (linear spherical spline) curve is defined as
<span class="math display">\[
\gamma_J(\cdot;\hat{\xi}_\lambda),
\]</span>
where
<span class="math display">\[
\hat{\xi}_\lambda = \underset{\xi \in \mathbb{S}^J}{\operatorname{argmin}} \ell^\lambda(\xi).
\]</span></p>
<div class="layout-chunk" data-layout="l-body">
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:elimination"></span>
<img src="figures/penalized_geo2.png" alt="Example of elimination process of the piecewise geodesic curve with three control points. Blue arrow vector indicates tangent vector of $\xi_2$ in consecutive geodesic segments. The left plot shows the spline curve with small value of complexity parameter. As the complexity parameter $\lambda$ increases, $\xi_2$ moves into the geodesic between $\xi_1$ and $\xi_3$ and the difference between tangent vectors becomes zero. The middle plot shows that step. When the difference between tangent vectors is zero, control point is removed. The right plot shows the resulting curve after control point is removed in the middle plot." width="33%" /><img src="figures/penalized_geo2_1.png" alt="Example of elimination process of the piecewise geodesic curve with three control points. Blue arrow vector indicates tangent vector of $\xi_2$ in consecutive geodesic segments. The left plot shows the spline curve with small value of complexity parameter. As the complexity parameter $\lambda$ increases, $\xi_2$ moves into the geodesic between $\xi_1$ and $\xi_3$ and the difference between tangent vectors becomes zero. The middle plot shows that step. When the difference between tangent vectors is zero, control point is removed. The right plot shows the resulting curve after control point is removed in the middle plot." width="33%" /><img src="figures/penalized_geo.png" alt="Example of elimination process of the piecewise geodesic curve with three control points. Blue arrow vector indicates tangent vector of $\xi_2$ in consecutive geodesic segments. The left plot shows the spline curve with small value of complexity parameter. As the complexity parameter $\lambda$ increases, $\xi_2$ moves into the geodesic between $\xi_1$ and $\xi_3$ and the difference between tangent vectors becomes zero. The middle plot shows that step. When the difference between tangent vectors is zero, control point is removed. The right plot shows the resulting curve after control point is removed in the middle plot." width="33%" />
<p class="caption">
Figure 3: Example of elimination process of the piecewise geodesic curve with three control points. Blue arrow vector indicates tangent vector of <span class="math inline">\(\xi_2\)</span> in consecutive geodesic segments. The left plot shows the spline curve with small value of complexity parameter. As the complexity parameter <span class="math inline">\(\lambda\)</span> increases, <span class="math inline">\(\xi_2\)</span> moves into the geodesic between <span class="math inline">\(\xi_1\)</span> and <span class="math inline">\(\xi_3\)</span> and the difference between tangent vectors becomes zero. The middle plot shows that step. When the difference between tangent vectors is zero, control point is removed. The right plot shows the resulting curve after control point is removed in the middle plot.
</p>
</div>
</div>
<h3 class="unnumbered" id="block-coordinate-descent-algorithm">Block coordinate descent algorithm</h3>
<p>To obtain <span class="math inline">\(\hat{\xi}_\lambda\)</span>, we adopt a block coordinate descent method, where each block consists of the three-dimensional coordinates of each control point.
First, we set the initial values of <span class="math inline">\(\xi\)</span> by <span class="math inline">\(J+1\)</span> number of data points <span class="math inline">\(y_n\)</span> associated with quantiles of the time points <span class="math inline">\(t_n\)</span> for <span class="math inline">\(j=0,1,\ldots, J\)</span>. Denote the initial values by <span class="math inline">\(\xi^{(0)} = (\xi^{(0)}_0, \ldots, \xi^{(0)}_J)\)</span>. Then, we obtain the Riemannian gradient of <span class="math inline">\(\ell^\lambda\)</span> with respect to <span class="math inline">\(\xi_j\)</span> and apply the gradient descent algorithm to update the control points. Since the updated points belong to a tangent space of <span class="math inline">\(\mathbb{S}\)</span>, we apply the exponential function to map the points into <span class="math inline">\(\mathbb{S}\)</span>.</p>
<p>Let <span class="math inline">\(\xi_j^{(l)}\)</span> denote the current values of the control point <span class="math inline">\(\xi_j\)</span> in the <span class="math inline">\(l\)</span>-th iteration for <span class="math inline">\(j=0,\ldots, J\)</span>. For <span class="math inline">\(l=1,2,\cdots\)</span>, the update formula has the following form:
<span class="math display">\[\begin{align*}
\xi_0^{(l)} &amp;\leftarrow \mathsf{Exp}_{\xi_0^{(l-1)}} \left[-\rho_{l, 0} \mathsf{grad}_{\xi_0} \ell^\lambda \left(\xi_0^{(l-1)}, \xi_1^{(l-1)}, \xi_2^{(l-1)}, \ldots, \xi_J^{(l-1)}\right) \right]
\\
\xi_1^{(l)} &amp;\leftarrow \mathsf{Exp}_{\xi_1^{(l-1)}} \left[-\rho_{l, 1} \mathsf{grad}_{\xi_1} \ell^\lambda \left(\xi_0^{(l)}, \xi_1^{(l-1)}, \xi_2^{(l-1)}, \ldots, \xi_J^{(l-1)}\right) \right]
\\
\xi_2^{(l)} &amp;\leftarrow \mathsf{Exp}_{\xi_2^{(l-1)}} \left[-\rho_{l, 2} \mathsf{grad}_{\xi_2} \ell^\lambda \left(\xi_0^{(l)}, \xi_1^{(l)}, \xi_2^{(l-1)}, \ldots, \xi_J^{(l-1)}\right) \right]
\\
&amp;\cdots
\\
\xi_J^{(l)} &amp;\leftarrow \mathsf{Exp}_{\xi_J^{(l-1)}} \left[-\rho_{l, J} \mathsf{grad}_{\xi_J} \ell^\lambda \left(\xi_0^{(l)}, \xi_1^{(l)}, \xi_2^{(l)}, \ldots, \xi_J^{(l-1)}\right) \right],
\end{align*}\]</span>
where <span class="math inline">\(\rho_{l,j}\)</span> denotes a specified step size for the update of <span class="math inline">\(\xi_j\)</span> in the <span class="math inline">\(l\)</span>th cycle. The specific form of the update formula is derived below.</p>
<p>As a line search strategy, we adopt the step-halving method to determine the step size <span class="math inline">\(\rho_{l,j}\)</span> to guarantee the stable convergence of the proposed algorithm.
When the objective function does not decrease with the current step size, the step size is halved. The step-halving procedure is repeated until the objective function decreases with the reduced step size. The iteration stops when the difference between the current and
the updated values of the objective function <span class="math inline">\(\ell^\lambda\)</span> is less than <span class="math inline">\(\varepsilon = 10^{-5}\)</span>.</p>
<h3 class="unnumbered" id="derivation-of-the-coordinate-wise-update-formula">Derivation of the coordinate-wise update formula</h3>
<p>The derivation of the update formula is based on the result in <span class="citation" data-cites="bak2023intrinsic">Bak et al. (<a href="#ref-bak2023intrinsic" role="doc-biblioref">2023</a>)</span>.
For notational convenience, denote
<span class="math display">\[
C(z) = \cos(z), \quad S(z) = \sin(z) \quad \text{and} \quad R_s(z) = \frac{S(sz)}{S(z)}
\]</span>
for <span class="math inline">\(s \in I\)</span> and <span class="math inline">\(z \in \mathbb{R}\)</span>. With this notation, the parametrized geodesic segment between control points <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> is expressed as
<span class="math display">\[
\alpha(t; u, v) = R_{1-t} (\theta) u + R_t(\theta) v,
\quad t \in I,
\]</span>
with <span class="math inline">\(\theta = \text{d}(u, v)\)</span>.
We first obtain the Euclidean derivative of the geodesic segment with respect to each endpoint.</p>
<p>Theorem 3.1 in <span class="citation" data-cites="bak2023intrinsic">Bak et al. (<a href="#ref-bak2023intrinsic" role="doc-biblioref">2023</a>)</span> implies that the derivatives of <span class="math inline">\(\alpha\)</span> with respect to the control points are given by
<span class="math display">\[
\left(\frac{d}{du} \gamma(t; u, v) \right)^\top
=
R_{1-t}(\theta) I + Q_{1-t}(\theta) v u^\top + Q_t(\theta) v v^\top,
\]</span>
and
<span class="math display">\[
\left(\frac{d}{dv} \gamma(t; u, v) \right)^\top
=
R_{t}(\theta) I + Q_{1-t}(\theta) u u^\top + Q_t(\theta) u v^\top,
\]</span>
where
<span class="math display">\[
Q_s(z)
\triangleq
\frac{S_s(z) C(z) - s C_s(z) S(z)}{S^3 (z)}
\quad \text{for} \quad s \in I \quad \text{and} \quad z \in \mathbb{R}
.
\]</span></p>
<p>Consider now a piecewise geodesic curve <span class="math inline">\(\gamma(\cdot, \xi)\)</span> defined by a set of control points <span class="math inline">\(\xi = (\xi_1, \ldots, \xi_J)\)</span>.
Since the spline curve consists of connected geodesic segments, we have
<span class="math display">\[
\frac{d}{d \xi_j} \gamma(t;\xi) =
\begin{cases}
\frac{d}{d \xi_0} \alpha\left(\frac{t - \tau_0}{\tau_{1} - \tau_0};\xi_0, \xi_1\right) \quad \text{for} \quad j = 0 \\
\frac{d}{d \xi_J} \alpha\left(\frac{t - \tau_{J-1}}{\tau_{J} - \tau_{J-1}};\xi_{J-1}, \xi_J\right)  \quad \text{for} \quad j = J \\
\frac{d}{d \xi_j} \alpha\left(\frac{t - \tau_{j-1}}{\tau_{j} - \tau_{j-1}};\xi_{j-1}, \xi_j\right)
+
\frac{d}{d \xi_j} \alpha\left(\frac{t - \tau_{j-1}}{\tau_{j} - \tau_{j-1}};\xi_{j}, \xi_{j+1}\right) &amp; \text{o.w.}
\end{cases}
\]</span>
Combining the results, we are able to obtain the derivatives of <span class="math inline">\(\gamma(\cdot, \xi)\)</span> with respect to each control point. This enables us to compute the Riemannian gradient of the squared distance loss:
<span class="math display">\[
\textsf{grad}_{\xi_k} \ell(\xi)
=
- \sum_{n=1}^N \frac{\phi_n}{S(\phi_n)} P_{\xi_k} \left(\frac{d \gamma(t_n;\xi)}{d\xi_k}\right)^\top y_n,
\]</span>
where <span class="math inline">\(\phi_n \triangleq \mathsf{d}(y_n, \gamma(t_n; \xi))\)</span>.</p>
<p>In addition to the result above, the Riemannian gradient of the velocity difference penalty is needed to derive a coordinate-wise update formula. Following Theorem 3.4 in <span class="citation" data-cites="bak2023intrinsic">Bak et al. (<a href="#ref-bak2023intrinsic" role="doc-biblioref">2023</a>)</span>,
for a fixed <span class="math inline">\(1 \le j \le J-1\)</span>, we have
<span class="math display">\[\begin{align*}
\textsf{grad}_{\xi_{j-1}} \lvert D_j(\xi) \rvert
&amp;=
P_{\xi_{j-1}}
\frac{1}{\tau_j - \tau_{j-1}} \left[
\frac{C(\theta_{j-1})\theta_{j-1} - S(\theta_{j-1})}{S^3(\theta_{j-1})} \xi_j \xi_{j-1}^\top + \frac{\theta_{j-1}}{S(\theta_{j-1})} I
\right]
\frac{D_j (\xi)}{\lvert D_j (\xi) \rvert},
\\
\textsf{grad}_{\xi_{j+1}} \lvert D_j (\xi) \rvert
&amp;=
\frac{1}{\tau_{j+1} - \tau_j} P_{\xi_{j+1}}
\left[
\frac{C(\theta_j)\theta_j - S(\theta_j)}{S^3(\theta_j)} \xi_j \xi_{j+1}^\top + \frac{\theta_j}{S(\theta_j)} I
\right]
\frac{D_j (\xi)}{\lvert D_j (\xi) \rvert},
\end{align*}\]</span>
and
<span class="math display">\[\begin{align*}
\textsf{grad}_{\xi_j} \lvert D_j (\xi) \rvert
&amp;=
\frac{1}{\tau_{j+1} - \tau_j} P_{\xi_j} \left[\frac{C(\theta_j)\theta_j - S(\theta_j)}{S^3(\theta_j)} \xi_{j+1} \xi_{j+1}^\top - \frac{\theta_j C(\theta_j)}{S(\theta_j)} I\right]
\frac{D_j (\xi)}{\lvert D_j (\xi) \rvert}
\\
&amp; \hspace{-0.5cm} +
\frac{1}{\tau_j - \tau_{j-1}} P_{\xi_j} \left[
\frac{C(\theta_{j-1}) \theta_{j-1} - S(\theta_{j-1})}{S^3(\theta_{j-1})} \xi_{j-1} \xi_{j-1}^\top - \frac{\theta_{j-1} C(\theta_{j-1})}{S(\theta_{j-1})} I
\right]
\frac{D_j (\xi)}{\lvert D_j (\xi) \rvert}.
\end{align*}\]</span>
Combining the derivatives of the loss function and the penalty function yields the required Riemannian gradient of the objective function with respect to the control points.</p>
<h3 class="unnumbered" id="selection-of-optimal-tuning-parameter">Selection of optimal tuning parameter</h3>
<p>The procedure for finding the optimal complexity parameter is as follows. The piecewise geodesic curves that minimize the objective function are computed for an increasing sequence of the complexity parameters
<span class="math inline">\(\lambda_1 &lt; \cdots &lt; \lambda_K\)</span>, where <span class="math inline">\(\lambda_K\)</span> is sufficiently large. As the complexity parameter increases, we eliminate the control points that are no longer active.</p>
<p>In general, the choice of the control points plays a crucial role in the spline-type curve fitting problem. We begin by setting <span class="math inline">\(\lambda_K\)</span> to a sufficiently large value and <span class="math inline">\(\lambda_1\)</span> to a value close to zero, ensuring the flexibility of the model. As the complexity parameter increases, the elimination process leads to data-adaptive control point selection. Then, we determine the optimal complexity parameter and the corresponding optimal curve whose control points are adaptively determined by the given set of data.</p>
<p>To choose an optimal complexity parameter, we use a modified version of the Bayes information criterion (<span class="math inline">\(\text{BIC}\)</span>); see <span class="citation" data-cites="schwarz1978">Schwarz (<a href="#ref-schwarz1978" role="doc-biblioref">1978</a>)</span>. The <span class="math inline">\(\text{BIC}\)</span> for a sequence of the complexity parameters is defined as
<span class="math display">\[
\text{BIC}_k = N \log \ell(\hat{\xi}_{\lambda_k}) +
3 J_k \log N \quad \text{for} \quad k = 1, \ldots, K
\]</span>
where <span class="math inline">\(J_k\)</span> denotes the number of control points for <span class="math inline">\(\lambda_k\)</span>.
The optimal value for <span class="math inline">\(\lambda\)</span> is chosen as <span class="math inline">\(\lambda_{\hat{k}}\)</span>, where
<span class="math display">\[
\hat{k} = \underset{1 \le k \le K}{\operatorname{argmin}}  \text{BIC}_k.
\]</span></p>
<h2 data-number="4" id="package"><span class="header-section-number">4</span> The <code>spheresmooth</code> package: structure and functionality</h2>
<h3 class="unnumbered" id="overall-structure-and-available-functions">Overall structure and available functions</h3>
<p>The <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package is a versatile toolkit designed for performing mathematical and geometric operations on the sphere, with a primary focus on smoothing spherical data observed at known time points. It finds applications across various fields such as geography, geometry, physics, and computer graphics. Table <a href="#tab:pakcage-functions">1</a> contains a compact summary of the available functions. When the name of a function is in uppercase, it means it computes the output for multiple points simultaneously except for <code>exp_map()</code> function. The package includes a corresponding internal function for a single point calculation. For example, the <code>geodesic()</code> function computes the coordinates of a geodesic curve at multiple time points, which is the result of multiple internal executions of the <code>geodesic_lower()</code> function for a single time point. These functions take arguments in the form of numeric matrices.</p>
<p>Spherical data may be given in the form of spherical coordinates or Cartesian coordinates depending on the case. We may need to switch between the two coordinate systems as necessary. The <code>cartesian_to_spherical()</code> function converts Cartesian coordinates to spherical coordinates, which is crucial for representing points on a spherical surface accurately. The <code>spherical_to_cartesian()</code> function performs the opposite operation. The input data for the main function must be in the form of Cartesian coordinates. Therefore, if the data is given in spherical coordinates, one can use the <code>spherical_to_cartesian()</code> function to perform coordinate transformation before applying the proposed method.</p>
<p>The proposed method is based on the calculation of piecewise geodesic paths. To this end, we need functions that compute the geodesic segments and partition the given time interval. The <code>geodesic()</code> function computes the value of the geodesic curve connecting two points <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> on the sphere at specified time points. On the other hand, the <code>knots_quantile()</code> function generates a sequence of knots for a given set of time points based on the quantile values, thereby offering support for interpolating and approximating time-series data using spherical spline curves. The <code>piecewise_geodesic()</code> function is one of the core functions in the package. It computes the coordinates of the piecewise geodesic curve at the input time point for the given knots in the time interval and the corresponding control points on the sphere.</p>
<p>To evaluate the goodness-of-fit of the fitted curve, a distance-based loss function is needed. The <code>spherical_dist()</code> function calculates the geodesic distance between two input points. Based on this function, the <code>calculate_loss()</code> calculates the loss function based on the squared spherical distances between observed values and predicted values on the curve. Finally, the main function <code>penalized_linear_spherical_spline()</code> fits the penalized piecewise geodesic curve to the given data. In summary, the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package provides core functions for smoothing spherical data, along with several useful functions for handling spherical data.</p>
<div class="layout-chunk" data-layout="l-body">
<table>
<caption><span id="tab:pakcage-functions">Table 1: </span>Summary of the functions in the spheresmooth package.</caption>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">calculate_loss</td>
<td style="text-align: left;">Calculates the loss function based on the squared spherical distances between observed values and predicted values on the curve.</td>
</tr>
<tr class="even">
<td style="text-align: left;">cartesian_to_spherical</td>
<td style="text-align: left;">Converts Cartesian coordinates to spherical coordinates.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">cross</td>
<td style="text-align: left;">Computes the cross product of two input vectors</td>
</tr>
<tr class="even">
<td style="text-align: left;">dot</td>
<td style="text-align: left;">Computes the dot product of two input vectors <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">edp</td>
<td style="text-align: left;">Computes the equal-distance projection of a point <span class="math inline">\(p\)</span> onto the xy plane.</td>
</tr>
<tr class="even">
<td style="text-align: left;">exp_map</td>
<td style="text-align: left;">Computes the exponential map on the unit sphere given a base point <span class="math inline">\(x\)</span> and a vector <span class="math inline">\(v\)</span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">geodesic</td>
<td style="text-align: left;">Computes the value of the geodesic curve connecting two points <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> on the unit sphere at specified time points.</td>
</tr>
<tr class="even">
<td style="text-align: left;">knots_quantile</td>
<td style="text-align: left;">Generates a sequence of knots for a given set of time points based on the quantiles.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">norm2</td>
<td style="text-align: left;">Computes the L2 norm (Euclidean norm) of the input vector.</td>
</tr>
<tr class="even">
<td style="text-align: left;">normalize</td>
<td style="text-align: left;">Normalizes the rows of the input matrix <span class="math inline">\(x\)</span> by dividing each row by its L2 norm (Euclidean norm).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">penalized_linear_spherical_spline</td>
<td style="text-align: left;">Fits a penalized linear spherical spline (piecewise geodesic) curve to the given data.</td>
</tr>
<tr class="even">
<td style="text-align: left;">piecewise_geodesic</td>
<td style="text-align: left;">Computes a piecewise geodesic path between control points.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">spherical_dist</td>
<td style="text-align: left;">Calculates the spherical distance between two vectors.</td>
</tr>
<tr class="even">
<td style="text-align: left;">spherical_to_cartesian</td>
<td style="text-align: left;">converts spherical coordinates (<span class="math inline">\(\theta\)</span>, <span class="math inline">\(\phi\)</span>) to Cartesian coordinates.</td>
</tr>
</tbody>
</table>
</div>
<h3 class="unnumbered" id="basic-functions-for-handling-spherical-data">Basic functions for handling spherical data</h3>
<p>Before delving into the main functions of the package, we introduce several useful functions for handling spherical data within the package. These functions are essential for performing core functionalities of the package but can also be applied to other spherical data analysis tasks. Only a subset of the functions listed in Table <a href="#tab:pakcage-functions">1</a> is illustrated based on their frequency of use.</p>
<p>The <code>spherical_dist()</code> function is used to compute the geodesic distance between two points on the unit sphere. For example, the distance along the geodesic segment between <span class="math inline">\((1,0,0)\)</span> and <span class="math inline">\((0,1,0)\)</span> is one-fourth of the circumference of a great circle containing two points, which is <span class="math inline">\(2\pi\)</span>, and it is calculated as follows in code:</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>x</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>0</span>, <span class='fl'>0</span><span class='op'>)</span></span>
<span><span class='va'>y</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>1</span>, <span class='fl'>0</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/spherical_dist.html'>spherical_dist</a></span><span class='op'>(</span><span class='va'>x</span>, <span class='va'>y</span><span class='op'>)</span></span></code></pre>
</div>
<pre><code>[1] 1.570796</code></pre>
</div>
<p>Consider another example involving the point <span class="math inline">\((1/\sqrt{3}, 1/\sqrt{3}, 1/\sqrt{3})\)</span>. The antipodal point to this given point is <span class="math inline">\((-1/\sqrt{3}, -1/\sqrt{3}, -1/\sqrt{3})\)</span>, which traverses half the circumference of the associated great circle, resulting in a length of <span class="math inline">\(\pi\)</span>. This can be checked with the following code.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>x</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span><span class='op'>)</span></span>
<span><span class='va'>y</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='op'>-</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='op'>-</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='op'>-</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/spherical_dist.html'>spherical_dist</a></span><span class='op'>(</span><span class='va'>x</span>, <span class='va'>y</span><span class='op'>)</span></span></code></pre>
</div>
<pre><code>[1] 3.141593</code></pre>
</div>
<p>Another useful function is the <code>cross</code> function with <code>normalize = TRUE</code> argument used to obtain a unit vector orthogonal to a pair of given vectors. For example, we can use this function to obtain a unit vector <span class="math inline">\((0,0,1)\)</span> orthogonal to the plane spanned by <span class="math inline">\((1,0,0)\)</span> and <span class="math inline">\((0,1,0)\)</span>.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>x</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>0</span>, <span class='fl'>0</span><span class='op'>)</span></span>
<span><span class='va'>y</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>1</span>, <span class='fl'>0</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/cross.html'>cross</a></span><span class='op'>(</span><span class='va'>x</span>, <span class='va'>y</span>, normalize <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span></span></code></pre>
</div>
<pre><code>[1] 0 0 1</code></pre>
</div>
<p>Besides standard utility functions, there are two crucial auxiliary functions in spherical data analysis: <code>cartesian_to_spherical()</code> and <code>spherical_to_cartesian()</code>. These transformations have already been discussed earlier in this section. For basic spherical operations, it is utilized as described previously. When data is given in Cartesian coordinates, the <code>cartesian_to_spherical()</code> function computes spherical coordinates, enabling visualization and other analyses. On the other hand, when the data is given in spherical coordinates, the main function of the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package, <code>penalized_linear_spherical_spline()</code>, cannot be directly applied. In such cases, the <code>spherical_to_cartesian()</code> function allows the transformation of data into the required format.
The following code demonstrates examples implementing these transformations.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='co'># example: cartesian_to_spherical</span></span>
<span><span class='va'>cartesian_points</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>1</span>, <span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>1</span><span class='op'>)</span>, ncol <span class='op'>=</span> <span class='fl'>3</span>, byrow <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/cartesian_to_spherical.html'>cartesian_to_spherical</a></span><span class='op'>(</span><span class='va'>cartesian_points</span><span class='op'>)</span></span></code></pre>
</div>
<pre><code>        theta      phi
[1,] 1.570796 0.000000
[2,] 1.570796 1.570796
[3,] 0.000000 0.000000</code></pre>
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='co'># example: spherical_to_cartesian</span></span>
<span><span class='va'>theta_phi</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='va'>pi</span><span class='op'>/</span><span class='fl'>4</span>, <span class='va'>pi</span><span class='op'>/</span><span class='fl'>3</span>, <span class='va'>pi</span><span class='op'>/</span><span class='fl'>6</span>, <span class='va'>pi</span><span class='op'>/</span><span class='fl'>4</span><span class='op'>)</span>, ncol <span class='op'>=</span> <span class='fl'>2</span>, byrow <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/spherical_to_cartesian.html'>spherical_to_cartesian</a></span><span class='op'>(</span><span class='va'>theta_phi</span><span class='op'>)</span></span></code></pre>
</div>
<pre><code>          [,1]      [,2]      [,3]
[1,] 0.3535534 0.6123724 0.7071068
[2,] 0.3535534 0.3535534 0.8660254</code></pre>
</div>
<p>The following code demonstrates that these two functions perform inverse operations.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>theta_phi</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='va'>pi</span><span class='op'>/</span><span class='fl'>4</span>, <span class='va'>pi</span><span class='op'>/</span><span class='fl'>3</span>, <span class='va'>pi</span><span class='op'>/</span><span class='fl'>6</span>, <span class='va'>pi</span><span class='op'>/</span><span class='fl'>4</span><span class='op'>)</span>, ncol <span class='op'>=</span> <span class='fl'>2</span>, byrow <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span></span>
<span><span class='va'>theta_phi</span></span></code></pre>
</div>
<pre><code>          [,1]      [,2]
[1,] 0.7853982 1.0471976
[2,] 0.5235988 0.7853982</code></pre>
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/cartesian_to_spherical.html'>cartesian_to_spherical</a></span><span class='op'>(</span><span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/spherical_to_cartesian.html'>spherical_to_cartesian</a></span><span class='op'>(</span><span class='va'>theta_phi</span><span class='op'>)</span><span class='op'>)</span></span></code></pre>
</div>
<pre><code>         theta       phi
[1,] 0.7853982 1.0471976
[2,] 0.5235988 0.7853982</code></pre>
</div>
<h3 class="unnumbered" id="piecewise-geodesic-curve-1">Piecewise geodesic curve</h3>
<p>As illustrated in <a href="#prelim">Section 2</a>, we need to provide a sequence of knots and associated control points to define a piecewise geodesic curve. Although we introduce our methodology targeting data observed over time, it is important to note that the argument of a parametrized curve, denoted as <span class="math inline">\(t\)</span>, does not necessarily imply physical time. This methodology can be applied to the smoothing problem of any directional data evolving over a continuous domain. The only requirements for computing a piecewise geodesic curve are the knots and their corresponding control points. The function that returns the coordinates of the curve at a given <span class="math inline">\(t\)</span> point is the <code>piecewise_geodesic()</code> function. Table <a href="#tab:piecewisegeodesic">2</a> summarizes the arguments of the function.</p>
<table>
<caption><span id="tab:piecewisegeodesic">Table 2: </span> Summary of the arguments of the <code>piecewise_geodesic()</code> function.</caption>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>t</td>
<td>A numeric vector representing the time or location.</td>
</tr>
<tr class="even">
<td>control_points</td>
<td>A matrix of control points where each row represents a control point.</td>
</tr>
<tr class="odd">
<td>knots</td>
<td>A numeric vector of knot values.</td>
</tr>
</tbody>
</table>
<p>Here, the <code>control_points</code> is a matrix where each row represents a point in Cartesian coordinates that determines the geodesic segments. Since a pair of points defines a geodesic segment, this function can be used to compute the geodesic curve between two points if the <code>knots</code> is given as two endpoints. The <code>knots</code> is a vector of points separating the curve in the time domain. The <code>piecewise_geodesic()</code> function performs the following steps. First, it initializes an empty matrix to store the generated points on the curve. Second, it iterates over the separated geodesic segments to find the segment to which the <code>t</code> values belong. Then, it internally calls the <code>geodesic()</code> function for the corresponding segment to compute the coordinates of those points on the curve and appends the generated points to the initialized matrix. Finally, it returns the matrix containing all the points corresponding to the given <code>t</code> values.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:piecewise"></span>
<img src="figures/piecewise_geo1.png" alt="Plot of (left) piecewise geodesic curve with the control points at (1, 0, 0), (1/$\sqrt{2}$, 1/$\sqrt{2}$, 0), (-1/$\sqrt{3}$, 1/$\sqrt{3}$, 1/$\sqrt{3}$), and (0, 0, 1) and (right) piecewise geodesic curve with the control points at (1/$\sqrt{3}$, 1/$\sqrt{3}$, 1/$\sqrt{3}$), (1/$\sqrt{3}$, 1/$\sqrt{3}$, -1/$\sqrt{3}$), (-1/$\sqrt{3}$, 1/$\sqrt{3}$, 1/$\sqrt{3}$), and (-1/$\sqrt{3}$, 1/$\sqrt{3}$, -1/$\sqrt{3}$)." width="40%" /><img src="figures/piecewise_geo2.png" alt="Plot of (left) piecewise geodesic curve with the control points at (1, 0, 0), (1/$\sqrt{2}$, 1/$\sqrt{2}$, 0), (-1/$\sqrt{3}$, 1/$\sqrt{3}$, 1/$\sqrt{3}$), and (0, 0, 1) and (right) piecewise geodesic curve with the control points at (1/$\sqrt{3}$, 1/$\sqrt{3}$, 1/$\sqrt{3}$), (1/$\sqrt{3}$, 1/$\sqrt{3}$, -1/$\sqrt{3}$), (-1/$\sqrt{3}$, 1/$\sqrt{3}$, 1/$\sqrt{3}$), and (-1/$\sqrt{3}$, 1/$\sqrt{3}$, -1/$\sqrt{3}$)." width="40%" />
<p class="caption">
Figure 4: Plot of (left) piecewise geodesic curve with the control points at (1, 0, 0), (1/<span class="math inline">\(\sqrt{2}\)</span>, 1/<span class="math inline">\(\sqrt{2}\)</span>, 0), (-1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>), and (0, 0, 1) and (right) piecewise geodesic curve with the control points at (1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>), (1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>, -1/<span class="math inline">\(\sqrt{3}\)</span>), (-1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>), and (-1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>, -1/<span class="math inline">\(\sqrt{3}\)</span>).
</p>
</div>
</div>
<p>In the Figure <a href="#fig:piecewise">4</a>, the left plot depicts a piecewise geodesic curve determined by the control points (<span class="math inline">\(1\)</span>, <span class="math inline">\(0\)</span>, <span class="math inline">\(0\)</span>), (<span class="math inline">\(1/\sqrt{2}\)</span>, <span class="math inline">\(1/\sqrt{2}\)</span>, <span class="math inline">\(0\)</span>), (<span class="math inline">\(-1/\sqrt{3}\)</span>, <span class="math inline">\(1/\sqrt{3}\)</span>, <span class="math inline">\(1/\sqrt{3}\)</span>), and (<span class="math inline">\(0\)</span>, <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>). The function <code>piecewise_geodesic()</code> is used to compute the coordinates of the curve at given time points.
The <code>piecewise_geodesic</code> function presented here is roughly equivalent to the <code>rgl.sphline()</code> function from the <a href="https://cran.r-project.org/package=sphereplot">sphereplot</a> package, which also generates great circle line segments. However, <code>piecewise_geodesic</code> provides additional flexibility for handling complex geometries and segmentations, making it a suitable choice for a broader range of applications.
In the following code, we create a variable called <code>control_points</code>, which is a matrix containing four control points. The control points are used to determine the curve on the sphere while the <code>knots</code> indicate the points where transitions occur in the time domain. To obtain a smooth curve for visualization, we generate <code>t_example</code> by slicing the interval from <span class="math inline">\(0\)</span> to <span class="math inline">\(4\)</span> into increments of <span class="math inline">\(0.01\)</span>, and evaluate the coordinates of the curve at those points using the <code>piecewise_geodesic()</code> function. The following code yields the left plot of Figure <a href="#fig:piecewise">4</a>.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>control_points</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>0</span>, <span class='fl'>0</span>,                               <span class='co'># Control point 1</span></span>
<span>                           <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>2</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>2</span><span class='op'>)</span>, <span class='fl'>0</span>,               <span class='co'># Control point 2</span></span>
<span>                           <span class='op'>-</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>,      <span class='co'># Control point 3</span></span>
<span>                           <span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>1</span><span class='op'>)</span>,                              <span class='co'># Control point 4</span></span>
<span>                         nrow <span class='op'>=</span> <span class='fl'>4</span>, byrow <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span></span>
<span><span class='va'>knots</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span>, <span class='fl'>3</span>, <span class='fl'>3.5</span><span class='op'>)</span>  <span class='co'># Knots indicating transitions</span></span>
<span><span class='co'># Example of generating piecewise geodesic curve</span></span>
<span><span class='va'>t_example</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/seq.html'>seq</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>4</span>, by <span class='op'>=</span> <span class='fl'>0.01</span><span class='op'>)</span></span>
<span><span class='va'>gamma_example</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/piecewise_geodesic.html'>piecewise_geodesic</a></span><span class='op'>(</span><span class='va'>t_example</span>, <span class='va'>control_points</span>, <span class='va'>knots</span><span class='op'>)</span></span>
<span><span class='co'># Plotting the piecewise geodesic curve</span></span>
<span><span class='fu'><a href='https://rdrr.io/pkg/sphereplot/man/rgl.sphgrid.html'>rgl.sphgrid</a></span><span class='op'>(</span>deggap <span class='op'>=</span> <span class='fl'>15</span>, col.long <span class='op'>=</span> <span class='st'>"skyblue"</span>, col.lat <span class='op'>=</span> <span class='st'>"skyblue"</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://dmurdoch.github.io/rgl/dev/reference/spheres.html'>spheres3d</a></span><span class='op'>(</span>x <span class='op'>=</span> <span class='fl'>0</span>, y <span class='op'>=</span> <span class='fl'>0</span>, z <span class='op'>=</span> <span class='fl'>0</span>, radius <span class='op'>=</span> <span class='fl'>1</span>, col <span class='op'>=</span> <span class='st'>"grey"</span>, alpha <span class='op'>=</span> <span class='fl'>0.05</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://dmurdoch.github.io/rgl/dev/reference/pch3d.html'>pch3d</a></span><span class='op'>(</span><span class='va'>control_points</span>, col <span class='op'>=</span> <span class='st'>"blue"</span>, cex <span class='op'>=</span> <span class='fl'>0.2</span>, pch <span class='op'>=</span> <span class='fl'>19</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://dmurdoch.github.io/rgl/dev/reference/primitives.html'>lines3d</a></span><span class='op'>(</span><span class='va'>gamma_example</span>, col <span class='op'>=</span> <span class='st'>"red"</span>, lty <span class='op'>=</span> <span class='fl'>1</span>, lwd <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span></span></code></pre>
</div>
</div>
<p>The right plot of Figure <a href="#fig:piecewise">4</a> is an example of the curve with control points located at (1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>), (1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>, -1/<span class="math inline">\(\sqrt{3}\)</span>), (-1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>), and (-1/<span class="math inline">\(\sqrt{3}\)</span>, 1/<span class="math inline">\(\sqrt{3}\)</span>, -1/<span class="math inline">\(\sqrt{3}\)</span>). Below is the code that computes the curve and draws the corresponding plot.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>control_points</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>,       <span class='co'># Control point 1</span></span>
<span>                           <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='op'>-</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>,      <span class='co'># Control point 2</span></span>
<span>                           <span class='op'>-</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>,      <span class='co'># Control point 3</span></span>
<span>                           <span class='op'>-</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span>, <span class='op'>-</span><span class='fl'>1</span><span class='op'>/</span><span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span><span class='op'>(</span><span class='fl'>3</span><span class='op'>)</span><span class='op'>)</span>,    <span class='co'># Control point 4</span></span>
<span>                         nrow <span class='op'>=</span> <span class='fl'>4</span>, byrow <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span></span>
<span><span class='va'>knots</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>1</span>, <span class='fl'>2</span>, <span class='fl'>3</span>, <span class='fl'>3.5</span><span class='op'>)</span>  <span class='co'># Knots indicating transitions</span></span>
<span><span class='co'># Example of generating piecewise geodesic curve</span></span>
<span><span class='va'>t_example</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/seq.html'>seq</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>4</span>, by <span class='op'>=</span> <span class='fl'>0.01</span><span class='op'>)</span></span>
<span><span class='va'>gamma_example</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/piecewise_geodesic.html'>piecewise_geodesic</a></span><span class='op'>(</span><span class='va'>t_example</span>, <span class='va'>control_points</span>, <span class='va'>knots</span><span class='op'>)</span></span>
<span><span class='co'># Plotting the piecewise geodesic curve</span></span>
<span><span class='fu'><a href='https://rdrr.io/pkg/sphereplot/man/rgl.sphgrid.html'>rgl.sphgrid</a></span><span class='op'>(</span>deggap <span class='op'>=</span> <span class='fl'>15</span>, col.long <span class='op'>=</span> <span class='st'>"skyblue"</span>, col.lat <span class='op'>=</span> <span class='st'>"skyblue"</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://dmurdoch.github.io/rgl/dev/reference/spheres.html'>spheres3d</a></span><span class='op'>(</span>x <span class='op'>=</span> <span class='fl'>0</span>, y <span class='op'>=</span> <span class='fl'>0</span>, z <span class='op'>=</span> <span class='fl'>0</span>, radius <span class='op'>=</span> <span class='fl'>1</span>, col <span class='op'>=</span> <span class='st'>"grey"</span>, alpha <span class='op'>=</span> <span class='fl'>0.05</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://dmurdoch.github.io/rgl/dev/reference/pch3d.html'>pch3d</a></span><span class='op'>(</span><span class='va'>control_points</span>, col <span class='op'>=</span> <span class='st'>"blue"</span>, cex <span class='op'>=</span> <span class='fl'>0.2</span>, pch <span class='op'>=</span> <span class='fl'>19</span><span class='op'>)</span></span>
<span><span class='fu'><a href='https://dmurdoch.github.io/rgl/dev/reference/primitives.html'>lines3d</a></span><span class='op'>(</span><span class='va'>gamma_example</span>, col <span class='op'>=</span> <span class='st'>"red"</span>, lty <span class='op'>=</span> <span class='fl'>1</span>, lwd <span class='op'>=</span> <span class='fl'>2</span><span class='op'>)</span></span></code></pre>
</div>
</div>
<h3 class="unnumbered" id="penalized-piecewise-geodesic-curve-fitting">Penalized piecewise geodesic curve fitting</h3>
<p>The main function <code>penalized_linear_spherical_spline()</code> fits a penalized piecewise geodesic curve to the given spherical data as illustrated in <a href="#ppgc">Section 3</a>. As implied by the name of the function, this approach can also be understood as using a penalized linear spline method on the sphere. The crucial aspect here is the selection of knots that capture the points of change within the given time domain. The strategy proposed in this paper involves generating a sufficient number of initial knots using the <code>knots_quantile()</code> function and then adaptively selecting knots and control points based on penalization. The initial control points corresponding to the generated knots are determined by the corresponding data points <span class="math inline">\(y_i\)</span> on the given spherical surface.</p>
<p>After ensuring the flexibility of the model by setting the number of initial knots and control points sufficiently large, piecewise geodesic curves are computed for an increasing sequence of the complexity parameters <span class="math inline">\(\lambda_1 &lt; \cdots &lt; \lambda_{\text{max}}\)</span>. As the complexity parameter increases, we prune or delete the knots that are no longer active. If <span class="math inline">\(\lambda\)</span> is small, then so is the amount of penalization, resulting in a wiggly fit. On the other hand, the fitted curve gets smoother as <span class="math inline">\(\lambda\)</span> gets larger. If one wishes to consider as many possibilities as possible to find the optimal curve, it is possible to generate complexity parameters densely starting from very small values, and ensuring that <span class="math inline">\(\lambda_{\text{max}}\)</span> is sufficiently large to yield a least squares geodesic curve. Among the fitted curves, we can select the optimal curve based on the BIC, thus obtaining a data-adaptive piecewise geodesic curve.</p>
<p>The <code>penalized_linear_spherical_spline()</code> function is designed to automatically perform all these steps when initial knots and initial control points are not specified, aiming to enhance convenience for researchers. If there are valid numbers of knots determined through exploratory data analysis and preliminary research, along with coordinates for initial control points, they can be used as arguments. Table <a href="#tab:penalized-linear-spherical-spline">3</a> summarizes the arguments of the function.</p>
<table>
<caption><span id="tab:penalized-linear-spherical-spline">Table 3: </span> Summary of the arguments of the <code>penalized_linear_spherical_spline()</code> function.</caption>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>Argument</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>t</td>
<td>A numeric vector representing the time or location.</td>
</tr>
<tr class="even">
<td>y</td>
<td>A matrix where each row represents a data point.</td>
</tr>
<tr class="odd">
<td>initial_control_points</td>
<td>An optional matrix specifying initial control points. Default is NULL.</td>
</tr>
<tr class="even">
<td>dimension</td>
<td>An integer specifying the dimension of the spline.</td>
</tr>
<tr class="odd">
<td>initial_knots</td>
<td>An optional numeric vector specifying initial knots. Default is NULL.</td>
</tr>
<tr class="even">
<td>lambdas</td>
<td>A numeric vector specifying the penalization parameters.</td>
</tr>
<tr class="odd">
<td>step_size</td>
<td>A numeric value specifying the step size for optimization. Default is 0.01.</td>
</tr>
<tr class="even">
<td>maxiter</td>
<td>An integer specifying the maximum number of iterations. Default is 1000.</td>
</tr>
<tr class="odd">
<td>epsilon_iter</td>
<td>A numeric value specifying the convergence criterion for iterations. Default is 1e-05.</td>
</tr>
<tr class="even">
<td>jump_eps</td>
<td>A numeric value specifying the threshold for pruning control points based on jump size. Default is 1e-02.</td>
</tr>
<tr class="odd">
<td>verbose</td>
<td>A logical value indicating whether to print progress information. Default is FALSE.</td>
</tr>
</tbody>
</table>
<p>The function returns a list containing the fitted result for each complexity parameter, the dimension and BIC values associated with the complexity parameters required for model selection. The BIC values are stored in the last element of the list. It is possible to directly examine the BIC values and their corresponding fitted curves. Unless there is a specific reason, it is recommended to consider the <span class="math inline">\(\lambda\)</span> that attains the minimum BIC value as the optimal complexity parameter and select the corresponding fitted curve as the final fitted model. The usage of the function and the model selection process are illustrated in <a href="#application">Section 5</a>.</p>
<h2 data-number="5" id="application"><span class="header-section-number">5</span> Applications</h2>
<h3 class="unnumbered" id="apw-data">APW Data</h3>
<p>The data considered in this section is the polar wander dataset presented in <span class="citation" data-cites="kent2010influence">Kent and Irving (<a href="#ref-kent2010influence" role="doc-biblioref">2010</a>)</span>. They argued that previous estimates of Triassic and Jurassic paleolatitudes for North America tend to be biased because of inclination error in sedimentary rocks. They constructed a new composite APW path for Triassic through Paleogene based on igneous rocks. The <span class="math inline">\(17\)</span> Triassic/Jurassic cratonic poles from other major cratons are rotated into North American coordinates and combined with the <span class="math inline">\(14\)</span> observations from North America. We apply the proposed method to these <span class="math inline">\(31\)</span> observations ranging in age from <span class="math inline">\(243\)</span> to <span class="math inline">\(144\)</span> Ma (millions of years ago), which covers the late Triassic and Jurassic periods.</p>
<p>The APW dataset is included in the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a>. The data consists of the time, longitude, and latitude values for <span class="math inline">\(31\)</span> observations. It can be loaded as follows.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='fu'><a href='https://rdrr.io/r/base/dim.html'>dim</a></span><span class='op'>(</span><span class='va'>apw_spherical</span><span class='op'>)</span></span></code></pre>
</div>
<pre><code>[1] 31  3</code></pre>
</div>
<p>The APW data is represented in spherical coordinates. To apply the main function, it is necessary to convert the given data into Cartesian coordinates. We apply the <code>spherical_to_cartesian()</code> function to the second and third columns of the datasets, since the first column represents the time points.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>apw_cartesian</span> <span class='op'>=</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/spherical_to_cartesian.html'>spherical_to_cartesian</a></span><span class='op'>(</span><span class='va'>apw_spherical</span><span class='op'>[</span>, <span class='fl'>2</span><span class='op'>:</span><span class='fl'>3</span><span class='op'>]</span><span class='op'>)</span></span></code></pre>
</div>
</div>
<p>To ensure sufficient flexibility of the model, we set the initial dimension to <span class="math inline">\(15\)</span>, where the dimension refers to the number of knots or the corresponding number of control points. The knot sequence corresponding to the specified dimension is created using the knots_quantile() function. The grid for tuning the complexity parameter is determined as a sequence of 40 values ranging from <span class="math inline">\(10^{-7}\)</span> to <span class="math inline">\(1\)</span> on a logarithmic scale. We compute the fitted curves using the <code>penalized_linear_spherical_spline()</code> function.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>t</span> <span class='op'>=</span> <span class='va'>apw_spherical</span><span class='op'>[</span>, <span class='fl'>1</span><span class='op'>]</span></span>
<span><span class='va'>dimension</span> <span class='op'>=</span> <span class='fl'>15</span></span>
<span><span class='va'>initial_knots</span> <span class='op'>=</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/knots_quantile.html'>knots_quantile</a></span><span class='op'>(</span><span class='va'>t</span>, dimension <span class='op'>=</span> <span class='va'>dimension</span><span class='op'>)</span></span>
<span><span class='va'>lambda_seq</span> <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Log.html'>exp</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/seq.html'>seq</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/Log.html'>log</a></span><span class='op'>(</span><span class='fl'>1e-07</span><span class='op'>)</span>, <span class='fu'><a href='https://rdrr.io/r/base/Log.html'>log</a></span><span class='op'>(</span><span class='fl'>1</span><span class='op'>)</span>, length <span class='op'>=</span> <span class='fl'>40</span><span class='op'>)</span><span class='op'>)</span></span>
<span></span>
<span><span class='va'>fit</span> <span class='op'>=</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/penalized_linear_spherical_spline.html'>penalized_linear_spherical_spline</a></span><span class='op'>(</span>t <span class='op'>=</span> <span class='va'>t</span>, y <span class='op'>=</span> <span class='va'>apw_cartesian</span>,</span>
<span>                                        dimension <span class='op'>=</span> <span class='va'>dimension</span>,</span>
<span>                                        initial_knots <span class='op'>=</span> <span class='va'>initial_knots</span>,</span>
<span>                                        lambdas <span class='op'>=</span> <span class='va'>lambda_seq</span><span class='op'>)</span></span></code></pre>
</div>
</div>
<p>As explained in the previous section, the returned result is a list containing the information about <span class="math inline">\(40\)</span> fitted curves and the dimension and BIC values for model selection.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='fu'><a href='https://rdrr.io/r/base/class.html'>class</a></span><span class='op'>(</span><span class='va'>fit</span><span class='op'>)</span></span></code></pre>
</div>
<pre><code>[1] &quot;list&quot;</code></pre>
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='fu'><a href='https://rdrr.io/r/base/length.html'>length</a></span><span class='op'>(</span><span class='va'>fit</span><span class='op'>)</span></span></code></pre>
</div>
<pre><code>[1] 42</code></pre>
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>fit</span><span class='op'>$</span><span class='va'>dimension_list</span></span></code></pre>
</div>
<pre><code> [1] 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15
[23] 15 15 15 15 13 13 10 10  9  9  8  8  8  8  8  8  8  8</code></pre>
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>fit</span><span class='op'>$</span><span class='va'>bic_list</span></span></code></pre>
</div>
<pre><code> [1] 95.27152 95.22637 95.19061 95.12282 95.08984 95.05878 95.02849
 [8] 95.00298 94.97865 94.96560 94.95472 80.58414 80.58430 80.58470
[15] 80.58565 80.58750 80.59240 80.60174 80.62544 80.68245 80.77479
[22] 80.96411 81.44382 82.18175 83.45483 85.39508 66.62308 67.99973
[29] 38.50011 39.57477 29.76234 30.82627 21.74930 32.81671 37.56793
[36] 46.46920 47.62672 51.38727 54.17926 54.60989</code></pre>
</div>
<p>The best model according to the BIC can be selected as follows.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='co'># choose a curve that minimizes the BIC</span></span>
<span><span class='va'>best_index</span> <span class='op'>=</span> <span class='fu'><a href='https://rspatial.github.io/terra/reference/summarize-generics.html'>which.min</a></span><span class='op'>(</span><span class='va'>fit</span><span class='op'>$</span><span class='va'>bic_list</span><span class='op'>)</span></span>
<span><span class='va'>best_index</span></span></code></pre>
</div>
<pre><code>[1] 33</code></pre>
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='co'># obtained control points for the piecewise geodesic curve</span></span>
<span><span class='va'>fit</span><span class='op'>[[</span><span class='va'>best_index</span><span class='op'>]</span><span class='op'>]</span><span class='op'>$</span><span class='va'>control_points</span></span></code></pre>
</div>
<pre><code>            [,1]       [,2]      [,3]
[1,] -0.48039447 -0.2266981 0.8472480
[2,] -0.11927705  0.1300343 0.9843089
[3,] -0.06869155  0.1967739 0.9780396
[4,]  0.01640654  0.2026538 0.9791130
[5,]  0.03231127  0.3512434 0.9357265
[6,] -0.03372888  0.5085848 0.8603510
[7,] -0.08310953  0.5246722 0.8472378
[8,] -0.45295783  0.3987197 0.7974032</code></pre>
</div>
<p>The optimal complexity parameter is determined as</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>lambda_seq</span><span class='op'>[</span><span class='va'>best_index</span><span class='op'>]</span></span></code></pre>
</div>
<pre><code>[1] 0.0554102</code></pre>
</div>
<p>and the corresponding dimension is <span class="math inline">\(8\)</span>. Since we started with the initial dimension <span class="math inline">\(15\)</span>, the result illustrates the sparsity-inducing property of the proposed method.</p>
<p>The code begins by retrieving a world map using the <code>getMap()</code> function, which is then converted to an <code>sf</code> object (<code>worldMap_sf</code>) using <code>st_as_sf()</code> for easier handling in spatial analyses.
Control points are transformed from Cartesian coordinates to spherical coordinates using the <code>cartesian_to_spherical</code> function, with the resulting coordinates converted to degrees (latitude and longitude) to create <code>cp_long_lat_df</code>. The latitude values are adjusted to range from 0 to 90 degrees instead of being measured from the center.
The <code>apw_spherical</code> data is also converted into a data frame (<code>apw_spherical_df</code>), where the latitude and longitude values are transformed from radians to degrees, making them suitable for mapping.
Then, a geodesic curve is fitted using the <code>piecewise_geodesic</code> function, generating a fitted curve (<code>fitted_geodesic_curve</code>). This fitted curve is converted from Cartesian to spherical coordinates (<code>fitted_cs</code>), and then transformed into a data frame (<code>fitted_cs_long_lat_df</code>) with latitude and longitude values in degrees.
Finally, three data frames (<code>apw_spherical_df</code>, <code>cp_long_lat_df</code>, <code>fitted_cs_long_lat_df</code>) are converted to <code>sf</code> objects for further geospatial analysis, specifying the appropriate coordinate reference system (EPSG:4326) to facilitate geographic visualizations and operations.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>worldMap</span> <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/rworldmap/man/getMap.html'>getMap</a></span><span class='op'>(</span><span class='op'>)</span></span>
<span><span class='va'>worldMap_sf</span> <span class='op'>=</span> <span class='fu'><a href='https://r-spatial.github.io/sf/reference/st_as_sf.html'>st_as_sf</a></span><span class='op'>(</span><span class='va'>worldMap</span><span class='op'>)</span></span>
<span></span>
<span><span class='va'>cp_best</span> <span class='op'>=</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/cartesian_to_spherical.html'>cartesian_to_spherical</a></span><span class='op'>(</span><span class='va'>fit</span><span class='op'>[[</span><span class='va'>best_index</span><span class='op'>]</span><span class='op'>]</span><span class='op'>$</span><span class='va'>control_points</span><span class='op'>)</span></span>
<span><span class='va'>cp_long_lat</span> <span class='op'>=</span> <span class='va'>cp_best</span> <span class='op'>*</span> <span class='fl'>180</span> <span class='op'>/</span> <span class='va'>pi</span></span>
<span><span class='va'>cp_long_lat_df</span> <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/data.frame.html'>data.frame</a></span><span class='op'>(</span>latitude <span class='op'>=</span> <span class='fl'>90</span><span class='op'>-</span><span class='va'>cp_long_lat</span><span class='op'>[</span>, <span class='fl'>1</span><span class='op'>]</span>,</span>
<span>                            longitude <span class='op'>=</span> <span class='va'>cp_long_lat</span><span class='op'>[</span>,<span class='fl'>2</span><span class='op'>]</span><span class='op'>)</span></span>
<span></span>
<span><span class='va'>apw_spherical_df</span> <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/data.frame.html'>data.frame</a></span><span class='op'>(</span><span class='va'>apw_spherical</span><span class='op'>)</span></span>
<span><span class='va'>apw_spherical_df</span><span class='op'>$</span><span class='va'>latitude</span> <span class='op'>=</span> <span class='fl'>90</span> <span class='op'>-</span> <span class='va'>apw_spherical_df</span><span class='op'>$</span><span class='va'>latitude</span> <span class='op'>*</span> <span class='fl'>180</span> <span class='op'>/</span> <span class='va'>pi</span></span>
<span><span class='va'>apw_spherical_df</span><span class='op'>$</span><span class='va'>longitude</span> <span class='op'>=</span> <span class='va'>apw_spherical_df</span><span class='op'>$</span><span class='va'>longitude</span> <span class='op'>*</span> <span class='fl'>180</span> <span class='op'>/</span> <span class='va'>pi</span></span>
<span></span>
<span><span class='va'>fitted_geodesic_curve</span> <span class='op'>=</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/piecewise_geodesic.html'>piecewise_geodesic</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/seq.html'>seq</a></span><span class='op'>(</span><span class='fl'>0</span>, <span class='fl'>1</span>, length <span class='op'>=</span> <span class='fl'>2000</span><span class='op'>)</span>,</span>
<span>                                           <span class='va'>fit</span><span class='op'>[[</span><span class='va'>best_index</span><span class='op'>]</span><span class='op'>]</span><span class='op'>$</span><span class='va'>control_points</span>,</span>
<span>                                           <span class='va'>fit</span><span class='op'>[[</span><span class='va'>best_index</span><span class='op'>]</span><span class='op'>]</span><span class='op'>$</span><span class='va'>knots</span><span class='op'>)</span></span>
<span><span class='va'>fitted_cs</span> <span class='op'>=</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/cartesian_to_spherical.html'>cartesian_to_spherical</a></span><span class='op'>(</span><span class='va'>fitted_geodesic_curve</span><span class='op'>)</span></span>
<span><span class='va'>fitted_cs_long_lat</span> <span class='op'>=</span> <span class='va'>fitted_cs</span> <span class='op'>*</span> <span class='fl'>180</span> <span class='op'>/</span> <span class='va'>pi</span></span>
<span><span class='va'>fitted_cs_long_lat_df</span> <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/data.frame.html'>data.frame</a></span><span class='op'>(</span>latitude <span class='op'>=</span> <span class='fl'>90</span> <span class='op'>-</span> <span class='va'>fitted_cs_long_lat</span><span class='op'>[</span>, <span class='fl'>1</span><span class='op'>]</span>,</span>
<span>                             longitude <span class='op'>=</span> <span class='va'>fitted_cs_long_lat</span><span class='op'>[</span>, <span class='fl'>2</span><span class='op'>]</span><span class='op'>)</span></span>
<span></span>
<span><span class='va'>apw_spherical_df_sf</span> <span class='op'>=</span> <span class='fu'><a href='https://r-spatial.github.io/sf/reference/st_as_sf.html'>st_as_sf</a></span><span class='op'>(</span><span class='va'>apw_spherical_df</span>,</span>
<span>                               coords <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"longitude"</span>, <span class='st'>"latitude"</span><span class='op'>)</span>, crs <span class='op'>=</span> <span class='fl'>4326</span><span class='op'>)</span></span>
<span><span class='va'>cp_long_lat_df_sf</span> <span class='op'>=</span> <span class='fu'><a href='https://r-spatial.github.io/sf/reference/st_as_sf.html'>st_as_sf</a></span><span class='op'>(</span><span class='va'>cp_long_lat_df</span>,</span>
<span>                             coords <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"longitude"</span>, <span class='st'>"latitude"</span><span class='op'>)</span>, crs <span class='op'>=</span> <span class='fl'>4326</span><span class='op'>)</span></span>
<span><span class='va'>fitted_cs_long_lat_df_sf</span> <span class='op'>=</span> <span class='fu'><a href='https://r-spatial.github.io/sf/reference/st_as_sf.html'>st_as_sf</a></span><span class='op'>(</span><span class='va'>fitted_cs_long_lat_df</span>,</span>
<span>                                    coords <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"longitude"</span>, <span class='st'>"latitude"</span><span class='op'>)</span>, crs <span class='op'>=</span> <span class='fl'>4326</span><span class='op'>)</span></span></code></pre>
</div>
</div>
<p>The optimal fitted curve is visualized in the left plot of Figure <a href="#fig:APW">5</a> using the following code. It presents the obtained APW path (red line) and the associated control points (blue rhombus-shaped points) with the observations in the geographic coordinates.
The visualization was generated using the <code>coord_sf()</code> function with the <code>+proj=ortho</code> option, providing an orthographic projection of the spherical data.
The fitted curve shows that the obtained APW path has a clockwise rotational trend.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>worldmap</span> <span class='op'>=</span> <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggplot.html'>ggplot</a></span><span class='op'>(</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>geom_sf</a></span><span class='op'>(</span>data <span class='op'>=</span> <span class='va'>worldMap_sf</span>, color <span class='op'>=</span> <span class='st'>"grey"</span>, fill <span class='op'>=</span> <span class='st'>"antiquewhite"</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>geom_sf</a></span><span class='op'>(</span>data <span class='op'>=</span> <span class='va'>apw_spherical_df_sf</span>, size <span class='op'>=</span> <span class='fl'>0.8</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>geom_sf</a></span><span class='op'>(</span>data <span class='op'>=</span> <span class='va'>cp_long_lat_df_sf</span>, color <span class='op'>=</span> <span class='st'>"blue"</span>, shape <span class='op'>=</span> <span class='fl'>23</span>, size <span class='op'>=</span> <span class='fl'>4</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>geom_sf</a></span><span class='op'>(</span>data <span class='op'>=</span> <span class='va'>fitted_cs_long_lat_df_sf</span>, color <span class='op'>=</span> <span class='st'>"red"</span>, size <span class='op'>=</span> <span class='fl'>0.5</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/labs.html'>xlab</a></span><span class='op'>(</span><span class='st'>"longitude"</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/labs.html'>ylab</a></span><span class='op'>(</span><span class='st'>"latitude"</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/scale_continuous.html'>scale_y_continuous</a></span><span class='op'>(</span>breaks <span class='op'>=</span> <span class='op'>(</span><span class='op'>-</span><span class='fl'>2</span><span class='op'>:</span><span class='fl'>2</span><span class='op'>)</span> <span class='op'>*</span> <span class='fl'>30</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/scale_continuous.html'>scale_x_continuous</a></span><span class='op'>(</span>breaks <span class='op'>=</span> <span class='op'>(</span><span class='op'>-</span><span class='fl'>4</span><span class='op'>:</span><span class='fl'>4</span><span class='op'>)</span> <span class='op'>*</span> <span class='fl'>45</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>coord_sf</a></span><span class='op'>(</span>crs <span class='op'>=</span> <span class='st'>"+proj=ortho +lat_0=38 +lon_0=120 +y_0=0 +ellps=WGS84 +no_defs"</span><span class='op'>)</span></span>
<span><span class='va'>worldmap</span></span></code></pre>
</div>
</div>
<p>A zoomed version of the plot obtained from the following code is presented in the right panel of Figure <a href="#fig:APW">5</a>.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>mar</span> <span class='op'>=</span> <span class='fl'>20</span></span>
<span><span class='va'>zoommap</span> <span class='op'>=</span> <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggplot.html'>ggplot</a></span><span class='op'>(</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>geom_sf</a></span><span class='op'>(</span>data <span class='op'>=</span> <span class='va'>worldMap_sf</span>, color <span class='op'>=</span> <span class='st'>"grey"</span>, fill <span class='op'>=</span> <span class='st'>"antiquewhite"</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>geom_sf</a></span><span class='op'>(</span>data <span class='op'>=</span> <span class='va'>apw_spherical_df_sf</span>, size <span class='op'>=</span> <span class='fl'>0.8</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>geom_sf</a></span><span class='op'>(</span>data <span class='op'>=</span> <span class='va'>cp_long_lat_df_sf</span>, color <span class='op'>=</span> <span class='st'>"blue"</span>, shape <span class='op'>=</span> <span class='fl'>23</span>, size <span class='op'>=</span> <span class='fl'>4</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>geom_sf</a></span><span class='op'>(</span>data <span class='op'>=</span> <span class='va'>fitted_cs_long_lat_df_sf</span>, color <span class='op'>=</span> <span class='st'>"red"</span>, size <span class='op'>=</span> <span class='fl'>0.5</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/labs.html'>xlab</a></span><span class='op'>(</span><span class='st'>"longitude"</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/labs.html'>ylab</a></span><span class='op'>(</span><span class='st'>"latitude"</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/scale_continuous.html'>scale_y_continuous</a></span><span class='op'>(</span>breaks <span class='op'>=</span> <span class='op'>(</span><span class='op'>-</span><span class='fl'>2</span><span class='op'>:</span><span class='fl'>2</span><span class='op'>)</span> <span class='op'>*</span> <span class='fl'>30</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/scale_continuous.html'>scale_x_continuous</a></span><span class='op'>(</span>breaks <span class='op'>=</span> <span class='op'>(</span><span class='op'>-</span><span class='fl'>4</span><span class='op'>:</span><span class='fl'>4</span><span class='op'>)</span> <span class='op'>*</span> <span class='fl'>45</span><span class='op'>)</span> <span class='op'>+</span></span>
<span>  <span class='fu'><a href='https://ggplot2.tidyverse.org/reference/ggsf.html'>coord_sf</a></span><span class='op'>(</span>xlim <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>min</a></span><span class='op'>(</span><span class='va'>cp_long_lat_df</span><span class='op'>$</span><span class='va'>longitude</span><span class='op'>)</span> <span class='op'>-</span> <span class='va'>mar</span>,</span>
<span>                    <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>max</a></span><span class='op'>(</span><span class='va'>cp_long_lat_df</span><span class='op'>$</span><span class='va'>longitude</span><span class='op'>)</span> <span class='op'>+</span> <span class='va'>mar</span><span class='op'>)</span>,</span>
<span>           ylim <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>min</a></span><span class='op'>(</span><span class='va'>cp_long_lat_df</span><span class='op'>$</span><span class='va'>latitude</span><span class='op'>)</span> <span class='op'>-</span> <span class='va'>mar</span>,</span>
<span>                    <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>max</a></span><span class='op'>(</span><span class='va'>cp_long_lat_df</span><span class='op'>$</span><span class='va'>latitude</span><span class='op'>)</span> <span class='op'>+</span> <span class='va'>mar</span><span class='op'>)</span><span class='op'>)</span></span>
<span><span class='va'>zoommap</span></span></code></pre>
</div>
</div>
<div class="layout-chunk" data-layout="l-body">
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:APW"></span>
<img src="figures/APWdata_worldmap.png" alt="Plots of the APW path (red line) and the associated control points (blue points) obtained from the proposed method. The path goes from left to right in the plots. The left plot displays the path on the globe, and the right plot is a zoomed in version of the left plot on the projection map." width="49%" /><img src="figures/APWdata_zoommap.png" alt="Plots of the APW path (red line) and the associated control points (blue points) obtained from the proposed method. The path goes from left to right in the plots. The left plot displays the path on the globe, and the right plot is a zoomed in version of the left plot on the projection map." width="49%" />
<p class="caption">
Figure 5: Plots of the APW path (red line) and the associated control points (blue points) obtained from the proposed method. The path goes from left to right in the plots. The left plot displays the path on the globe, and the right plot is a zoomed in version of the left plot on the projection map.
</p>
</div>
</div>
<h3 class="unnumbered" id="goni-data">Goni Data</h3>
<p>This section considers the tropical cyclone (TC) data provided by the Regional Specialized Meteorological Center (RSMC) Tokyo Typhoon Center. This data consists of the variables TC name, time, latitude, longitude, TC central pressure, and maximum sustained wind speed. To illustrate the proposed method and the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package, we select the data concerning a cyclone named Goni observed from August 13th, 2015, to August 29th, 2015. The number of data points for Goni is 69, corresponding to each time point.</p>
<p>The Goni dataset is also included in the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> and can be loaded as follows.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>goni_cartesian</span> <span class='op'>=</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/spherical_to_cartesian.html'>spherical_to_cartesian</a></span><span class='op'>(</span><span class='va'>goni_spherical</span><span class='op'>[</span>, <span class='fl'>2</span><span class='op'>:</span><span class='fl'>3</span><span class='op'>]</span><span class='op'>)</span></span></code></pre>
</div>
</div>
<p>The code used for analysis is very similar to that used for computing the APW path. It involves transforming the data given in spherical coordinates to Cartesian coordinates, setting the initial dimension to 15, and fitting it with a sequence of complexity parameters. Subsequently, the optimal curve is selected using the BIC, and the coordinates of the corresponding control points are determined.</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>t</span> <span class='op'>=</span> <span class='va'>goni_spherical</span><span class='op'>[</span>, <span class='fl'>1</span><span class='op'>]</span></span>
<span><span class='va'>dimension</span> <span class='op'>=</span> <span class='fl'>15</span></span>
<span><span class='va'>initial_knots</span> <span class='op'>=</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/knots_quantile.html'>knots_quantile</a></span><span class='op'>(</span><span class='va'>t</span>, dimension <span class='op'>=</span> <span class='va'>dimension</span><span class='op'>)</span></span>
<span><span class='va'>lambda_seq</span> <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Log.html'>exp</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/seq.html'>seq</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/Log.html'>log</a></span><span class='op'>(</span><span class='fl'>1e-07</span><span class='op'>)</span>, <span class='fu'><a href='https://rdrr.io/r/base/Log.html'>log</a></span><span class='op'>(</span><span class='fl'>1</span><span class='op'>)</span>, length <span class='op'>=</span> <span class='fl'>40</span><span class='op'>)</span><span class='op'>)</span></span>
<span></span>
<span><span class='va'>fit</span> <span class='op'>=</span> <span class='fu'><a href='https://kybak90.github.io/spheresmooth/reference/penalized_linear_spherical_spline.html'>penalized_linear_spherical_spline</a></span><span class='op'>(</span>t <span class='op'>=</span> <span class='va'>t</span>, y <span class='op'>=</span> <span class='va'>goni_cartesian</span>,</span>
<span>                                        dimension <span class='op'>=</span> <span class='va'>dimension</span>,</span>
<span>                                        initial_knots <span class='op'>=</span> <span class='va'>initial_knots</span>,</span>
<span>                                        lambdas <span class='op'>=</span> <span class='va'>lambda_seq</span><span class='op'>)</span></span>
<span><span class='co'># choose a curve that minimizes the BIC</span></span>
<span><span class='va'>best_index</span> <span class='op'>=</span> <span class='fu'><a href='https://rspatial.github.io/terra/reference/summarize-generics.html'>which.min</a></span><span class='op'>(</span><span class='va'>fit</span><span class='op'>$</span><span class='va'>bic_list</span><span class='op'>)</span></span>
<span><span class='va'>best_index</span></span></code></pre>
</div>
<pre><code>[1] 23</code></pre>
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>fit</span><span class='op'>$</span><span class='va'>dimension_list</span><span class='op'>[</span><span class='va'>best_index</span><span class='op'>]</span></span></code></pre>
</div>
<pre><code>[1] 12</code></pre>
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>fit</span><span class='op'>[[</span><span class='va'>best_index</span><span class='op'>]</span><span class='op'>]</span><span class='op'>$</span><span class='va'>control_points</span></span></code></pre>
</div>
<pre><code>            [,1]      [,2]      [,3]
 [1,] -0.8572250 0.4708035 0.2085888
 [2,] -0.8205531 0.5235703 0.2292744
 [3,] -0.7429817 0.6032236 0.2899991
 [4,] -0.6430559 0.6947774 0.3221234
 [5,] -0.5554791 0.7659919 0.3235729
 [6,] -0.5088629 0.7970417 0.3252431
 [7,] -0.5041307 0.7884991 0.3523087
 [8,] -0.5073276 0.7575879 0.4107058
 [9,] -0.5258286 0.7266336 0.4421627
[10,] -0.5470298 0.6626324 0.5115434
[11,] -0.5418227 0.5904786 0.5981331
[12,] -0.4863508 0.5146343 0.7061263</code></pre>
</div>
<p>The index of the curve that minimizes BIC is <span class="math inline">\(23\)</span> with the corresponding dimension <span class="math inline">\(12\)</span>. The optimal complexity parameter is determined as</p>
<div class="layout-chunk" data-layout="l-body">
<div class="sourceCode">
<pre class="sourceCode r"><code class="sourceCode r"><span><span class='va'>lambda_seq</span><span class='op'>[</span><span class='va'>best_index</span><span class='op'>]</span></span></code></pre>
</div>
<pre><code>[1] 0.0008886238</code></pre>
</div>
<div class="layout-chunk" data-layout="l-body">
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:Goni"></span>
<img src="figures/Gonidata_worldmap.png" alt="Plots of the Goni path (red line) and the associated control points (blue points) obtained from the proposed method. The path goes from left to right in the plots. The left plot displays the path on the globe, and the right plot is a zoomed in version of the left plot on the projection map." width="49%" /><img src="figures/Gonidata_zoommap.png" alt="Plots of the Goni path (red line) and the associated control points (blue points) obtained from the proposed method. The path goes from left to right in the plots. The left plot displays the path on the globe, and the right plot is a zoomed in version of the left plot on the projection map." width="49%" />
<p class="caption">
Figure 6: Plots of the Goni path (red line) and the associated control points (blue points) obtained from the proposed method. The path goes from left to right in the plots. The left plot displays the path on the globe, and the right plot is a zoomed in version of the left plot on the projection map.
</p>
</div>
</div>
<p>We can visualize the fitted curve and obtain Figure <a href="#fig:Goni">6</a> by executing code similar to that used in the previous section. The obtained path for Goni (red line) and the corresponding control points (blue rhombus-shaped points) are visualized along with the observations in Figure <a href="#fig:Goni">6</a>. Although the remaining control points may appear somewhat dense, in reality, these points are not redundant. The proposed penalization method utilizes the difference in velocity vectors to induce sparsity. Therefore, even control points that do not appear visually active on a map can provide valuable information for further analysis when viewed alongside time points, as they represent points where the velocity changes.</p>
<div class="layout-chunk" data-layout="l-body">

</div>
<h2 data-number="6" id="conclusion"><span class="header-section-number">6</span> Summary</h2>
<p>This paper introduced the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package. We proposed a piecewise geodesic curve fitting method based on a velocity-based penalization scheme. The <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package implements the proposed method with the Riemannian block coordinate descent algorithm. It provides an automatic procedure for fitting a smooth path to a given set of noisy spherical data at known times. The <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package demonstrated its usefulness by applying the functions to the polar wander path data and tropical cyclone data.
The methods presented in this paper not only advance spherical data analysis in general but also hold significant potential for application in astronomy, where spherical coordinate systems and data are foundational. For example, these methods could be effectively utilized in analyzing celestial data, similar to the work conducted with CMB maps by the WMAP and Planck missions, demonstrating the versatility and applicability of our approach in handling complex, all-sky astronomical observations.
We expect that the <a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a> package will be helpful for applications in various fields, including statistics, machine learning, astronomy, cardiology, computer vision, physiology, and geophysics.</p>
<h2 data-number="7" id="acknowledgments"><span class="header-section-number">7</span> Acknowledgments</h2>
<p>The work of Jae-Hwan Jhong was supported by the National Research Foundation of Korea(NRF) grant funded by the Korea government(MSIT)(RS-2024-00342014 and RS-2024-00440787).
The work of Ja-Yong Koo was supported by the National Research Foundation of Korea(NRF) grant funded by the Korea government(MSIT)(RS-2023-00253020 and RS-2023-00219212).
The work of Kwan-Young Bak was supported by the National Research Foundation of Korea(NRF) grant funded by the Korea government(MSIT)(RS-2024-00342014 and RS-2022-00165581).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r distill-force-highlighting-css"><code class="sourceCode r"></code></pre></div>
<h3 class="appendix" data-number="7.1" id="supplementary-materials"><span class="header-section-number">7.1</span> Supplementary materials</h3>
<p>Supplementary materials are available in addition to this article. It can be downloaded at
<a href="RJ-2025-004.zip">RJ-2025-004.zip</a></p>
<h3 class="appendix" data-number="7.2" id="cran-packages-used"><span class="header-section-number">7.2</span> CRAN packages used</h3>
<p><a href="https://cran.r-project.org/package=spheresmooth">spheresmooth</a>, <a href="https://cran.r-project.org/package=sphereplot">sphereplot</a>, <a href="https://cran.r-project.org/package=rgl">rgl</a>, <a href="https://cran.r-project.org/package=rworldmap">rworldmap</a>, <a href="https://cran.r-project.org/package=ggplot2">ggplot2</a>, <a href="https://cran.r-project.org/package=sf">sf</a></p>
<h3 class="appendix" data-number="7.3" id="cran-task-views-implied-by-cited-packages"><span class="header-section-number">7.3</span> CRAN Task Views implied by cited packages</h3>
<p><a href="https://cran.r-project.org/view=ChemPhys">ChemPhys</a>, <a href="https://cran.r-project.org/view=DynamicVisualizations">DynamicVisualizations</a>, <a href="https://cran.r-project.org/view=NetworkAnalysis">NetworkAnalysis</a>, <a href="https://cran.r-project.org/view=OfficialStatistics">OfficialStatistics</a>, <a href="https://cran.r-project.org/view=Phylogenetics">Phylogenetics</a>, <a href="https://cran.r-project.org/view=Spatial">Spatial</a>, <a href="https://cran.r-project.org/view=SpatioTemporal">SpatioTemporal</a>, <a href="https://cran.r-project.org/view=TeachingStatistics">TeachingStatistics</a></p>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bak2023intrinsic" class="csl-entry" role="listitem">
K.-Y. Bak, J.-K. Shin and J.-Y. Koo. Intrinsic spherical smoothing method based on generalized <span class="nocase">B<span class="nocase">é</span>zier</span> curves and sparsity inducing penalization. <em>Journal of Applied Statistics</em>, 50(9): 1942–1961, 2023.
</div>
<div id="ref-camarinha1995splines" class="csl-entry" role="listitem">
M. Camarinha, F. Silva Leite and P. Crouch. Splines of class <span><span class="math inline">\(C^k\)</span></span> on non-<span>Euclidean</span> spaces. <em>IMA Journal of Mathematical Control and Information</em>, 12(4): 399–410, 1995.
</div>
<div id="ref-carmo1976differential" class="csl-entry" role="listitem">
M. P. do Carmo. <em>Differential geometry of curves and surfaces.</em> Prentice-Hall, Englewood Cliffs, New Jersey, 1976.
</div>
<div id="ref-carmo1992riemannian" class="csl-entry" role="listitem">
M. P. do Carmo. <em>Riemannian geometry.</em> Birkh<span>ä</span>user, 1992.
</div>
<div id="ref-gorski2005healpix" class="csl-entry" role="listitem">
K. M. Górski, E. Hivon, A. J. Banday, B. D. Wandelt, F. K. Hansen, M. Reinecke and M. Bartelmann. <span>HEALPix</span>: A framework for high-resolution discretization and fast analysis of data distributed on the sphere. <em>The Astrophysical Journal</em>, 622(2): 759, 2005.
</div>
<div id="ref-gould1969regression" class="csl-entry" role="listitem">
A. L. Gould. A regression technique for angular variates. <em>Biometrics</em>, 683–700, 1969.
</div>
<div id="ref-jupp1987fitting" class="csl-entry" role="listitem">
P. E. Jupp and J. T. Kent. Fitting smooth paths to spherical data. <em>Journal of the Royal Statistical Society: Series C (Applied Statistics)</em>, 36(1): 34–46, 1987.
</div>
<div id="ref-kent2010influence" class="csl-entry" role="listitem">
D. V. Kent and E. Irving. Influence of inclination error in sedimentary rocks on the <span>Triassic</span> and <span>Jurassic</span> apparent pole wander path for <span>North America</span> and implications for <span>Cordilleran</span> tectonics. <em>Journal of Geophysical Research: Solid Earth</em>, 115(B10): 2010.
</div>
<div id="ref-kim2021smoothing" class="csl-entry" role="listitem">
K.-R. Kim, I. L. Dryden, H. Le and K. E. Severn. Smoothing splines on <span>Riemannian</span> manifolds, with applications to <span>3D</span> shape space. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 83(1): 108–132, 2021.
</div>
<div id="ref-kume2007shape" class="csl-entry" role="listitem">
A. Kume, I. L. Dryden and H. Le. Shape-space smoothing splines for planar landmark data. <em>Biometrika</em>, 94(3): 513–528, 2007.
</div>
<div id="ref-machado2006riemannian" class="csl-entry" role="listitem">
L. Machado, F. S. Leite and K. Hüper. <span>Riemannian</span> means as solutions of variational problems. <em>LMS Journal of Computation and Mathematics</em>, 9: 86–103, 2006.
</div>
<div id="ref-rgl-ref" class="csl-entry" role="listitem">
D. Murdoch and D. Adler. <em><span class="nocase">rgl</span>: 3<span>D</span> visualization using <span>OpenGL</span> (<span>R</span> package version 1.3.1).</em> 2024. URL <a href="https://CRAN.R-project.org/package=rgl">https://CRAN.R-project.org/package=rgl</a>.
</div>
<div id="ref-noakes1989cubic" class="csl-entry" role="listitem">
L. Noakes, G. Heinzinger and B. Paden. Cubic splines on curved spaces. <em>IMA Journal of Mathematical Control and Information</em>, 6(4): 465–473, 1989.
</div>
<div id="ref-sphereplot-ref" class="csl-entry" role="listitem">
A. Robotham. <em><span class="nocase">sphereplot</span>: Spherical plotting (<span>R</span> package version 1.5.1).</em> 2022. URL <a href="https://CRAN.R-project.org/package=sphereplot">https://CRAN.R-project.org/package=sphereplot</a>.
</div>
<div id="ref-samir2012gradient" class="csl-entry" role="listitem">
C. Samir, P. A. Absil, A. Srivastava and E. Klassen. A gradient-descent method for curve fitting on <span>Riemannian</span> manifolds. <em>Foundations of Computational Mathematics</em>, 12(1): 49–73, 2012.
</div>
<div id="ref-schwarz1978" class="csl-entry" role="listitem">
G. Schwarz. Estimating the dimension of a model. <em>Annals of Statistics</em>, 6(2): 461–464, 1978.
</div>
<div id="ref-rworldmap-ref" class="csl-entry" role="listitem">
A. South. <span class="nocase">rworldmap</span>: A new <span>R</span> package for mapping global data. <em>The R Journal</em>, 3(1): 35–43, 2011. URL <a href="https://journal.r-project.org/articles/RJ-2011-006/">https://journal.r-project.org/articles/RJ-2011-006/</a>.
</div>
<div id="ref-su2012fitting" class="csl-entry" role="listitem">
J. Su, I. L. Dryden, E. Klassen, H. Le and A. Srivastava. Fitting smoothing splines to time-indexed, noisy points on nonlinear manifolds. <em>Image and Vision Computing</em>, 30(6-7): 428–442, 2012.
</div>
<div id="ref-thompson1982robust" class="csl-entry" role="listitem">
R. Thompson and R. M. Clark. A robust least-squares <span>Gondwanan</span> apparent polar wander path and the question of palaeomagnetic assessment of <span>Gondwanan</span> reconstruction. <em>Earth and Planetary Science Letters</em>, 57(1): 152–158, 1982.
</div>
<div id="ref-ggplot2-ref" class="csl-entry" role="listitem">
H. Wickham. <em><span class="nocase">ggplot2</span>: Elegant graphics for data analysis.</em> Springer-Verlag New York, 2016. URL <a href="https://ggplot2.tidyverse.org">https://ggplot2.tidyverse.org</a>.
</div>
</div>
<!--radix_placeholder_article_footer-->
<!--/radix_placeholder_article_footer-->
</div>

<div class="d-appendix">
</div>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<!--radix_placeholder_site_after_body-->
<!--/radix_placeholder_site_after_body-->
<!--radix_placeholder_appendices-->
<div class="appendix-bottom">
<h3 id="references">References</h3>
<div id="references-listing"></div>
<h3 id="reuse">Reuse</h3>
<p>Text and figures are licensed under Creative Commons Attribution <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>. The figures that have been reused from other sources don't fall under this license and can be recognized by a note in their caption: "Figure from ...".</p>
<h3 id="citation">Citation</h3>
<p>For attribution, please cite this work as</p>
<pre class="citation-appendix short">Jhong, et al., "spheresmooth: An R Package for Penalized Piecewise Geodesic Curve Fitting on a Sphere", The R Journal, 2025</pre>
<p>BibTeX citation</p>
<pre class="citation-appendix long">@article{RJ-2025-004,
  author = {Jhong, Jae-Hwan and Lee, Seyoung and Koo, Ja-Yong and Bak, Kwan-Young},
  title = {spheresmooth: An R Package for Penalized Piecewise Geodesic Curve Fitting on a Sphere},
  journal = {The R Journal},
  year = {2025},
  note = {https://doi.org/10.32614/RJ-2025-004},
  doi = {10.32614/RJ-2025-004},
  volume = {17},
  issue = {1},
  issn = {2073-4859},
  pages = {67-87}
}</pre>
</div>
<!--/radix_placeholder_appendices-->
<!--radix_placeholder_navigation_after_body-->
<!--/radix_placeholder_navigation_after_body-->

</body>

</html>
