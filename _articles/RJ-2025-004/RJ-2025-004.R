# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2025-004.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)


## ----echo = TRUE--------------------------------------------------------------
library(spheresmooth)
library(sphereplot)
library(rworldmap)
library(ggplot2)
library(sf)


## ----dist-geodesic, fig.show='hold', out.width="40%", fig.cap="Illustration of geodesic segment between $u$ and $v$ and spherical distance.", fig.subcap=c("",""), fig.align='center'----
knitr::include_graphics("figures/geodesic_dist.png")


## ----riemann, fig.show='hold', out.width="49%", fig.cap="Illustration of (left) Riemannian gradient and (right) exponential map.", fig.subcap=c("",""), fig.align='center'----
knitr::include_graphics("figures/Riemannian_grad.png")
knitr::include_graphics("figures/exponential_map.png")


## ----elimination, fig.show='hold', out.width="33%", fig.cap="Example of elimination process of the piecewise geodesic curve with three control points. Blue arrow vector indicates tangent vector of $\\xi_2$ in consecutive geodesic segments. The left plot shows the spline curve with small value of complexity parameter. As the complexity parameter $\\lambda$ increases, $\\xi_2$ moves into the geodesic between $\\xi_1$ and $\\xi_3$ and the difference between tangent vectors becomes zero. The middle plot shows that step. When the difference between tangent vectors is zero, control point is removed. The right plot shows the resulting curve after control point is removed in the middle plot.", fig.subcap=c("","",""), fig.align='center'----
knitr::include_graphics("figures/penalized_geo2.png")
knitr::include_graphics("figures/penalized_geo2_1.png")
knitr::include_graphics("figures/penalized_geo.png")


## ----pakcage-functions, echo = FALSE------------------------------------------
library(knitr)
library(kableExtra)

# Create the data frame with function names and descriptions
spheresmooth_functions <- data.frame(
  Function = c(
    "calculate\\_loss",
    "cartesian\\_to\\_spherical",
    "cross",
    "dot",
    "edp",
    "exp\\_map",
    "geodesic",
    "knots\\_quantile",
    "norm2",
    "normalize",
    "penalized\\_linear\\_spherical\\_spline",
    "piecewise\\_geodesic",
    "spherical\\_dist",
    "spherical\\_to\\_cartesian"
  ),
  Description = c(
    "Calculates the loss function based on the squared spherical distances between observed values and predicted values on the curve.",
    "Converts Cartesian coordinates to spherical coordinates.",
    "Computes the cross product of two input vectors",
    "Computes the dot product of two input vectors $u$ and $v$.",
    "Computes the equal-distance projection of a point $p$ onto the xy plane.",
    "Computes the exponential map on the unit sphere given a base point $x$ and a vector $v$.",
    "Computes the value of the geodesic curve connecting two points $p$ and $q$ on the unit sphere at specified time points.",
    "Generates a sequence of knots for a given set of time points based on the quantiles.",
    "Computes the L2 norm (Euclidean norm) of the input vector.",
    "Normalizes the rows of the input matrix $x$ by dividing each row by its L2 norm (Euclidean norm).",
    "Fits a penalized linear spherical spline (piecewise geodesic) curve to the given data.",
    "Computes a piecewise geodesic path between control points.",
    "Calculates the spherical distance between two vectors.",
    "converts spherical coordinates ($\\theta$, $\\phi$) to Cartesian coordinates."
  ),
  stringsAsFactors = FALSE
)

# Create the table using knitr::kable with kableExtra formatting
tab <- kable(spheresmooth_functions,
      caption = "Summary of the functions in the spheresmooth package.",
      align = c("l", "l"),
      col.names = c("Function", "Description"),
      booktabs = TRUE,
      longtable = FALSE,
      escape = FALSE)
    
if (knitr::is_latex_output()) {
  tab <- tab |>
    column_spec(1, monospace = TRUE) |>
    column_spec(2, width = "7cm")
}
tab



## ----echo = TRUE--------------------------------------------------------------
x <- c(1, 0, 0)
y <- c(0, 1, 0)
spherical_dist(x, y)


## ----echo = TRUE--------------------------------------------------------------
x <- c(1/sqrt(3), 1/sqrt(3), 1/sqrt(3))
y <- c(-1/sqrt(3), -1/sqrt(3), -1/sqrt(3))
spherical_dist(x, y)


## ----echo = TRUE--------------------------------------------------------------
x <- c(1, 0, 0)
y <- c(0, 1, 0)
cross(x, y, normalize = TRUE)


## ----echo = TRUE--------------------------------------------------------------
# example: cartesian_to_spherical
cartesian_points <- matrix(c(1, 0, 0, 0, 1, 0, 0, 0, 1), ncol = 3, byrow = TRUE)
cartesian_to_spherical(cartesian_points)

# example: spherical_to_cartesian
theta_phi <- matrix(c(pi/4, pi/3, pi/6, pi/4), ncol = 2, byrow = TRUE)
spherical_to_cartesian(theta_phi)


## ----echo = TRUE--------------------------------------------------------------
theta_phi <- matrix(c(pi/4, pi/3, pi/6, pi/4), ncol = 2, byrow = TRUE)
theta_phi
cartesian_to_spherical(spherical_to_cartesian(theta_phi))


## ----piecewise, fig.show='hold', out.width="40%", fig.cap="Plot of (left) piecewise geodesic curve with the control points at (1, 0, 0), (1/$\\sqrt{2}$, 1/$\\sqrt{2}$, 0), (-1/$\\sqrt{3}$, 1/$\\sqrt{3}$, 1/$\\sqrt{3}$), and (0, 0, 1) and (right) piecewise geodesic curve with the control points at (1/$\\sqrt{3}$, 1/$\\sqrt{3}$, 1/$\\sqrt{3}$), (1/$\\sqrt{3}$, 1/$\\sqrt{3}$, -1/$\\sqrt{3}$), (-1/$\\sqrt{3}$, 1/$\\sqrt{3}$, 1/$\\sqrt{3}$), and (-1/$\\sqrt{3}$, 1/$\\sqrt{3}$, -1/$\\sqrt{3}$).", fig.subcap=c("",""), fig.align='center'----
knitr::include_graphics("figures/piecewise_geo1.png")
knitr::include_graphics("figures/piecewise_geo2.png")


## ----message=FALSE, warning=FALSE, cache=TRUE, cache.lazy=FALSE, echo = TRUE----
control_points <- matrix(c(1, 0, 0,                               # Control point 1
                           1/sqrt(2), 1/sqrt(2), 0,               # Control point 2
                           -1/sqrt(3), 1/sqrt(3), 1/sqrt(3),      # Control point 3
                           0, 0, 1),                              # Control point 4
                         nrow = 4, byrow = TRUE)
knots <- c(1, 2, 3, 3.5)  # Knots indicating transitions
# Example of generating piecewise geodesic curve
t_example <- seq(0, 4, by = 0.01)
gamma_example <- piecewise_geodesic(t_example, control_points, knots)
# Plotting the piecewise geodesic curve
rgl.sphgrid(deggap = 15, col.long = "skyblue", col.lat = "skyblue")
spheres3d(x = 0, y = 0, z = 0, radius = 1, col = "grey", alpha = 0.05)
pch3d(control_points, col = "blue", cex = 0.2, pch = 19)
lines3d(gamma_example, col = "red", lty = 1, lwd = 2)


## ----message=FALSE, warning=FALSE, cache=TRUE, cache.lazy=FALSE, echo = TRUE----
control_points <- matrix(c(1/sqrt(3), 1/sqrt(3), 1/sqrt(3),       # Control point 1
                           1/sqrt(3), 1/sqrt(3), -1/sqrt(3),      # Control point 2
                           -1/sqrt(3), 1/sqrt(3), 1/sqrt(3),      # Control point 3
                           -1/sqrt(3), 1/sqrt(3), -1/sqrt(3)),    # Control point 4
                         nrow = 4, byrow = TRUE)
knots <- c(1, 2, 3, 3.5)  # Knots indicating transitions
# Example of generating piecewise geodesic curve
t_example <- seq(0, 4, by = 0.01)
gamma_example <- piecewise_geodesic(t_example, control_points, knots)
# Plotting the piecewise geodesic curve
rgl.sphgrid(deggap = 15, col.long = "skyblue", col.lat = "skyblue")
spheres3d(x = 0, y = 0, z = 0, radius = 1, col = "grey", alpha = 0.05)
pch3d(control_points, col = "blue", cex = 0.2, pch = 19)
lines3d(gamma_example, col = "red", lty = 1, lwd = 2)


## ----echo = TRUE--------------------------------------------------------------
dim(apw_spherical)


## ----echo = TRUE--------------------------------------------------------------
apw_cartesian = spherical_to_cartesian(apw_spherical[, 2:3])


## ----echo = TRUE, cache = TRUE, cache.lazy = FALSE----------------------------
t = apw_spherical[, 1]
dimension = 15
initial_knots = knots_quantile(t, dimension = dimension)
lambda_seq = exp(seq(log(1e-07), log(1), length = 40))

fit = penalized_linear_spherical_spline(t = t, y = apw_cartesian,
                                        dimension = dimension,
                                        initial_knots = initial_knots,
                                        lambdas = lambda_seq)


## ----echo = TRUE--------------------------------------------------------------
class(fit)
length(fit)
fit$dimension_list
fit$bic_list


## ----echo = TRUE--------------------------------------------------------------
# choose a curve that minimizes the BIC
best_index = which.min(fit$bic_list)
best_index
# obtained control points for the piecewise geodesic curve
fit[[best_index]]$control_points


## ----echo = TRUE--------------------------------------------------------------
lambda_seq[best_index]


## ----echo = TRUE, eval = FALSE------------------------------------------------
# worldMap = getMap()
# worldMap_sf = st_as_sf(worldMap)
# 
# cp_best = cartesian_to_spherical(fit[[best_index]]$control_points)
# cp_long_lat = cp_best * 180 / pi
# cp_long_lat_df = data.frame(latitude = 90-cp_long_lat[, 1],
#                             longitude = cp_long_lat[,2])
# 
# apw_spherical_df = data.frame(apw_spherical)
# apw_spherical_df$latitude = 90 - apw_spherical_df$latitude * 180 / pi
# apw_spherical_df$longitude = apw_spherical_df$longitude * 180 / pi
# 
# fitted_geodesic_curve = piecewise_geodesic(seq(0, 1, length = 2000),
#                                            fit[[best_index]]$control_points,
#                                            fit[[best_index]]$knots)
# fitted_cs = cartesian_to_spherical(fitted_geodesic_curve)
# fitted_cs_long_lat = fitted_cs * 180 / pi
# fitted_cs_long_lat_df = data.frame(latitude = 90 - fitted_cs_long_lat[, 1],
#                              longitude = fitted_cs_long_lat[, 2])
# 
# apw_spherical_df_sf = st_as_sf(apw_spherical_df,
#                                coords = c("longitude", "latitude"), crs = 4326)
# cp_long_lat_df_sf = st_as_sf(cp_long_lat_df,
#                              coords = c("longitude", "latitude"), crs = 4326)
# fitted_cs_long_lat_df_sf = st_as_sf(fitted_cs_long_lat_df,
#                                     coords = c("longitude", "latitude"), crs = 4326)


## ----echo = TRUE, eval = FALSE------------------------------------------------
# worldmap = ggplot() +
#   geom_sf(data = worldMap_sf, color = "grey", fill = "antiquewhite") +
#   geom_sf(data = apw_spherical_df_sf, size = 0.8) +
#   geom_sf(data = cp_long_lat_df_sf, color = "blue", shape = 23, size = 4) +
#   geom_sf(data = fitted_cs_long_lat_df_sf, color = "red", size = 0.5) +
#   xlab("longitude") +
#   ylab("latitude") +
#   scale_y_continuous(breaks = (-2:2) * 30) +
#   scale_x_continuous(breaks = (-4:4) * 45) +
#   coord_sf(crs = "+proj=ortho +lat_0=38 +lon_0=120 +y_0=0 +ellps=WGS84 +no_defs")
# worldmap


## ----echo = TRUE, eval = FALSE------------------------------------------------
# mar = 20
# zoommap = ggplot() +
#   geom_sf(data = worldMap_sf, color = "grey", fill = "antiquewhite") +
#   geom_sf(data = apw_spherical_df_sf, size = 0.8) +
#   geom_sf(data = cp_long_lat_df_sf, color = "blue", shape = 23, size = 4) +
#   geom_sf(data = fitted_cs_long_lat_df_sf, color = "red", size = 0.5) +
#   xlab("longitude") +
#   ylab("latitude") +
#   scale_y_continuous(breaks = (-2:2) * 30) +
#   scale_x_continuous(breaks = (-4:4) * 45) +
#   coord_sf(xlim = c(min(cp_long_lat_df$longitude) - mar,
#                     max(cp_long_lat_df$longitude) + mar),
#            ylim = c(min(cp_long_lat_df$latitude) - mar,
#                     max(cp_long_lat_df$latitude) + mar))
# zoommap


## ----APW, fig.show='hold', out.width="49%", fig.cap="Plots of the APW path (red line) and the associated control points (blue points) obtained from the proposed method. The path goes from left to right in the plots. The left plot displays the path on the globe, and the right plot is a zoomed in version of the left plot on the projection map.", fig.subcap=c("",""), fig.align='center'----
knitr::include_graphics("figures/APWdata_worldmap.png")
knitr::include_graphics("figures/APWdata_zoommap.png")


## ----echo = TRUE--------------------------------------------------------------
goni_cartesian = spherical_to_cartesian(goni_spherical[, 2:3])


## ----echo = TRUE, eval = TRUE-------------------------------------------------
t = goni_spherical[, 1]
dimension = 15
initial_knots = knots_quantile(t, dimension = dimension)
lambda_seq = exp(seq(log(1e-07), log(1), length = 40))

fit = penalized_linear_spherical_spline(t = t, y = goni_cartesian,
                                        dimension = dimension,
                                        initial_knots = initial_knots,
                                        lambdas = lambda_seq)
# choose a curve that minimizes the BIC
best_index = which.min(fit$bic_list)
best_index
fit$dimension_list[best_index]
fit[[best_index]]$control_points


## ----echo = TRUE--------------------------------------------------------------
lambda_seq[best_index]


## ----Goni, fig.show='hold', out.width="49%", fig.cap="Plots of the Goni path (red line) and the associated control points (blue points) obtained from the proposed method. The path goes from left to right in the plots. The left plot displays the path on the globe, and the right plot is a zoomed in version of the left plot on the projection map.", fig.subcap=c("",""), fig.align='center'----
knitr::include_graphics("figures/Gonidata_worldmap.png")
knitr::include_graphics("figures/Gonidata_zoommap.png")


## ----echo = FALSE, eval = FALSE-----------------------------------------------
# worldMap = getMap()
# worldMap_sf = st_as_sf(worldMap)
# 
# cp_best = cartesian_to_spherical(fit[[best_index]]$control_points)
# cp_long_lat = cp_best * 180 / pi
# cp_long_lat_df = data.frame(latitude = 90-cp_long_lat[, 1],
#                             longitude = cp_long_lat[,2])
# 
# goni_spherical_df = data.frame(goni_spherical)
# goni_spherical_df$latitude = 90 - goni_spherical_df$latitude * 180 / pi
# goni_spherical_df$longitude = goni_spherical_df$longitude * 180 / pi
# 
# fitted_geodesic_curve = piecewise_geodesic(seq(0, 1, length = 2000),
#                                            fit[[best_index]]$control_points,
#                                            fit[[best_index]]$knots)
# fitted_cs = cartesian_to_spherical(fitted_geodesic_curve)
# fitted_cs_long_lat = fitted_cs * 180 / pi
# fitted_cs_long_lat_df = data.frame(latitude = 90 - fitted_cs_long_lat[, 1],
#                                    longitude = fitted_cs_long_lat[, 2])
# 
# goni_spherical_df_sf = st_as_sf(goni_spherical_df,
#                                 coords = c("longitude", "latitude"), crs = 4326)
# cp_long_lat_df_sf = st_as_sf(cp_long_lat_df,
#                              coords = c("longitude", "latitude"), crs = 4326)
# fitted_cs_long_lat_df_sf = st_as_sf(fitted_cs_long_lat_df,
#                                     coords = c("longitude", "latitude"), crs = 4326)
# 
# worldmap = ggplot() +
#   geom_sf(data = worldMap_sf, color = "grey", fill = "antiquewhite") +
#   geom_sf(data = goni_spherical_df_sf, size = 0.8) +
#   geom_sf(data = cp_long_lat_df_sf, color = "blue", shape = 23, size = 4) +
#   geom_sf(data = fitted_cs_long_lat_df_sf, color = "red", size = 0.5) +
#   xlab("longitude") +
#   ylab("latitude") +
#   scale_y_continuous(breaks = (-2:2) * 30) +
#   scale_x_continuous(breaks = (-4:4) * 45) +
#   coord_sf(crs = "+proj=ortho +lat_0=38 +lon_0=120 +y_0=0 +ellps=WGS84 +no_defs")
# worldmap
# 
# mar = 20
# zoommap = ggplot() +
#   geom_sf(data = worldMap_sf, color = "grey", fill = "antiquewhite") +
#   geom_sf(data = goni_spherical_df_sf, size = 0.8) +
#   geom_sf(data = cp_long_lat_df_sf, color = "blue", shape = 23, size = 4) +
#   geom_sf(data = fitted_cs_long_lat_df_sf, color = "red", size = 0.5) +
#   xlab("longitude") +
#   ylab("latitude") +
#   scale_y_continuous(breaks = (-2:2) * 30) +
#   scale_x_continuous(breaks = (-4:4) * 45) +
#   coord_sf(xlim = c(min(cp_long_lat_df$longitude) - mar,
#                     max(cp_long_lat_df$longitude) + mar),
#            ylim = c(min(cp_long_lat_df$latitude) - mar,
#                     max(cp_long_lat_df$latitude) + mar))
# zoommap

