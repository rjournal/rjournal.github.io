% !TeX root = RJwrapper.tex
\title{Sparse Model Matrices for Multidimensional Hierarchical Aggregation}


\author{by Ã˜yvind Langsrud}

\maketitle

\abstract{%
Multidimensional hierarchical sum aggregations can be formulated as matrix multiplications involving dummy matrices which can be referred to as model matrices. In contrast to standard model matrices, all categories of all variables must be included. For this purpose, the R package SSBtools includes functionality to create model matrices in two alternative ways, by model formulas or by so-called hierarchies. The latter means a coding of hierarchical relationships, and this can be done in several ways. Tree-shaped hierarchies are not required. The internal standard in the package is a parent-child coding. Functionality to find hierarchies automatically from the data is also included. The model matrix functionality is applied in several R packages for statistical disclosure control. This enables general implementation of methods and a flexible user interface. This paper describes the model matrix and hierarchy functions in SSBtools, as well as the methods and functions behind it.
}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

In general, a vector of sum aggregates (\(z\)) can be calculated from a data vector (\(y\)) through a dummy matrix (\(x\)) by

\begin{equation} 
 z = x^{T}y 
   \label{eq:eq1}
\end{equation}

The matrix \(x\) can be referred to as a model matrix.
In package \CRANpkg{SSBtools} (Langsrud and Lupp 2023b) there are several tools for creating such model matrices and for computing aggregates via such matrices.
This article focuses on these tools, while there are additional tools included in the package that are not addressed herein.
Note that the package gathers functions that are used by other packages for specific purposes.

For some applications it is important to have access to the model matrix.
In other applications, the interface or the computational efficiency is what is needed.
For efficiency, the aggregates may sometimes be computed by

\begin{equation} 
 z = x_{1}^{T}y x_{2}
   \label{eq:eq2}
\end{equation}

where \(y\) is a matrix of input data that is appropriately reorganized into multiple columns and where \(x_{1}\) and \(x_{2}\) are two dummy matrices.

An important part of the model matrix framework within \CRANpkg{SSBtools} is the handling of hierarchical relationships.
That is, the categorical variables in the input data are hierarchically related.
Or, alternatively, some codings of hierarchical relationships, such as parent-child, are supplied as separate input.
We refer to these codings as hierarchies and these are not limited to being tree-shaped.
Hierarchies are used both in the process of constructing the model matrix and also to organize the categorical variables in the aggregated output data.

Model matrices are usually associated with regression models which can be expressed by model formulas and fitted by the \texttt{lm} function or by other more advanced functions.
In this article, we will also use model formulas to specify model matrices.
For this purpose, only the right-hand side of a model formula is needed.
A formula consisting of the variables \texttt{a} and \texttt{b} including the interaction (\texttt{a:b}) can be written as \texttt{\textasciitilde{}a\ +\ b\ +\ a:b}, or equivalently as \texttt{\textasciitilde{}a\ *\ b}.
By using model formulas, we can take advantage of the asterisk sign and other possibilities to write comprehensive models in compact ways (see \texttt{?formula} in an interactive R console).
The intercept term, which is included by default, can be removed by subtracting a one (\texttt{\textasciitilde{}a\ *\ b\ -\ 1}).
In the model matrix, the intercept term is a column of ones.
In our context, we would rather refer to this model term as the overall total.

Most elements of the model matrices considered in this paper will be zero.
When using regular dense matrices, as created by the base-R function \texttt{matrix}, an unnecessary amount of memory is used to store all the zeros.
Instead, we use sparse matrices defined in the \CRANpkg{Matrix} package (Bates, Maechler, and Jagan 2023).
Then the matrices are stored in a compressed format, while ordinary matrix operations can still be performed.
In many cases, the matrices will be so large that applications which do not utilize sparse matrices will be impossible in practice.
Please note that the functions discussed in this article do not create any new classes.
The primary outputs of these functions include sparse matrices according to \CRANpkg{Matrix}, data frames, or a combination of both in the form of lists.

The rest of this paper is structured as follows.
First, we describe the function, \texttt{ModelMatrix}, for generating model matrices.
The following section takes a closer look at some underlying computations.
Then, a section is devoted to a more advanced function for two-way computation. Within this function, equation \eqref{eq:eq2} is applied.
The next section looks at aggregation beyond summation, such as median calculation.
Then, there is a section where various alternatives for creating model matrices and aggregates are compared in terms of both time and memory usage.
In the penultimate section, we consider applications in other packages.
Finally, a short conclusion is given.

The theory in this paper is described using examples and R code.

\hypertarget{the-function-modelmatrix}{%
\section{\texorpdfstring{The function \texttt{ModelMatrix}}{The function ModelMatrix}}\label{the-function-modelmatrix}}

The base-R function \texttt{model.matrix} is a workhorse function for constructing model or design matrices used in regression modeling.
To create sparse matrices, the corresponding function \texttt{sparse.model.matrix} in the \CRANpkg{Matrix} package (Bates, Maechler, and Jagan 2023) can be used.
When all variables involved are categorical, the model matrices are dummy matrices of zeroes and ones.
The function \texttt{ModelMatrix} in package \CRANpkg{SSBtools} is an alternative function with a slightly different purpose.
The aim is to represent the transformation from input to output when producing various types of aggregated data.
As described below, the model matrix can be constructed with both a formula interface and a hierarchy interface.

\hypertarget{model-matrix-from-formula}{%
\subsection{Model matrix from formula}\label{model-matrix-from-formula}}

In the examples below, \texttt{d} is a data frame.

\begin{verbatim}
> d
\end{verbatim}

\begin{verbatim}
    age      geo    eu value
1 young    Spain    EU  66.9
2 young  Iceland nonEU   1.8
3 young Portugal    EU  11.6
4   old    Spain    EU 120.3
5   old  Iceland nonEU   1.5
6   old Portugal    EU  20.2
\end{verbatim}

A model matrix can be specified with a formula.

\begin{verbatim}
> ModelMatrix(d, formula = ~age + geo)
\end{verbatim}

\begin{verbatim}
     Total-Total old-Total young-Total Total-Iceland Total-Portugal Total-Spain
[1,]           1         .           1             .              .           1
[2,]           1         .           1             1              .           .
[3,]           1         .           1             .              1           .
[4,]           1         1           .             .              .           1
[5,]           1         1           .             1              .           .
[6,]           1         1           .             .              1           .
\end{verbatim}

In contrast to standard model matrices, all categories are included.
All variables are considered categorical.
The column names correspond to rows in a data frame, called \texttt{crossTable}, which can be requested as output.
Such a model matrix can be used to compute aggregates according to \eqref{eq:eq1}, for example by:

\begin{verbatim}
> t(ModelMatrix(d, formula = ~age + geo)) %*% d$value
\end{verbatim}

\begin{verbatim}
                [,1]
Total-Total    222.3
old-Total      142.0
young-Total     80.3
Total-Iceland    3.3
Total-Portugal  31.8
Total-Spain    187.2
\end{verbatim}

Exactly the same aggregates can be computed more directly using
a related \CRANpkg{SSBtools} function: \texttt{FormulaSums(d,\ formula\ =\ value\textasciitilde{}age\ +\ geo)}.
With this function, the aggregates are computed somewhat faster when the data is large.
Internally, each model term triggers a call to the function \texttt{aggregate}.
Correspondingly, \texttt{ModelMatrix} calls the \texttt{Matrix} function \texttt{fac2sparse} repeatedly.
Note that the formula interface within \texttt{aggregate} is different from our approach.
The formula \texttt{\textasciitilde{}age\ +\ geo} interpreted by \texttt{aggregate} corresponds to \texttt{\textasciitilde{}age:geo\ -\ 1} interpreted by \texttt{ModelMatrix} or \texttt{FormulaSums}.
So the formula interface in \texttt{aggregate} is less flexible.
For example,
\texttt{aggregate(value\ \textasciitilde{}age\ +\ geo,\ d,\ sum)} and
\texttt{aggregate(value\ \textasciitilde{}age\ *\ geo,\ d,\ sum)} give the same results.

To illustrate hierarchical variables, we proceed with a more complicated formula:

\begin{verbatim}
> ModelMatrix(d, formula = ~age*eu + geo, crossTable = TRUE)
\end{verbatim}

\begin{verbatim}
$modelMatrix
\end{verbatim}

\begin{verbatim}
  [[ suppressing 12 column names 'Total-Total', 'old-Total', 'young-Total' ... ]]
\end{verbatim}

\begin{verbatim}
                            
[1,] 1 . 1 1 . . . 1 . . 1 .
[2,] 1 . 1 . 1 1 . . . . . 1
[3,] 1 . 1 1 . . 1 . . . 1 .
[4,] 1 1 . 1 . . . 1 1 . . .
[5,] 1 1 . . 1 1 . . . 1 . .
[6,] 1 1 . 1 . . 1 . 1 . . .

$crossTable
     age      geo
1  Total    Total
2    old    Total
3  young    Total
4  Total       EU
5  Total    nonEU
6  Total  Iceland
7  Total Portugal
8  Total    Spain
9    old       EU
10   old    nonEU
11 young       EU
12 young    nonEU
\end{verbatim}

The column names suppressed from the \texttt{\$modelMatrix} output can be seen in \texttt{\$crossTable}.
Here there are two variables in \texttt{crossTable} even though there are three in the formula. This is because it has automatically been discovered that \texttt{geo} and \texttt{eu} are hierarchically related. Combining hierarchical variables in this way is often useful and this is common within official statistics. Automatic detection and handling of hierarchical relationships can be turned off with the \texttt{avoidHierarchical} parameter. The calculations made in the background are related to the automatic generation of hierarchies discussed below.

Note that \texttt{ModelMatrix} does not define any new classes.
The dummy matrix will have a sparse matrix class according to \CRANpkg{Matrix}.
Though, an attribute called \texttt{startCol} has been added to make locating individual model terms easy
and a related function, \texttt{FormulaSelection}, is available in \CRANpkg{SSBtools}.

\hypertarget{model-matrix-from-hierarchies}{%
\subsection{Model matrix from hierarchies}\label{model-matrix-from-hierarchies}}

From the data we can generate hierarchies coded as trees:

\begin{verbatim}
> dimLists <- FindDimLists(d[c("age", "geo", "eu")])
> dimLists 
\end{verbatim}

\begin{verbatim}
$age
  levels codes
1      @ Total
2     @@   old
3     @@ young

$geo
  levels    codes
1      @    Total
2     @@       EU
3    @@@ Portugal
4    @@@    Spain
5     @@    nonEU
6    @@@  Iceland
\end{verbatim}

\begin{figure}
\includegraphics[width=1\linewidth]{figures/young_old_EU_nonEU_Total} \caption{The hierarchies in the examples.}\label{fig:fig1}
\end{figure}

The two hierarchies are illustrated in Figure \ref{fig:fig1}.
This way of coding hierarchies follows the standard used in the R package \CRANpkg{sdcTable} (Meindl 2023),
which is a tool for statistical disclosure control (SDC) (Hundepool et al. 2012).
A model matrix can be constructed from the data and the hierarchies.

\begin{verbatim}
> ModelMatrix(d[-6, -3], hierarchies = dimLists, inputInOutput = c(TRUE, FALSE), 
+             crossTable = TRUE)
\end{verbatim}

\begin{verbatim}
$modelMatrix
\end{verbatim}

\begin{verbatim}
  [[ suppressing 9 column names 'Total:Total', 'Total:EU', 'Total:nonEU' ... ]]
\end{verbatim}

\begin{verbatim}
                      
[1,] 1 1 . . . . 1 1 .
[2,] 1 . 1 . . . 1 . 1
[3,] 1 1 . . . . 1 1 .
[4,] 1 1 . 1 1 . . . .
[5,] 1 . 1 1 . 1 . . .

$crossTable
    age   geo
1 Total Total
2 Total    EU
3 Total nonEU
4   old Total
5   old    EU
6   old nonEU
7 young Total
8 young    EU
9 young nonEU
\end{verbatim}

By default, with hierarchy input, all possible combinations are made.
Here, parameter \texttt{inputInOutput} is used to prevent columns being constructed from input codes for \texttt{geo} (country names).
The \texttt{eu} column (3rd) was removed from the input data to illustrate that this column is not being used.
Instead, the information about \texttt{EU} and \texttt{nonEU} is now given in the hierarchy.
The last row (6th) was also removed to illustrate that complete data is not required.
Either way, the rows in the output correspond to the rows in the input.

An alternative coding of the above hierarchies follow the standard used in the SDC program called \(\tau\)-Argus (Wolf et al. 2014). Conversion to and from this standard is possible:

\begin{verbatim}
> hrc <- DimList2Hrc(dimLists)
> hrc
\end{verbatim}

\begin{verbatim}
$age
[1] "old"   "young"

$geo
[1] "EU"        "@Portugal" "@Spain"    "nonEU"     "@Iceland" 
\end{verbatim}

However, the standard we use within the framework of \texttt{ModelMatrix} is more general and tree-shaped hierarchies are not required.
By the function \texttt{AutoHierarchies}, hierarchies coded in several ways are converted to our internal standard.
As shown below, it is also possible to specify total codes.

\begin{verbatim}
> hi <- AutoHierarchies(hrc, total = c("All", "Europe"))
> hi
\end{verbatim}

\begin{verbatim}
$age
  mapsFrom mapsTo sign level
1      old    All    1     1
2    young    All    1     1

$geo
  mapsFrom mapsTo sign level
1       EU Europe    1     2
2 Portugal     EU    1     1
3    Spain     EU    1     1
4    nonEU Europe    1     2
5  Iceland  nonEU    1     1
\end{verbatim}

The variable names \texttt{mapsFrom} and \texttt{mapsTo} were chosen because the starting point was to reprogram an application implemented in the
Validation and Transformation Language (VTL) described in Airo et al. (2015).
The level variable indicates the order in which the codes must be calculated.
This variable can be computed automatically and is not needed in input.
Sign, as coded in the \texttt{sign} column, can also be negative (\texttt{-1}), which means subtraction instead of addition.
The hierarchies can be very general (but not circular) and it is possible that the final model matrix consists of values beyond zeros and ones. A dummy matrix can be ensured by \texttt{unionComplement\ =\ TRUE}.
Then, in accordance with VTL, \texttt{sign} is interpreted as union or complement instead of addition or subtraction.

Another possible coding that can be input to \texttt{AutoHierarchies} is formulas.
This should not be confused with model formulas in the section above.
Conversion to formulas from the internal standard is possible.

\begin{verbatim}
> Hierarchies2Formulas(hi)
\end{verbatim}

\begin{verbatim}
$age
[1] "All = old + young"

$geo
[1] "Europe = EU + nonEU"   "EU = Portugal + Spain" "nonEU = Iceland"      
\end{verbatim}

By using the parameter \texttt{select}, the columns in the model matrix, i.e.~\texttt{crossTable}, can be specified in advance.
This can be much more efficient than making the selection afterwards.

\begin{verbatim}
> ModelMatrix(d, hierarchies = hi, select = data.frame(
+             age = c("young", "young", "All", "All"), 
+             geo = c("EU", "nonEU", "nonEU", "Europe")))
\end{verbatim}

\begin{verbatim}
     young:EU young:nonEU All:nonEU All:Europe
[1,]        1           .         .          1
[2,]        .           1         1          1
[3,]        1           .         .          1
[4,]        .           .         .          1
[5,]        .           .         1          1
[6,]        .           .         .          1
\end{verbatim}

With few rows in input, many columns in the model matrix will only consist of zeros. As illustrated below, such columns can be omitted by the parameter, \texttt{removeEmpty}.

\begin{verbatim}
> ModelMatrix(d[c(1, 4), ], hierarchies = hi, removeEmpty = TRUE)
\end{verbatim}

\begin{verbatim}
     All:Europe All:EU All:Spain old:Europe old:EU old:Spain young:Europe
[1,]          1      1         1          .      .         .            1
[2,]          1      1         1          1      1         1            .
     young:EU young:Spain
[1,]        1           1
[2,]        .           .
\end{verbatim}

Due to \texttt{removeEmpty}, nine columns were omitted (\texttt{"All"}, \texttt{"old"} and \texttt{"young"} crossed with \texttt{"nonEU"}, \texttt{"Iceland"} and \texttt{"Portugal"}).
In large real data sets, the effect of \texttt{removeEmpty} can be enormous.

Two special possibilities are that the hierarchies can be encoded as a string or as an empty string.
A string is considered a total code. An empty string means that the variable is considered a pure categorical variable without a hierarchy.

\begin{verbatim}
> ModelMatrix(d[c(1,2,4), ], hierarchies = list(age = "", geo = "Europe"))
\end{verbatim}

\begin{verbatim}
     old:Europe old:Iceland old:Spain young:Europe young:Iceland young:Spain
[1,]          .           .         .            1             .           1
[2,]          .           .         .            1             1           .
[3,]          1           .         1            .             .           .
\end{verbatim}

In this case only two countries are present in the input data. If \texttt{removeEmpty} had been \texttt{TRUE}, the \texttt{old:Iceland} column would have been omitted.

Note that both \texttt{ModelMatrix} parameters, \texttt{hierarchies} and \texttt{formula}, can be used simultaneously.
How the hierarchies are to be crossed is then defined by the formula.

\hypertarget{underlying-computations}{%
\section{Underlying computations}\label{underlying-computations}}

\hypertarget{hierarchies-automatically-from-the-data}{%
\subsection{Hierarchies automatically from the data}\label{hierarchies-automatically-from-the-data}}

To find hierarchies automatically from the data, a kind of correlation matrix is first computed by the function \texttt{FactorLevCorr}.
The function was named with factor variables and their levels in mind, but any variable type is possible.
To illustrate a little more complexity, we add \texttt{isSpain} as a logical variable.

\begin{verbatim}
> d$isSpain <- d$geo == "Spain"
> fCorr <- FactorLevCorr(d[c("age", "geo", "eu", "isSpain")])
> fCorr
\end{verbatim}

\begin{verbatim}
        age geo   eu isSpain
age       2   0  0.0     0.0
geo       0   3 -1.0    -1.0
eu        0   1  2.0     0.5
isSpain   0   1 -0.5     2.0
\end{verbatim}

The diagonal elements in this matrix are used to store the number of unique values of each variable (\(n_i\)).
To calculate our correlations, we first find the number of unique combinations (\(m_{ij}\)) of each pair of variables.
For this purpose, the function, \texttt{unique}, is repeatedly called with two-column data frames as input.
The absolute values of off-diagonal elements are
\(0\) when \(m_{ij} = n_i*n_j\),
\(1\) when \(m_{ij} = \max(n_i, n_j)\) and otherwise computed as
\((n_i*n_j-m_{ij})/(n_i*n_j-\max(n_i, n_j))\).
So \(0\) means that all possible level combinations exist in the data and \(1\) means that the two variables are hierarchically related. In our example the correlation between \texttt{eu} and \texttt{isSpain} isn't zero since the combination (\texttt{nonEU}, \texttt{TRUE}) is missing in the data.
The signs of off-diagonal elements are set to be positive when \(n_i<n_j\) and negative when \(n_i>n_j\).
In cases where \(n_i=n_j\), elements will be positive above the diagonal and negative below.
Values other than \(0\), \(-1\) and \(1\) could be useful for detecting errors in the data. For example, values close to one may be suspicious.

In our application, to generate hierarchies, we only need to look for ones.
A one means that two hierarchically related variables are found.
More generally, one can find trees by connecting relations when the variables are ordered according to the diagonal elements.
The function, \texttt{HierarchicalGroups}, does this repeatedly using a recursive algorithm so that all possible trees are found.
Below we run this function with \texttt{eachName\ =\ TRUE} so that names are included instead of indices.

\begin{verbatim}
> HierarchicalGroups(fCorr = fCorr, eachName = TRUE)
\end{verbatim}

\begin{verbatim}
$age
[1] "age"

$geo
[1] "geo" "eu" 

$geo
[1] "geo"     "isSpain"
\end{verbatim}

Here two groups were named \texttt{geo}. This means also that \texttt{FindDimLists} will result in two hierarchies named \texttt{geo}.
Each hierarchy is achieved by looking at sorted unique rows.
For example, this hierarchy,

\begin{verbatim}
> FindDimLists(d[c("age", "geo", "eu", "isSpain")])[[3]]
\end{verbatim}

\begin{verbatim}
  levels    codes
1      @    Total
2     @@    FALSE
3    @@@  Iceland
4    @@@ Portugal
5     @@     TRUE
6    @@@    Spain
\end{verbatim}

was constructed from this data frame:

\begin{verbatim}
> SSBtools::SortRows(unique(d[c("isSpain", "geo")]))
\end{verbatim}

\begin{verbatim}
  isSpain      geo
2   FALSE  Iceland
3   FALSE Portugal
1    TRUE    Spain
\end{verbatim}

The top level (\texttt{@}) is always the total code. The remaining levels correspond to the columns in the data as defined by the hierarchical groups.
Here this means \texttt{"isSpain"} (\texttt{@@}) and \texttt{"geo"} (\texttt{@@@}).

Note that the corresponding function \texttt{FindHierarchies} produces only a single \texttt{geo} hierarchy.

\begin{verbatim}
> FindHierarchies(d[c("age", "geo", "eu", "isSpain")])$geo
\end{verbatim}

\begin{verbatim}
  mapsFrom mapsTo sign level
1  Iceland  nonEU    1     1
2  Iceland  Total    1     1
3  Iceland  FALSE    1     1
4 Portugal     EU    1     1
5 Portugal  Total    1     1
6 Portugal  FALSE    1     1
7    Spain     EU    1     1
8    Spain  Total    1     1
9    Spain   TRUE    1     1
\end{verbatim}

\texttt{FindHierarchies} wraps \texttt{FindDimLists} and \texttt{AutoHierarchies} into a single function.
By default, when multiple hierarchies exist for the same variable, \texttt{AutoHierarchies} combines them by generating a flattened hierarchy with a single level.
The output codes are the parents (\texttt{mapsTo}) and all childs (\texttt{mapsFrom}) are input codes.
Parent-child relationships corresponding to multilevel tree structures are not directly available,
but the information needed to create model matrices is available.
In fact, the hierarchies are combined via dummy matrices described below.

\hypertarget{from-hierarchies-to-dummy-matrices}{%
\subsection{From hierarchies to dummy matrices}\label{from-hierarchies-to-dummy-matrices}}

To produce model matrices, the hierarchies are converted to dummy matrices and the parameter \texttt{inputInOutput} is used.
Here we convert the hierarchies, \texttt{hi}, in the previous section:

\begin{verbatim}
> hiM <- DummyHierarchies(hi, inputInOutput = c(TRUE, FALSE))
> hiM
\end{verbatim}

\begin{verbatim}
$age
      old young
old     1     .
young   .     1
All     1     1

$geo
       Iceland Portugal Spain
EU           .        1     1
nonEU        1        .     .
Europe       1        1     1
\end{verbatim}

The first two rows of \texttt{hiM\$age} are a perturbed identity matrix since \texttt{inputInOutput\ =\ TRUE} for this variable.
The first two rows of \texttt{hiM\$geo} can be found directly from the level 1 rows of the hierarchy, \texttt{hi\$geo}.
The nonzero elements are taken from the \texttt{sign} variable and the corresponding rows and columns can be read from the variables \texttt{mapsFrom} and \texttt{mapsTo}, respectively.
A similar matrix can be constructed from level 2. In our example this matrix is:

\begin{verbatim}
> geo2 <- Matrix(1, 1, 2, dimnames = list("Europe", c("EU", "nonEU")))
> geo2
\end{verbatim}

\begin{verbatim}
       EU nonEU
Europe  1     1
\end{verbatim}

The last row of \texttt{hiM\$geo} can now be found by the matrix multiplication:

\begin{verbatim}
> geo2 %*% hiM$geo[1:2, ]
\end{verbatim}

\begin{verbatim}
       Iceland Portugal Spain
Europe       1        1     1
\end{verbatim}

In general, the dummy matrix is constructed successively by adding one level at a time. The new rows are found as a matrix constructed from the new level multiplied by the preliminary dummy matrix. The parameter \texttt{unionComplement} mentioned above is used within this process.

The next step is to extend these matrices to match the data and this can be achieved by the function \texttt{DataDummyHierarchies}:

\begin{verbatim}
> hiD <- DataDummyHierarchies(d, hiM, colNamesFromData = TRUE)
> hiD
\end{verbatim}

\begin{verbatim}
$age
      young young young old old old
old       .     .     .   1   1   1
young     1     1     1   .   .   .
All       1     1     1   1   1   1

$geo
       Spain Iceland Portugal Spain Iceland Portugal
EU         1       .        1     1       .        1
nonEU      .       1        .     .       1        .
Europe     1       1        1     1       1        1
\end{verbatim}

For readability \texttt{colNamesFromData} was here set to \texttt{TRUE}.
This also means that the relationship to \texttt{hiM} is direct.
Now a transposed model matrix can be achieved by the function \texttt{KhatriRao} (column-wise Kronecker product) within the Matrix package.

\begin{verbatim}
> Matrix::KhatriRao(hiD$geo, hiD$age, make.dimnames = TRUE)
\end{verbatim}

\begin{verbatim}
             Spain Iceland Portugal Spain Iceland Portugal
old:EU           .       .        .     1       .        1
young:EU         1       .        1     .       .        .
All:EU           1       .        1     1       .        1
old:nonEU        .       .        .     .       1        .
young:nonEU      .       1        .     .       .        .
All:nonEU        .       1        .     .       1        .
old:Europe       .       .        .     1       1        1
young:Europe     1       1        1     .       .        .
All:Europe       1       1        1     1       1        1
\end{verbatim}

Now the column names are misleading since only names from the first input matrix are used. However, the row names can be useful.
With more than two variables, \texttt{KhatriRao} is run several times by adding one variable at a time.

We now recall how a model matrix with pre-selected columns was created in the previous section using the \texttt{select} parameter to \texttt{ModelMatrix}.
When we look at dummy matrices here, this means pre-selected rows.
To produce such a matrix with pre-selected rows, one possibility is to first produce separate matrices for each variable.

\begin{verbatim}
> hiD$age[c("young", "young", "All", "All"), ]
\end{verbatim}

\begin{verbatim}
      young young young old old old
young     1     1     1   .   .   .
young     1     1     1   .   .   .
All       1     1     1   1   1   1
All       1     1     1   1   1   1
\end{verbatim}

\begin{verbatim}
> hiD$geo[c("EU", "nonEU", "nonEU", "Europe"), ]
\end{verbatim}

\begin{verbatim}
       Spain Iceland Portugal Spain Iceland Portugal
EU         1       .        1     1       .        1
nonEU      .       1        .     .       1        .
nonEU      .       1        .     .       1        .
Europe     1       1        1     1       1        1
\end{verbatim}

The transposed model matrix is then obtained by multiplying these matrices together.
This is a fast way to obtain the model matrix.
A possible problem is, however, that the matrices to be multiplied are not as sparse as the final matrix.
Therefore \texttt{KhatriRao} combined with reducing the matrices as much as possible first, can still be better.
The choice between the two methods is controlled by a parameter, called \texttt{selectionByMultiplicationLimit}.
The functionality of the parameter \texttt{removeEmpty} mentioned above, is implemented by \texttt{KhatriRao} combined with reducing the matrices.

\hypertarget{two-way-computation}{%
\section{Two-way computation}\label{two-way-computation}}

\hypertarget{the-function-hierarchycompute}{%
\subsection{\texorpdfstring{The function \texttt{HierarchyCompute}}{The function HierarchyCompute}}\label{the-function-hierarchycompute}}

We recall that sum aggregates of a data vector (\(y\)) can be calculated by equation \eqref{eq:eq1} where the model matrix (\(x\)) can be produced by the function \texttt{ModelMatrix}.
As mentioned above, with formula input an alternative function is \texttt{FormulaSums}. Then the aggregates are calculated without \(x\) being created.
In the cases of hierarchies, a corresponding function is \texttt{HierarchyCompute}.
Although this function makes aggregates via one or two dummy matrices, a model matrix that matches the input data is not necessarily made.
A special case of \texttt{HierarchyCompute} is to make such a model matrix and this matrix can also be requested as output.
Actually, \texttt{ModelMatrix} with hierarchy input make use of \texttt{HierarchyCompute}.
The \texttt{HierarchyCompute} function does not take many hierarchy types as input, so \texttt{AutoHierarchies} may have to be run first.

In general, aggregates are computed by \texttt{HierarchyCompute} according to equation \eqref{eq:eq2}.
But the original version of the function, without the \texttt{colVar} parameter, is limited to equation \eqref{eq:eq1}.
However, \(y\) may be a multi-column matrix containing a reorganized version of the input data vector.
Then the columns represent a single categorical variable with no hierarchy.
To tell \texttt{HierarchyCompute} to treat a categorical variable in this way,
this categorical variable is encoded as the string \texttt{"colFactor"} in the hierarchy input.
Other categorical variables are encoded as \texttt{"rowFactor"}.
The function \texttt{AutoHierarchies} re-encodes an empty string to \texttt{"rowFactor"}.

To illustrate this function, we add an extra variable, \texttt{year}, to the data. Although, it is only a single year.

\begin{verbatim}
> HierarchyCompute(data = cbind(d, year = 2022), 
+      hierarchies = list(age = "colFactor", geo = hi$geo, year = "rowFactor"), 
+      valueVar = "value")
\end{verbatim}

\begin{verbatim}
    age    geo year value
1   old     EU 2022 140.5
2   old  nonEU 2022   1.5
3   old Europe 2022 142.0
4 young     EU 2022  78.5
5 young  nonEU 2022   1.8
6 young Europe 2022  80.3
\end{verbatim}

Except for column and row order, the output will be the same if \texttt{"rowFactor"} and \texttt{"colFactor"} are swapped or if both \texttt{age} and \texttt{year} are set to \texttt{"rowFactor"}.
If \texttt{output\ =\ "matrixComponents"} is included in the function call, the internal differences can be seen. Then, in our example, output become:

\begin{verbatim}
> hc <- HierarchyCompute(data = cbind(d, year = 2022), 
+            hierarchies = list(age = "colFactor", geo = hi$geo, year = "rowFactor"), 
+            valueVar = "value", output = "matrixComponents")
> hc
\end{verbatim}

\begin{verbatim}
$dataDummyHierarchy
                 
EU:2022     . 1 1
nonEU:2022  1 . .
Europe:2022 1 1 1

$valueMatrix
       old young
[1,]   1.5   1.8
[2,]  20.2  11.6
[3,] 120.3  66.9

$fromCrossCode
       geo year
1  Iceland 2022
2 Portugal 2022
3    Spain 2022

$toCrossCode
     geo year
1     EU 2022
2  nonEU 2022
3 Europe 2022
\end{verbatim}

The matrix, \texttt{valueMatrix} is a reorganized version of the value variable in the input data.
If a variable is selected as \texttt{"colFactor"}, there is one column for each level of that variable.
Even without such a variable, there may be fewer rows in the \texttt{valueMatrix} than in the input data.
This is because rows where the values are zero can be removed and because duplicated code combinations in the input can be aggregated.
This is controlled by parameters \texttt{"reduceData"} and \texttt{"handleDuplicated"}.
The data frame \texttt{fromCrossCode} contains variables that characterize the rows of \texttt{valueMatrix}.
The matrix \texttt{dataDummyHierarchy} is a transposed model matrix that matches \texttt{valueMatrix}.
This means that the aggregate output values can be calculated as \texttt{dataDummyHierarchy\ \%*\%\ valueMatrix}:

\begin{verbatim}
> hc$dataDummyHierarchy %*% hc$valueMatrix
\end{verbatim}

\begin{verbatim}
              old young
EU:2022     140.5  78.5
nonEU:2022    1.5   1.8
Europe:2022 142.0  80.3
\end{verbatim}

The data frame \texttt{toCrossCode} contains variables that characterize the rows of this matrix.
Along with column names, this is the information needed to reorganize the aggregate result into a regular output data frame.

\hypertarget{hierarchycompute-with-colvar}{%
\subsection{\texorpdfstring{\texttt{HierarchyCompute} with \texttt{colVar}}{HierarchyCompute with colVar}}\label{hierarchycompute-with-colvar}}

When the parameter \texttt{colVar} is applied, two (transposed) model matrices are made,
one for rows and one for columns.
Parameter \texttt{colVar} splits the hierarchy variables in two groups and this variable overrides the difference between \texttt{"rowFactor"} and \texttt{"colFactor"}.
Actually, there will be two runs of \texttt{HierarchyCompute}.
With \texttt{output\ =\ "matrixComponents"}, output from the two runs are returned as a list with elements \texttt{hcRow} and \texttt{hcCol}.
Below we illustrate this by including the age hierarchy with \texttt{inputInOutput\ =\ TRUE} (\texttt{FALSE} is default).

\begin{verbatim}
> hc2 <- HierarchyCompute(data = cbind(d, year = 2022), 
+             hierarchies = list(age = hi$age, geo = hi$geo, year = "rowFactor"), 
+             colVar = "age", inputInOutput = c(TRUE, FALSE),
+             valueVar = "value", output = "matrixComponents")
\end{verbatim}

For rows, we obtain the same matrices as earlier. The aggregates in the previous subsection can now be computed as:

\begin{verbatim}
> hc2$hcRow$dataDummyHierarchy %*% hc2$hcRow$valueMatrix
\end{verbatim}

\begin{verbatim}
                1    2
EU:2022     140.5 78.5
nonEU:2022    1.5  1.8
Europe:2022 142.0 80.3
\end{verbatim}

The model matrix for columns can be seen as:

\begin{verbatim}
> t(hc2$hcCol$dataDummyHierarchy)
\end{verbatim}

\begin{verbatim}
     old young All
[1,]   1     .   1
[2,]   .     1   1
\end{verbatim}

Finally, the aggregate output values can be calculated as:

\begin{verbatim}
> hc2$hcRow$dataDummyHierarchy %*% hc2$hcRow$valueMatrix %*% t(hc2$hcCol$dataDummyHierarchy)
\end{verbatim}

\begin{verbatim}
              old young   All
EU:2022     140.5  78.5 219.0
nonEU:2022    1.5   1.8   3.3
Europe:2022 142.0  80.3 222.3
\end{verbatim}

Taking into account that the dummy matrices are transposed model matrices, equation \eqref{eq:eq2} is applied.
With ordinary output, these values are organized into a data frame and we do not see what is going on internally.

\begin{verbatim}
> HierarchyCompute(data = cbind(d, year = 2022), 
+      hierarchies = list(age = hi$age, geo = hi$geo, year = "rowFactor"), 
+      colVar = "age", inputInOutput = c(TRUE, FALSE),
+      valueVar = "value")
\end{verbatim}

\begin{verbatim}
    age    geo year value
1   old     EU 2022 140.5
2   old  nonEU 2022   1.5
3   old Europe 2022 142.0
4 young     EU 2022  78.5
5 young  nonEU 2022   1.8
6 young Europe 2022  80.3
7   All     EU 2022 219.0
8   All  nonEU 2022   3.3
9   All Europe 2022 222.3
\end{verbatim}

We obtain the same results without specifying \texttt{colVar}.
One reason to use \texttt{colVar} is to do the computations more efficiently.
Another reason may be that the internal matrices may be of interest.
Note that variable combinations for output can be specified by parameters
\texttt{rowSelect}, \texttt{colSelect} and \texttt{select}.
Then \texttt{colVar} also matters.

\hypertarget{aggregation-beyond-summation}{%
\section{Aggregation beyond summation}\label{aggregation-beyond-summation}}

The most recent functions in the \CRANpkg{SSBtools} package are about general aggregation beyond summation.
With respect to future application packages, this is written in a different coding style (lower snake case).
The function \texttt{model\_aggregate} combines the model specification capabilities of \texttt{ModelMatrix} with aggregation with general functions. Below is an example:

\begin{verbatim}
> model_aggregate(d, formula = ~age + eu, 
+                 fun_vars = c(max = "value", median = "value", length = "geo"))
\end{verbatim}

\begin{verbatim}
    age    eu value_max value_median geo_length
1 Total Total     120.3        15.90          6
2   old Total     120.3        20.20          3
3 young Total      66.9        11.60          3
4 Total    EU     120.3        43.55          4
5 Total nonEU       1.8         1.65          2
\end{verbatim}

The underlying computations make use of a model matrix. By default (\texttt{pre\_aggregate\ =\ TRUE}), the number of rows in the input data frame is reduced before \texttt{ModelMatrix} is called.
In practice, this pre-aggregation step is done by running \texttt{aggregate} with \texttt{FUN\ =\ function(x)\{x\}} and \texttt{simplify\ =\ FALSE}.
The individual observations to be aggregated are then included as lists. In this example, the reduced input data is:

\begin{verbatim}
    age    eu       value             geo
1   old    EU 120.3, 20.2 Spain, Portugal
2 young    EU  66.9, 11.6 Spain, Portugal
3   old nonEU         1.5         Iceland
4 young nonEU         1.8         Iceland
\end{verbatim}

The corresponding model matrix is:

\begin{verbatim}
     Total-Total old-Total young-Total Total-EU Total-nonEU
[1,]           1         1           .        1           .
[2,]           1         .           1        1           .
[3,]           1         1           .        .           1
[4,]           1         .           1        .           1
\end{verbatim}

The function \texttt{model\_aggregate} has many possibilities for specifying the aggregation.
Functions of several data variables are possible. Output variable names can be passed as input, even for functions with multiple outputs.
This is possible since \texttt{model\_aggregate} calls \texttt{dummy\_aggregate} (model matrix is input) which calls
\texttt{aggregate\_multiple\_fun} which is an advanced wrapper to \texttt{aggregate}.
The implementation uses indexes to rows, which made it possible to call \texttt{aggregate} only once.
Since matrix multiplication is a fast way to do sum aggregation, this is also included as a possibility in \texttt{model\_aggregate} (parameter \texttt{sum\_vars}).

\hypertarget{comparisons-with-comments}{%
\section{Comparisons with comments}\label{comparisons-with-comments}}

To facilitate comparisons, we utilize hierarchical example data with \(10^i\) rows obtained by crossing \(i\) dimensions.
For each dimension there is a child variable with 10 categories and a parent variable with 3 categories (2, 3 and 5 categories aggregated).
The child and parent variables are named alphabetically by small and capital letters, respectively.
Below is an illustration of a \texttt{HierarchyCompute} call when \(i = 4\), showing eight rows in both the input and output.

\begin{verbatim}
> d <- SSBtoolsData("power10to4")
> d[c(1:4, 3715:3716, 9999:10000), ]
\end{verbatim}

\begin{verbatim}
        a    A   b    B   c    C   d    D
1      a1 A100  b1 B100  c1 C100  d1 D100
2      a2 A100  b1 B100  c1 C100  d1 D100
3      a3 A200  b1 B100  c1 C100  d1 D100
4      a4 A200  b1 B100  c1 C100  d1 D100
3715   a5 A200  b2 B100  c8 C300  d4 D200
3716   a6 A300  b2 B100  c8 C300  d4 D200
9999   a9 A300 b10 B300 c10 C300 d10 D300
10000 a10 A300 b10 B300 c10 C300 d10 D300
\end{verbatim}

\begin{verbatim}
> hi <- FindHierarchies(d)
> d$y <- 1:nrow(d)
> output <- HierarchyCompute(d, hi, "y", inputInOutput = TRUE)
> output[c(1, 5473:5475, 37852:37854, 38416), ]
\end{verbatim}

\begin{verbatim}
          a     b     c     d        y
1        a1    b1    c1    d1        1
5473   A300  B300 Total   d10  2382000
5474  Total  B300 Total   d10  4762750
5475     a1 Total Total   d10   949600
37852    a9   b10  C200 Total   146970
37853  A100   b10  C200 Total   293490
37854  A200   b10  C200 Total   440460
38416 Total Total Total Total 50005000
\end{verbatim}

Here an \texttt{integer} \(y\) is added to the input data. Either way, the variable becomes \texttt{numeric} in the output.
In the comparisons below, the input class is also \texttt{numeric}.
We use \texttt{inputInOutput\ =\ TRUE}, which is the default in \texttt{ModelMatrix}.
With 10 child categories, 3 parent categories, and the inclusion of a total code, this results in \(14^i\) rows in the output.

\begin{table}[p]

\caption{\label{tab:tab1-pdf}User CPU time in seconds based on hierarchical input data with $10^i$ rows, resulting in $14^i$ output aggregates. Thus, the size of the model matrix is $10^i \times 14^i$. The source code is given in Table 3.}
\centering
\begin{tabular}[t]{r|r|r|r|r|r}
\hline
function call & $i = 2$ & $i = 3$ & $i = 4$ & $i = 5$ & $i = 6$\\
\hline
FindHierarchies & 0.010 & 0.032 & 0.392 & 8 & 131\\
\hline
HierarchyCompute & 0.017 & 0.027 & 0.188 & 5 & 147\\
\hline
HierarchyCompute with colVar & 0.018 & 0.028 & 0.086 & 1 & 22\\
\hline
ModelMatrix from hierarchies & 0.014 & 0.026 & 0.229 & 7 & 218\\
\hline
ModelMatrix from formula & 0.016 & 0.083 & 1.294 & 60 & 2922\\
\hline
sparse.model.matrix & 0.026 & 0.173 & 11.703 & 1597 & \\
\hline
model.matrix & 0.004 & 0.024 & 3.238 &  & \\
\hline
FormulaSums & 0.021 & 0.110 & 1.417 & 43 & 1041\\
\hline
median by model\_aggregate & 0.030 & 0.208 & 3.353 & 74 & 1403\\
\hline
\end{tabular}
\vspace{20pt} \end{table}

\begin{table}[p]

\caption{\label{tab:tab2-pdf}Peak RAM in MiB for the calculations described in Tables 1 and 3. For $i\geq 4$, the size of the output object is provided within parentheses, denoted in MiB as well.}
\centering
\begin{tabular}[t]{r|r|r|l|l|l}
\hline
function call & $i = 2$ & $i = 3$ & Â Â Â Â  $i = 4$ & Â Â Â Â  $i = 5$ & Â Â Â Â  $i = 6$\\
\hline
FindHierarchies & 0.9 & 1.9 & Â Â Â Â Â Â Â  12   (0.010) & Â Â Â Â Â Â Â  57   (0.012) & Â Â Â Â Â  610   (0.015)\\
\hline
HierarchyCompute & 3.0 & 3.8 & Â Â Â Â Â Â Â  69   (1.5) & Â Â Â  1074   (25) & Â  30792   (402)\\
\hline
HierarchyCompute with colVar & 1.2 & 2.1 & Â Â Â Â Â Â Â  20   (1.5) & Â Â Â Â Â  201   (25) & Â Â Â  1273   (402)\\
\hline
ModelMatrix from hierarchies & 1.0 & 4.3 & Â Â Â Â Â Â Â  71   (12.2) & Â Â Â  1079   (324) & Â  32246   (9003)\\
\hline
ModelMatrix from formula & 0.7 & 16.8 & Â Â Â Â Â Â Â  71   (12.2) & Â Â Â Â Â  919   (324) & Â  27809   (9003)\\
\hline
sparse.model.matrix & 2.4 & 40.0 & Â Â Â Â Â  536   (13.1) & Â  61654   (333) & Â Â Â Â Â Â Â Â Â \\
\hline
model.matrix & 0.6 & 42.1 & Â Â Â  5864   (2935) & Â Â Â Â Â Â Â Â Â  & Â Â Â Â Â Â Â Â Â \\
\hline
FormulaSums & 1.0 & 18.2 & Â Â Â Â Â  431   (3.1) & Â Â Â  6884   (48) & Â Â Â  1252   (689)\\
\hline
median by model\_aggregate & 0.9 & 15.2 & Â Â Â Â Â  230   (1.5) & Â Â Â  2257   (25) & Â  63435   (402)\\
\hline
\end{tabular}
\vspace{20pt} \end{table}

\begin{table}[p]
\centering
\caption{\label{tab:tab3-pdf}The source code for the calculations underlying Tables 1 and 2. With $i$ defined, the code can be run directly from top to bottom. Be careful not to run \ttfamily{FindHierarchies(d)} with \ttfamily{y} included in \ttfamily{d}.}
\centering
\begin{tabular}[t]{r|>{}l}
\hline
function call, etc. & source code\\
\hline
Input data & \ttfamily{d <- SSBtoolsData(paste0("power10to", i))}\\
\hline
FindHierarchies & \ttfamily{hi <- FindHierarchies(d)}\\
\hline
Adding numeric variable & \ttfamily{d\$y <- as.numeric(1:nrow(d))}\\
\hline
HierarchyCompute & \ttfamily{HierarchyCompute(d, hi, "y", inputInOutput = TRUE)}\\
\hline
HierarchyCompute with colVar & \ttfamily{\shortstack[r]{HierarchyCompute(d, hi, "y", inputInOutput = TRUE, \\  \phantom{AAA} colVar = letters[1:(floor(i/2))])}}\\
\hline
ModelMatrix from hierarchies & \ttfamily{ModelMatrix(d, hierarchies = hi)}\\
\hline
Formula & \ttfamily{\shortstack[l]{f <- as.formula(strtrim( \\  \phantom{AAA} "y \textasciitilde{} (a+A)*(b+B)*(c+C)*(d+D)*(e+E)*(f+F)", 3 + 6*i))}}\\
\hline
ModelMatrix from formula & \ttfamily{ModelMatrix(d, formula = f)}\\
\hline
sparse.model.matrix & \ttfamily{ModelMatrix(d, formula = f, viaOrdinary = TRUE)}\\
\hline
model.matrix & \ttfamily{\shortstack[r]{ModelMatrix(d, formula = f, viaOrdinary = TRUE, \\  \phantom{AAA} sparse = FALSE)\phantom{AAAAAAAAAAAAAAAAAAAA} }}\\
\hline
FormulaSums & \ttfamily{FormulaSums(d, formula = f)}\\
\hline
median by model\_aggregate & \ttfamily{\shortstack[l]{model\_aggregate(d, hierarchies = hi, \\  \phantom{AAAAAAAAAAAAAAA} fun\_vars = c(median = "y"))}}\\
\hline
\end{tabular}
\vspace{20pt} \end{table}

Table \ref{tab:tab1-pdf}
displays the CPU times for different function calls.
The measurements were made by \texttt{system.time} (first element). The median values from five runs are shown.
Table \ref{tab:tab2-pdf}
displays the memory usage as peak RAM, measured using the \CRANpkg{peakRAM} package (Quinn 2017).
The median values from five runs are shown.
These runs were conducted separately from the CPU time measurements.
Table \ref{tab:tab2-pdf}
also presents object sizes obtained using the \texttt{object.size} function.
The source code is shown in
Table \ref{tab:tab3-pdf}.
These comparisons were made with R version 4.2.2 running on Linux.
The server had about 500 GiB of RAM, and it appeared that less than 10\% of it were occupied by other users.

Since some functions are based on hierarchy input that may need to be generated from data, \texttt{FindHierarchies} are also included in the tables.
Some functions produce aggregate results \linebreak (\texttt{HierarchyCompute}, \texttt{FormulaSums} and \texttt{model\_aggregate}), while others produce a model matrix.
\linebreak However, the time required for calculating sum aggregates through matrix multiplication is almost negligible.
When \(i=6\), \texttt{crossprod(x,\ d\$y)} takes four seconds. Here \texttt{x} refers to the sparse model matrix.

Generation of the model matrix from hierarchies by \texttt{ModelMatrix} is done via \texttt{HierarchyCompute}.
The transposed model matrix is outputted before the ordinary results are produced.
The main reason why \texttt{ModelMatrix} still takes longer, when \(i \geq 4\), is a parameter setting that ensures that the column order is more similar to a usual model matrix (\texttt{reorder\ =\ TRUE}).
Some time is also spent on matrix transposition.
Even if \texttt{ModelMatrix} is run with \texttt{crossTable\ =\ FALSE}, which is the default, this information is still internally generated in order to create column names.

If the desired output is sum aggregates, there is no doubt that \texttt{HierarchyCompute} with \texttt{colVar} is the most efficient option.
In this case, equation \eqref{eq:eq2} is utilized, and instead of creating one large model matrix, two smaller matrices are generated.
For example, when \(i=5\), dimensions \(a\) and \(b\) are used for columns, while \(c\), \(d\), and \(e\) are used for rows.

Even though the functions handle hierarchical relationships, the formula used in the input must be written appropriately in order to achieve the desired output.
To generate all combinations, the input formula to \texttt{ModelMatrix} at \(i=4\) would be \texttt{\textasciitilde{}(a+A)*(b+B)*(c+C)*(d+D)}.
In Table \ref{tab:tab3-pdf},
a response term is included in the formula, but it is only necessary for the \texttt{FormulaSums} function.
The output from \texttt{FormulaSums} is a one-column matrix containing aggregates.
However, the object size is larger compared to the data frame output of \texttt{HierarchyCompute}.
This is because row names are a less efficient method of storing the information.
It is interesting to note that \texttt{FormulaSums} uses more memory at \(i=5\) than \(i=6\).
This is probably because the \texttt{aggregate} function uses a different method for large data.

The initial implementation of \texttt{ModelMatrix} utilized the functions \texttt{sparse.model.matrix} and \linebreak  \texttt{model.matrix}.
This option still remains available by setting \texttt{viaOrdinary\ =\ TRUE}.
Since these functions omit a factor level, the input variables are encoded as factors and an empty factor level is added.
In this way, the desired matrix is achieved, here a \(10^i \times 14^i\) matrix.
With small data sets (\(i \leq 3\)), \texttt{model.matrix} is the fastest method, but with \(i \geq 5\), there was not enough available memory.
With \(i=5\) and \(i=6\), the size of the output object would be approximately 400 GiB and 55 TiB, respectively.
The results show, perhaps surprisingly, that \texttt{sparse.model.matrix} consumes significant time and memory.
It was not feasible to run it at \(i=6\).
Profiling indicates that this is primarily due to interaction calculations.
In contrast, in \texttt{ModelMatrix}, which only handles categorical variables, this process is simplified by combining multiple variables from the input before calling \texttt{fac2sparse}.
The hierarchy interface to \texttt{ModelMatrix}, however, is significantly faster than the formula interface.
This is because a few calls to the \texttt{KhatriRao} function are much faster than building the matrix with \texttt{cbind} based on numerous \texttt{fac2sparse} calls.
The object size of the output matrix is slightly larger when using \texttt{sparse.model.matrix} compared to the regular \texttt{ModelMatrix}.
This is primarily because the output from \texttt{sparse.model.matrix} includes row names as well.

Here, \texttt{model\_aggregate} is used to calculate median values instead of the sums calculated by \texttt{HierarchyCompute}.
Output is similar, but the rows are sorted differently.
Internally, \texttt{ModelMatrix} is called, and the formula interface is also possible.
Instead of matrix multiplication, the \texttt{median} function is now called \(14^i\) times.
This is more resource-intensive, but still feasible when \(i=6\).

\hypertarget{applications-in-other-r-packages}{%
\section{Applications in other R packages}\label{applications-in-other-r-packages}}

The first of the functions demonstrated above to be used in a specific purpose package was \texttt{FindDimLists}.
Package \CRANpkg{easySdcTable} (Langsrud 2022) provides a simplifying interface to the
statistical disclosure control (SDC) package \CRANpkg{sdcTable} (Meindl 2023).
This is about protecting frequency tables by the suppression method.
Automatic hierarchies by \texttt{FindDimLists} is an important part of the simplification.

The function \texttt{HierarchyCompute} was originally made for Statistics Norway's modernized calculations
of \href{https://www.ssb.no/en/kommregnko/}{municipal accounts}, which involve complicated hierarchies.
The original intention was to do the computations by an implementation of VTL (Airo et al. 2015), but this approach proved to be too inefficient and R was chosen instead.
The calculations are implemented in the package \pkg{Kostra} (LillegÃ¥rd et al. 2023) that is made for internal use in Statistics Norway.
The two complicated hierarchies involved are illustrated on Figure \ref{fig:fig2}.
This figure as well as Figure \ref{fig:fig1} is made using package \CRANpkg{igraph} (Csardi and Nepusz 2006).
Plotting could be achieved by converting the hierarchies produced by \texttt{AutoHierarchies} into igraph objects using the \texttt{graph\_from\_data\_frame} function.

\begin{figure}
\includegraphics[width=1\linewidth]{figures/Function_Art_hierarchy} \caption{The function (left) and art (right) hierarchy involved in Statistics Norwayâ€™s municipal accounts calculations. Red arrow means negative sign.}\label{fig:fig2}
\end{figure}

The hierarchy interface part of \texttt{ModelMatrix} was created as a spin-off from \texttt{HierarchyCompute}.
The first application was in the SDC package \CRANpkg{SmallCountRounding} (Langsrud and Heldal 2022),
which protects frequency tables data by the perturbation method described by Langsrud and Heldal (2018).
The earliest versions of this package were limited to formula input and the package then contained the first version of \texttt{ModelMatrix}.
Two other SDC packages also use \texttt{ModelMatrix}.
The packages \pkg{SSBcellKey} (Lupp and Langsrud 2023) and \CRANpkg{GaussSuppression} (Langsrud and Lupp 2023a) can be used to protect both frequency and magnitude tables
by, respectively, perturbation (Thompson, Broadfoot, and Elazar 2013) and suppression (Hundepool et al. 2012).

All the SDC packages mentioned above are about protection of tabular data.
When \texttt{ModelMatrix} is used, the model matrix itself is important to the algorithm.
The model matrix is therefore necessary for more than aggregating the data by a matrix multiplication.
In the package \pkg{SSBcellKey}, however, use of the model matrix is limited to running the \CRANpkg{SSBtools} function \texttt{DummyApply}
which is a precursor to the \texttt{dummy\_aggregate} function mentioned above.

\hypertarget{conclusion}{%
\section{Conclusion}\label{conclusion}}

The \CRANpkg{SSBtools} package provides functionality to handle hierarchical relationships and to generate corresponding model matrices.
This is useful in contexts where multidimensional aggregation and related computations are to be done.
This is applied by several R packages for statistical disclosure control, a field that is important for official statistics.

\hypertarget{acknowledgements}{%
\section*{Acknowledgements}\label{acknowledgements}}
\addcontentsline{toc}{section}{Acknowledgements}

I would like to thank my colleagues Daniel Lupp and Johan Fosen at Statistics Norway, as well as an anonymous reviewer, for their valuable comments that led to improvements.

\hypertarget{references}{%
\section*{References}\label{references}}
\addcontentsline{toc}{section}{References}

\hypertarget{refs}{}
\begin{CSLReferences}{1}{0}
\leavevmode\vadjust pre{\hypertarget{ref-VTL_2015}{}}%
Airo, Sami, Foteini Andrikopoulou, David Barraclough, Luigi Bellomarini, Marc Bouffard, Maurizio Capaccioli, Vincenzo Vecchio, et al. 2015. \emph{Validation \& Transformation Language, Part 2 Library of Operators, Version 1.0}. \url{https://sdmx.org/wp-content/uploads/VTL1_2015_part2_operators_final.pdf}.

\leavevmode\vadjust pre{\hypertarget{ref-Matrix}{}}%
Bates, Douglas, Martin Maechler, and Mikael Jagan. 2023. \emph{{Matrix}: Sparse and Dense Matrix Classes and Methods}. \url{https://CRAN.R-project.org/package=Matrix}.

\leavevmode\vadjust pre{\hypertarget{ref-igraph_2006}{}}%
Csardi, Gabor, and Tamas Nepusz. 2006. {``The Igraph Software Package for Complex Network Research.''} \emph{InterJournal} Complex Systems: 1695. \url{https://igraph.org}.

\leavevmode\vadjust pre{\hypertarget{ref-SDCbook_2012}{}}%
Hundepool, Anco, Josep Domingo-Ferrer, Luisa Franconi, Sarah Giessing, Eric Schulte Nordholt, Keith Spicer, and Peter-Paul de Wolf. 2012. \emph{Statistical Disclosure Control}. John Wiley \& Sons, Ltd. \url{https://doi.org/10.1002/9781118348239.ch1}.

\leavevmode\vadjust pre{\hypertarget{ref-easySdcTable_2022}{}}%
Langsrud, Ã˜yvind. 2022. \emph{{easySdcTable}: Easy Interface to the Statistical Disclosure Control Package 'sdcTable' Extended with Own Implementation of 'GaussSuppression'}. \url{https://CRAN.R-project.org/package=easySdcTable}.

\leavevmode\vadjust pre{\hypertarget{ref-Langsrud_Heldal_2018}{}}%
Langsrud, Ã˜yvind, and Johan Heldal. 2018. {``{An Algorithm for Small Count Rounding of Tabular Data}.''} {Privacy in statistical databases, Valencia, Spain}.

\leavevmode\vadjust pre{\hypertarget{ref-SmallCountRounding_2022}{}}%
---------. 2022. \emph{{SmallCountRounding}: Small Count Rounding of Tabular Data}. \url{https://CRAN.R-project.org/package=SmallCountRounding}.

\leavevmode\vadjust pre{\hypertarget{ref-GaussSuppression}{}}%
Langsrud, Ã˜yvind, and Daniel Lupp. 2023a. \emph{{GaussSuppression}: Tabular Data Suppression Using Gaussian Elimination}. \url{https://CRAN.R-project.org/package=GaussSuppression}.

\leavevmode\vadjust pre{\hypertarget{ref-SSBtools_2023}{}}%
---------. 2023b. \emph{{SSBtools}: Statistics Norway's Miscellaneous Tools}. \url{https://CRAN.R-project.org/package=SSBtools}.

\leavevmode\vadjust pre{\hypertarget{ref-Kostra_2023}{}}%
LillegÃ¥rd, Magnar, Anna-Karin Mevik, Johan Heldal, and Ã˜yvind Langsrud. 2023. \emph{{Kostra}: Functions for Kostra}. \url{https://github.com/statisticsnorway/Kostra}.

\leavevmode\vadjust pre{\hypertarget{ref-SSBcellKey}{}}%
Lupp, Daniel, and Ã˜yvind Langsrud. 2023. \emph{{SSBcellKey}: Cell-Key Method for Tabular Data}. \url{https://github.com/statisticsnorway/SSBcellKey}.

\leavevmode\vadjust pre{\hypertarget{ref-sdcTable}{}}%
Meindl, Bernhard. 2023. \emph{{sdcTable}: Methods for Statistical Disclosure Control in Tabular Data}. \url{https://CRAN.R-project.org/package=sdcTable}.

\leavevmode\vadjust pre{\hypertarget{ref-peakRAM_2017}{}}%
Quinn, Thomas. 2017. \emph{{peakRAM}: Monitor the Total and Peak RAM Used by an Expression or Function}. \url{https://CRAN.R-project.org/package=peakRAM}.

\leavevmode\vadjust pre{\hypertarget{ref-CellKey}{}}%
Thompson, G., S. Broadfoot, and D. Elazar. 2013. {``{Methodology for the automatic confidentialisation of statistical outputs from remote servers at the Australian Bureau of Statistics}.''} {Joint UNECE/Eurostat Work Session on Statistical Data}.

\leavevmode\vadjust pre{\hypertarget{ref-tauARGUS_2014}{}}%
Wolf, Peter-Paul de, Anco Hundepool, Sarah Giessing, Juan-JosÃ© Salazar, and Jordi Castro. 2014. {``{tau-ARGUS user's manual, version 4.1}.''} Statistics Netherlands. \url{https://github.com/sdcTools/tauargus}.

\end{CSLReferences}


\address{%
Ã˜yvind Langsrud\\
Statistics Norway\\%
P.O. Box 8131 Dep.,\\ 0033 Oslo, Norway\\
%
\url{https://github.com/olangsrud}\\%
\textit{ORCiD: \href{https://orcid.org/0000-0002-1380-4396}{0000-0002-1380-4396}}\\%
\href{mailto:Oyvind.Langsrud@ssb.no}{\nolinkurl{Oyvind.Langsrud@ssb.no}}%
}
