# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit stpointprocess.Rmd to modify this file

params <-
list(run_all_code = FALSE)

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, 
                      fig.align = "center", eval = params$run_all_code)
library(spatstat)
library(viridis)
library(plotly)
library(ggplot2)
library(palmerpenguins)
library(sparr)
library(foreach)
library(doParallel)
library(GET)
library(kernstadapt)
library(KernSmooth)
library(plot3D)
library(stpp)
load("Results.RData")


## ---- echo = TRUE, eval = TRUE------------------------------------------------
library(spatstat)
library(viridis)
load("AegissData.RData")


## ---- echo = TRUE, eval = TRUE------------------------------------------------
head(as.data.frame(Aegiss))


## ---- echo = TRUE, eval = TRUE------------------------------------------------
Times <- Aegiss$marks
timelabels <- as.Date(Times - 1, origin = "2001-01-01")
colmap <- viridis(length(Times))
sy <- symbolmap(pch = 21, col = "black", bg = colmap, range = range(timelabels))


## ----stpointpattern, echo = TRUE, eval = TRUE, result.width='100%', fig.width=9.5, fig.height=3, fig.cap ="Left: Locations of 10443 reports of non-specific gastrointestinal disease in Hampshire from January 2001 to July 2003. The time is treated as a quantitative mark where darker dots correspond to the older events, and lighter dots match the most recent reports. Right: Hampshire population density averaged over the years 2001-2003. The colour map is evenly-spaced on a logarithmic scale.", out.width='\\textwidth'----
par(mfrow = c(1, 2), mar = c(0,0,2,0.5)) 
X <- unmark(Aegiss)
PopDens <- im.apply(Population, mean)
plot(X %mark% timelabels, symap = sy, 
     main = "Gastrointestinal disease reports")
plot(PopDens, col = viridis(prod(PopDens$dim)), log = T, box = F,
     main = "Population intensity")


## ---- echo = TRUE, eval = TRUE------------------------------------------------
# This takes roughly 12 seconds to be executed in an
# iMAC 2019, 3GHz intel core i5 processor with 16GB of RAM (hereinafter)
SpatialDens <- adaptive.density(X, method = "kernel", edge = T)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
N <- integral.im(PopDens) 
n <- X$n
ControlDens <- eval.im((PopDens / N) * n)
Controls <- rpoispp(ControlDens)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
Window(Controls) <- X$window


## ---- echo = TRUE, eval = TRUE------------------------------------------------
# This takes roughly 22 seconds to be executed 
library(sparr)
RelativeRisk <- risk(f = X, g = Controls, adapt = T, 
                     pilot.symmetry = "pooled", tolerate = T)


## ----adaptativeintensities, echo = T, eval = TRUE, result.width='100%', fig.width=9.5, fig.height=3, fig.cap ="Left: Adaptive bandwidth kernel estimate of intensity for the gastrointestinal data. The intensity is expressed as number of reports per squared kilometre. Right: Adaptive spatial log-relative risk of non-specific gastrointestinal disease, with asymptotic tolerance contours for elevated risk.", out.width='\\textwidth'----
par(mfrow = c(1, 2), mar = c(0,0,2,0.5)) 
plot(SpatialDens, col = viridis(1200), auto.axes = F,
     main = "Adaptative kernel intensity estimate", box = F)
plot(RelativeRisk, auto.axes = F, tol.type = "upper", 
     main = "Relative risk estimate")


## ---- echo = TRUE, eval = TRUE------------------------------------------------
sigmaD <- bw.scott(X)
MD <- density.ppp(X, diggle = T, positive = T, sigma = sigmaD)
MP <- density.ppp(X, diggle = T, sigma = sigmaD, at = "points")


## ---- echo = TRUE, warning=FALSE----------------------------------------------
# Time consuming: This takes roughly 24 minutes to be executed 
bwG <- bw.pcf(X, cv.method = "compLik", divisor = "d", lambda = MP)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
r0 <- 0.7 * rmax.rule("K", X$window, intensity(X))
rr <- seq(0, r0, length.out = 71)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
# Time consuming: This takes roughly 3 minutes to be executed 
L1 <- envelope(X, nsim = 39, savefuns = TRUE, fun = "Linhom", diggle = T,
               transform = expression(.-r), sigma = sigmaD, r = rr, 
               simulate = expression(rpoispp(lambda = MD)), verbose = F)


## ---- echo = TRUE-------------------------------------------------------------
Simpatterns <- rpoispp(lambda = MD, nsim = 39)


## ---- echo = TRUE-------------------------------------------------------------
simL <- function(rep) {
  sim_fit <- density.ppp(Simpatterns[[rep]], diggle = T, 
                         sigma = sigmaD, positive = T)
  envelope(Simpatterns[[rep]], nsim = 39, savefuns = T, fun = "Linhom", 
           transform = expression(.-r), r = rr, diggle = T, sigma = sigmaD,
           simulate = expression(rpoispp(lambda = sim_fit)))
}


## ---- echo = TRUE-------------------------------------------------------------
# Time consuming: This takes roughly 21 minutes to be executed 
library(foreach)
library(doParallel)
c0 <- parallel::makeCluster(detectCores() - 1)
doParallel::registerDoParallel(c0)
L.ls <- foreach(i = 1:39, .packages = c("spatstat")) %dopar% {simL(i)}
parallel::stopCluster(c0)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
library(GET)
library(ggplot2)
resL <- GET.composite(X = L1, X.ls = L.ls, type = "erl", 
                      alternative = "greater", savefuns = T)


## ----kandgspatial, echo = F, eval = TRUE, fig.cap ="Graphical clustering tests of Hampshire data based on the $L$-functions. The gray bands represent the $95\\%$ global envelope. Red dots stand for the second-order descriptors outside the envelopes.", out.width='75%'----
plot(resL) +
  theme_bw() +
  theme(axis.title.x = element_blank(), legend.position = "none")


## ---- echo = TRUE, eval = TRUE------------------------------------------------
# This takes roughly 20 seconds to be executed 
SepTest <- separability.test(Aegiss, nx = 5, ny = 4, nt = 16, nperm = 50000)

## ---- echo = TRUE, eval = TRUE------------------------------------------------
SepTest


## ---- echo = TRUE, eval = TRUE------------------------------------------------
Times <- Aegiss$marks
bwt <- bw.nrd0(Times)
edgewt.t <- pnorm((max(Times) - Times) / bwt) - pnorm((min(Times)- Times) / bwt) 


## ---- echo = TRUE, eval = TRUE------------------------------------------------
# This takes roughly 44 seconds to be executed 
nonseparable <- function(time){
	contrib <- (Times >= time - 3 * bwt) & (Times <= time + 3 * bwt)
	Wh <- dnorm(x = Times[contrib], mean = time, sd = bwt) / edgewt.t[contrib]
	density.ppp(X[contrib], weights = Wh, diggle = TRUE)
}
nonsep <- lapply(unique(Times), nonseparable)


## ----snapshotsintensity, echo = TRUE, eval = TRUE,  fig.width=9.5, fig.height=3, fig.cap ="Temporal snapshots of the intensity $\\hat{\\lambda}(\\mathbf{u},v)$, of non-specific gastrointestinal reports in Hampshire, estimated in a non-separable way through Gaussian kernels. The units are rescaled by $100$.", out.width='100%'----
n.slices <- which(unique(timelabels) %in% as.Date(c("2001-01-01", "2002-01-01", 
                                                    "2003-01-01", "2003-12-31")))
Snap <- list(nonsep[[n.slices[1]]], nonsep[[n.slices[2]]], 
             nonsep[[n.slices[3]]], nonsep[[n.slices[4]]])
plot.imlist(Snap, equal.ribbon = T, ncols = 4, box = F, main = "", log = F,
            main.panel = unique(timelabels)[n.slices], col = viridis(1200),
            ribscale = 100,  mar.panel=c(0, 0, 1, 1), panel.end = X$window)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
lambda <- NULL
for (i in 1:length(nonsep)) {
	lambda <- c(lambda, safelookup(nonsep[[i]], 
	Aegiss[marks(Aegiss) == unique(Times)[i]]))
}
PP <- X %mark% data.frame(time = Aegiss$marks, Lambda = lambda)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
Ni <- lapply(Population, integral.im)
ni <- lapply(split(Aegiss, cut(Aegiss$marks, breaks = c(0, 365, 730, 1095))), 
             npoints)
ControlDensi <- mapply(function(D, N, n) {eval.im((D / N) * n)}, 
                       D = Population, N = Ni, n = ni, SIMPLIFY = F)
Controlsi <- mapply(function(L, Breaks){
  PP <- rpoispp(lambda = L)
  marks(PP) <- sample(x = (Breaks[1] + 1):Breaks[2], 
                      size = npoints(PP), replace = T)
  return(PP)}, 
  L = ControlDensi, Breaks = list(c(0, 365), c(365, 730), c(730, 1095)), 
  SIMPLIFY = F)

Controlsi <- superimpose(as.solist(Controlsi))
Controlsi <- unmark(Controlsi) %mark% Controlsi$marks$origMarks
Window(Controlsi) <- Window(Aegiss)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
# This takes roughly 4.87 minutes to be executed
Br <- OS.spattemp(Aegiss)
f.num <- spattemp.density(Aegiss, h = Br[1], lambda = Br[2])
d.den <- spattemp.density(Controlsi, h = Br[1], lambda = Br[2])


## ---- echo = TRUE, eval = TRUE------------------------------------------------
# This takes roughly 5.47 minutes to be executed
st.risk <- spattemp.risk(f = f.num, g = d.den, tolerate = T)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
risk.slices <- spattemp.slice(st.risk, tt = n.slices)


## ----strisk, echo = TRUE, eval = TRUE,  fig.width=9.5, fig.height=6, fig.cap ="Temporal snapshots of the unconditional risk $\\hat{r}(\\mathbf{u},v)$ (top) and conditional risk $\\hat{r}(\\mathbf{u}|v= t)$ (where $t$ is $01/01/2001$, $01/01/2002$, $01/01/2003$ and $12/31/2003$) (bottom) of non-specific gastrointestinal disease in Hampshire. Solid lines delineate a statistical significant elevated risk at the $5\\%$ level.", out.width='100%'----
plot.imlist(c(risk.slices$rr, risk.slices$rr.cond), equal.ribbon = T, ncols = 4, 
            box = F, main = "", main.panel = c(timelabels[n.slices], rep("", 4)), 
            mar.panel = c(0, 0, 1, 1), col = rocket(1200), ribmar = c(1, 3, 1, 2), 
            ribwid = 0.4, panel.end = function(i,...){
              contour(c(risk.slices$P, risk.slices$P.cond)[[i]], 
                      levels = 0.05, drawlabels = TRUE, ...)
              plot(X$window, add = T)})


## ---- echo = TRUE, eval = TRUE------------------------------------------------
library(KernSmooth)
dt <- dist(unique(Times))
ht <- dpik(dt, kernel = "epanech", gridsize = 50, scalest = "iqr")
ht <- 2 * ht


## ---- echo = TRUE, eval = TRUE------------------------------------------------
t0 <- 0.15 * max(dt)


## ---- echo = TRUE, eval = TRUE------------------------------------------------
library(stpp)
FMD <- as.3dpoints(PP$x, PP$y, PP$marks$time)
s.region <- as.matrix(data.frame(x = PP$window$bdry[[1]]$x, 
                                 y = PP$window$bdry[[1]]$y))
hs <- bwG
u1 <- seq(hs, r0, length.out = 71)[-1]
v1 <- seq(ht, t0, length.out = 71)[-1]


## ---- echo = TRUE-------------------------------------------------------------
# Time consuming: This takes roughly 3.87 hours to be executed
g <- PCFhat(xyt = FMD, s.region = s.region, t.region = range(Times), 
            lambda = lambda, dist = u1, times = v1, ks = "epanech", 
            kt = "epanech", hs = hs, ht = ht)


## ----gfunction, echo = TRUE, eval = TRUE,  fig.width=6, fig.height=6, fig.cap ="Spatio-temporal pair correlation function estimate of non-specific gastrointestinal disease data.", out.width='65%'----
library(plot3D)
par(mar = c(0,0,0,0))
persp3D(x = u1, y = v1, z = g$pcf, facets = NA, curtain = F, col =  viridis(200), 
	colkey = F, bty = "g", pch = 20, cex = 1.5, theta = 40, phi = 5, 
	border = NA, ticktype = "detailed", cex.axis = 0.5,  zlab = "",
	xlab = "spatial distances", ylab = "temporal distances")


## ---- echo = TRUE, eval = TRUE------------------------------------------------
u <- seq(0, r0, length.out = 71)
v <- seq(0, t0, length.out = 71)


## ---- echo = TRUE-------------------------------------------------------------
# Time consuming: This takes roughly 55 minutes to be executed
stik <- STIKhat(xyt = FMD, s.region = s.region, t.region = range(Times),
                lambda = lambda, dist = u, times = v, infectious = F)


## ----Kfunctions, echo = TRUE, eval = TRUE,  fig.width=6, fig.height=6, fig.cap ="Spatio-temporal pair correlation function estimate of non-specific gastrointestinal disease data.", out.width='65%'----
KS <- stik$Khat - stik$Ktheo
par(mar = c(0,0,0,0))
persp3D(x = u[-1], y = v[-1], z = KS, facets = NA, zlab = "",
	curtain = F, col =  viridis(100), colkey = F, bty = "g", pch = 20, 
	cex = 1.5, theta = 40, phi = 5, border = NA, ticktype = "detailed", 
	cex.axis = 0.5, xlab = "spatial distances", ylab = "temporal distances")

