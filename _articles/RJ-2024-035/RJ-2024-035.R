# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2024-035.Rmd to modify this file

## ----include=FALSE------------------------------------------------------------
options(tinytex.verbose = TRUE)


## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(DisaggregateTS)
library(xts)
library(ggplot2)
library(readxl)
library(tidyr)
library(dplyr)
library(kableExtra)


## ----sub1,  fig.width = 5.5, fig.height = 4, fig.align = "center", fig.cap = "Quarterly and monthly simulated stock data"----
# ------------------------------------------------------------------------------
# First data generation (stock data)
# ------------------------------------------------------------------------------
set.seed(123)
data1 = TempDisaggDGP(
  n_l      = 4,
  n        = 12,
  aggRatio = 3,
  p        = 10,
  rho      = 0.5,
  aggMat   = "first",
  simul    = TRUE
)

# Set up a 1x2 plotting area
par(mfrow = c(1, 2))

X  <- seq(1, 4)
x  <- seq(1, 12)
x2 <- c(1, 4, 7, 10)

# Corrected sprintf usage
my_labelsX <- sprintf("%.0f", X)  
my_labelsx <- sprintf("%.0f", x)  

# --- Plot 1: Aggregated (quarterly) data ---
plot(
  x    = X,
  y    = data1$Y_Gen,
  type = "b",
  xlab = "Quarter",
  ylim = c(-7, 8),
  ylab = "Simulated stock data",
  xaxt = "n"             # Hide default X axis tick labels
)
axis(
  side   = 1,
  at     = X,
  labels = my_labelsX
)
# Overlay the same points in red (gives black lines + red points)
points(x = X, y = data1$Y_Gen, col = "red")

# --- Plot 2: Disaggregated (monthly) data ---
plot(
  x    = x,
  y    = data1$y_Gen,
  type = "b",
  xlab = "Month",
  ylim = c(-7, 8),
  ylab = "",
  xaxt = "n"
)
axis(
  side   = 1,
  at     = x,
  labels = my_labelsx
)
# Overlay aggregated data (quarterly) points in red
points(x = x2, y = data1$Y_Gen, col = "red")


## ----sub2, fig.width = 5.5, fig.height = 4, fig.align = "center", fig.cap = "Quarterly and monthly simulated flow data"----
# ------------------------------------------------------------------------------
# Second data generation (flow data)
# ------------------------------------------------------------------------------
set.seed(312)
data2 = TempDisaggDGP(
  n_l      = 4,
  n        = 12,
  aggRatio = 3,
  p        = 10,
  rho      = 0.5,
  simul    = TRUE
)

# Set up another 1x2 plotting area
par(mfrow = c(1, 2))

X  <- seq(1, 4)
x  <- seq(1, 12)
x2 <- c(3, 6, 9, 12)

# Corrected sprintf usage
my_labelsX <- sprintf("%.0f", X)
my_labelsx <- sprintf("%.0f", x)

# --- Plot 1: Aggregated (quarterly) data ---
plot(
  x    = X,
  y    = data2$Y_Gen,
  type = "b",
  xlab = "Quarter",
  ylim = c(-8, 8),
  ylab = "Simulated flow data",
  xaxt = "n"
)
axis(
  side   = 1,
  at     = X,
  labels = my_labelsX
)

# --- Plot 2: Disaggregated (monthly) data ---
plot(
  x    = x,
  y    = data2$y_Gen,
  type = "b",
  xlab = "Month",
  ylim = c(-8, 8),
  ylab = "",
  xaxt = "n"
)
axis(
  side   = 1,
  at     = x,
  labels = my_labelsx
)


## ----echo = TRUE, eval = FALSE------------------------------------------------
# disaggregate(Y, X, aggMat, aggRatio, method, ...)


## ----echo=TRUE, eval = FALSE--------------------------------------------------
# TempDisaggDGP(n_l, n, aggRatio, p, beta, sparsity, method, aggMat, rho, ...)


## ----echo = TRUE, eval = TRUE-------------------------------------------------
# Generate low-frequency quarterly series and its high-frequency monthly counterpart
SynthethicData <- TempDisaggDGP(n_l = 2,
                                n = 6, 
                                aggRatio = 3, 
                                p = 6, 
                                beta = 0.5, 
                                sparsity = 0.5, 
                                method  = 'Chow-Lin', 
                                rho = 0.5)


## ----echo = TRUE, eval = TRUE-------------------------------------------------
# Set seed for reproducibility
set.seed(27)
# Generate low-frequency yearly series and its high-frequency quarterly counterpart
n_l <- 17 # The number of low-frequency data points - annual
n <- 68 # The number of high-frequency (quarterly) data points.
p_sim <- 5 # The number of the high-frequency exogenous variables.
rho_sim <- 0.8 # autocorrelation parameter
Sim_data <- TempDisaggDGP(n_l, 
                          n, 
                          aggRatio = 4,
                          p = p_sim,
                          rho = rho_sim)
Y_sim <- matrix(Sim_data$Y_Gen) # Extract the simulated dependent low-frequency variable
X_sim <- matrix(Sim_data$X_Gen) # Extract the simulated dependent 
# (low-frequency) variable
Y_sim_HF_obs <- matrix(Sim_data$y_Gen) #  HF simulated observations


## ----echo= TRUE, eval = TRUE--------------------------------------------------
C_sparse_SIM <- disaggregate(Y_sim, 
                             X_sim,
                             aggMat = "sum",
                             aggRatio = 4,
                             method = "Chow-Lin")
C_sparse_SIM$beta_Est
Y_HF_SIM <- C_sparse_SIM$y_Est[ ,1] # Extract the temporal disaggregated 
# dependent variable estimated through the function disaggregate()


## ----fig-res-sim-cs, fig.width = 5.5, fig.height = 4, fig.cap="Temporal disaggregated and interpolated observations for the estimation under the classical setting. The plot is built using the snippet code provided in this subsection. As we used the setting `aggMat = sum`, the sum of every four disaggregated observations corresponds to an actual low-frequency observation."----
# -------------------------------
# 1. Load Necessary Libraries
# -------------------------------

# -------------------------------
# 2. Data Preparation
# -------------------------------

set.seed(27)

# Define parameters
n_l <- 17    # Number of low-frequency data points
n <- 68      # Number of high-frequency (quarterly) data points
p_sim <- 5   # Number of high-frequency exogenous variables
rho_sim <- 0.8 # Autocorrelation parameter

# Generate simulated data using TempDisaggDGP
Sim_data <- TempDisaggDGP(n_l, n, aggRatio = 4, p = p_sim, rho = rho_sim)

# Extract simulated observations
Y_sim <- matrix(Sim_data$Y_Gen)         # Low-frequency simulated observations
Y_sim_HF_obs <- matrix(Sim_data$y_Gen)  # High-frequency simulated observations
X_sim <- Sim_data$X_Gen                  # Exogenous high-frequency variables

# Perform temporal disaggregation using Chow-Lin method
C_sparse_SIM <- disaggregate(Y_sim, X_sim, aggMat = "sum", aggRatio = 4, method = "Chow-Lin")
Y_HF_SIM <- C_sparse_SIM$y_Est[,1]      # Temporal disaggregated observations

# -------------------------------
# 3. Extract Dates from CSV Files
# -------------------------------

Data_X <- read.csv("./data/Exogenous_variables_IBM.csv", stringsAsFactors = FALSE)
Data_Y <- read.csv("./data/Total_emissions.csv", stringsAsFactors = FALSE)


# Extract relevant date ranges
Dates <- Data_Y$Dates[7:23]                # Low-frequency dates
Dates <- as.Date(Dates, format = "%m/%d/%Y")
Dates_Q <- Data_X$Dates[24:91]             # High-frequency dates
Dates_Q <- as.Date(Dates_Q, format = "%m/%d/%Y")


# -------------------------------
# 4. Proportional (Linear) Interpolation
# -------------------------------

# Create xts objects for interpolation
Y_temp <- xts(Y_sim / 4, order.by = Dates) # Divide by 4 as per aggregation ratio

# Merge low-frequency and high-frequency dates
Y_temp2 <- merge(Y_temp, xts(rep(NA, length(Dates_Q)), order.by = Dates_Q))

# Perform linear interpolation to fill NA values
Y_HF_approx <- as.numeric(na.approx(Y_temp2[,1], rule = 2)) # Ensure it's a numeric vector

# -------------------------------
# 5. Prepare Data for ggplot2
# -------------------------------

# Create a data frame combining all series
plot_data <- data.frame(
  Date = Dates_Q,
  Temporal_Disaggregated = Y_HF_SIM,
  High_Frequency = Y_sim_HF_obs,
  Interpolated = Y_HF_approx
)

# Convert to long format suitable for ggplot2
plot_long <- pivot_longer(
  plot_data,
  cols = c("Temporal_Disaggregated", "High_Frequency", "Interpolated"),
  names_to = "Series",
  values_to = "Value"
)

# -------------------------------
# 6. Rename Series Labels to Remove Underscores
# -------------------------------

# Use dplyr's mutate and recode to rename Series labels
plot_long <- plot_long %>%
  mutate(Series = recode(Series,
                         "Temporal_Disaggregated" = "Temporal Disaggregated",
                         "High_Frequency" = "High-Frequency",
                         "Interpolated" = "Interpolated"))

# -------------------------------
# 7. Create the ggplot2 Plot
# -------------------------------

ggplot(plot_long, aes(x = Date, y = Value, color = Series, linetype = Series)) +
  geom_line(size = 0.5) +       # Adjust line thickness for better visibility
  geom_point(data = subset(plot_long, Series == "Temporal Disaggregated"), size = 1.5) +      # Adjust point size
  labs(
    title = "Classical Setting",
    x = "Time",
    y = ""  # Empty y-axis label as per original code
    ) +
  theme_minimal(base_size = 14) +  # Apply a clean minimal theme with larger base font size
theme(
  panel.grid.major = element_blank(),    # Remove major gridlines
  panel.grid.minor = element_blank(),    # Remove minor gridlines
  legend.position = "top",               # Position legend at the top
  legend.title = element_blank(),        # Remove legend title
  legend.text = element_text(size = 12), # Increase legend text size for readability
  plot.title = element_text(
    hjust = 0.5, size = 16, face = "bold" # Center and style the plot title
  ),
  axis.text = element_text(size = 12),   # Increase axis text size
  axis.title = element_text(size = 14)   # Increase axis title size
) +
  scale_color_manual(
    values = c(
      "High-Frequency" = "red",
      "Interpolated" = "blue",
      "Temporal Disaggregated" = "black"
    )
  ) +
  scale_linetype_manual(
    values = c(
      "High-Frequency" = "solid",
      "Interpolated" = "dashed",
      "Temporal Disaggregated" = "solid"
    )
  ) +
  guides(
    color = guide_legend(nrow = 1, byrow = TRUE),    # Arrange legend items in one row
    linetype = guide_legend(nrow = 1, byrow = TRUE) # Ensure linetype legend aligns with color
  )


## ----echo = TRUE, eval = TRUE-------------------------------------------------
# Generate low-frequency yearly series and its high-frequency quarterly counterpart
set.seed(27)
n_l <- 17 # The number of low-frequency data points 
n <- 68 # The number of high-frequency data points - quarterly
p_sim <- 100 # The number of the high-frequency exogenous variables.
rho_sim <- 0.8 # autocorrelation parameter
Sim_data <- TempDisaggDGP(n_l,
                          n,
                          aggRatio = 4,
                          p = p_sim,
                          rho = rho_sim)
Y_sim <- matrix(Sim_data$Y_Gen) #Extract the simulated dependent 
# (low-frequency) variable
X_sim <- Sim_data$X_Gen #Extract the simulated exogenous variables - high-frequency


## ----fig-res-sim-hds, fig.width = 5.5, fig.height = 4, fig.cap="Temporal disaggregated and interpolated observations for the estimation under the high-dimensional setting. The plot is built using the snippet code provided in this subsection. As we used the setting `aggMat = sum`, the sum of every four disaggregated observations corresponds to an actual low-frequency observation."----
# -------------------------------
# 1. Load Necessary Libraries
# -------------------------------

# -------------------------------
# 2. Data Preparation
# -------------------------------

set.seed(27)

# Define parameters
n_l <- 17    # Number of low-frequency data points (annual)
n <- 68      # Number of high-frequency data points (quarterly)
p_sim <- 100 # Number of high-frequency exogenous variables
rho_sim <- 0.8 # Autocorrelation parameter

# Generate simulated data using TempDisaggDGP
Sim_data <- TempDisaggDGP(n_l, n, aggRatio = 4, p = p_sim, rho = rho_sim)

# Extract simulated observations
Y_sim <- matrix(Sim_data$Y_Gen)            # Low-frequency simulated observations
Y_sim_HF_obs <- matrix(Sim_data$y_Gen)     # High-frequency simulated observations
X_sim <- Sim_data$X_Gen                     # Exogenous high-frequency variables

# Perform temporal disaggregation using adaptive-spTD method
C_sparse_SIM <- disaggregate(Y_sim, X_sim, aggMat = "sum", aggRatio = 4, method = "adaptive-spTD")
Y_HF_SIM <- C_sparse_SIM$y_Est[,1]         # Temporal disaggregated observations

# -------------------------------
# 3. Extract Dates from CSV Files
# -------------------------------

# Read CSV files
# Adjust the file path as necessary. Here, it assumes the CSV files are in the same directory as the R Markdown file.
Data_X <- read.csv("./data/Exogenous_variables_IBM.csv", stringsAsFactors = FALSE)
Data_Y <- read.csv("./data/Total_emissions.csv", stringsAsFactors = FALSE)

# Extract relevant date ranges
Dates <- Data_Y$Dates[7:23]                # Low-frequency dates
Dates <- as.Date(Dates, format = "%m/%d/%Y")
Dates_Q <- Data_X$Dates[24:91]             # High-frequency dates
Dates_Q <- as.Date(Dates_Q, format = "%m/%d/%Y")
# -------------------------------
# 4. Proportional (Linear) Interpolation
# -------------------------------

# Create xts objects for interpolation
Y_temp <- xts(Y_sim / 4, order.by = Dates) # Divide by 4 as per aggregation ratio

# Merge low-frequency and high-frequency dates
Y_temp2 <- merge(Y_temp, xts(rep(NA, length(Dates_Q)), order.by = Dates_Q))

# Perform linear interpolation to fill NA values
Y_HF_approx <- as.numeric(na.approx(Y_temp2[,1], rule = 2)) # Ensure it's a numeric vector

# -------------------------------
# 5. Prepare Data for ggplot2
# -------------------------------

# Create a data frame combining all series
plot_data <- data.frame(
  Date = Dates_Q,
  Temporal_Disaggregated = Y_HF_SIM,
  High_Frequency = Y_sim_HF_obs,
  Interpolated = Y_HF_approx
)

# Convert to long format suitable for ggplot2
plot_long <- pivot_longer(
  plot_data,
  cols = c("Temporal_Disaggregated", "High_Frequency", "Interpolated"),
  names_to = "Series",
  values_to = "Value"
)

# -------------------------------
# 6. Rename Series Labels to Remove Underscores
# -------------------------------

# Use dplyr's mutate and recode to rename Series labels
plot_long <- plot_long %>%
  mutate(Series = recode(Series,
                         "Temporal_Disaggregated" = "Temporal Disaggregated",
                         "High_Frequency" = "High-Frequency",
                         "Interpolated" = "Interpolated"))

# -------------------------------
# 7. Create the ggplot2 Plot
# -------------------------------

ggplot(plot_long, aes(x = Date, y = Value, color = Series, linetype = Series)) +
  geom_line(size = 0.5) +       # Adjust line thickness for better visibility
  geom_point(data = subset(plot_long, Series == "Temporal Disaggregated"), size = 1.5) +      # Adjust point size
  labs(
    title = "High-Dimensional Setting",
    x = "Time",
    y = ""  # Empty y-axis label as per original code
  ) +
  theme_minimal(base_size = 14) +  # Apply a clean minimal theme with larger base font size
theme(
  panel.grid.major = element_blank(),    # Remove major gridlines
  panel.grid.minor = element_blank(),    # Remove minor gridlines
  legend.position = "top",               # Position legend at the top
  legend.title = element_blank(),        # Remove legend title
  legend.text = element_text(size = 12), # Increase legend text size for readability
  plot.title = element_text(
    hjust = 0.5, size = 16, face = "bold" # Center and style the plot title
  ),
  axis.text = element_text(size = 12),   # Increase axis text size
  axis.title = element_text(size = 14)   # Increase axis title size
) +
  scale_color_manual(
    values = c(
      "High-Frequency" = "red",
      "Interpolated" = "blue",
      "Temporal Disaggregated" = "black"
    )
  ) +
  scale_linetype_manual(
    values = c(
      "High-Frequency" = "solid",
      "Interpolated" = "dashed",
      "Temporal Disaggregated" = "solid"
    )
  ) +
  guides(
    color = guide_legend(nrow = 1, byrow = TRUE),    # Arrange legend items in one row
    linetype = guide_legend(nrow = 1, byrow = TRUE) # Ensure linetype legend aligns with color
  )


## ----eval = TRUE, echo = FALSE------------------------------------------------
# Create the data frame
table_data <- data.frame(
  Statistic = c("Standard Deviation", "Kurtosis", "MSE", "MAE"),
  Classical_Obs = c("2.716 (0.258)", "2.897 (0.519)", "- (-)", "- (-)"),
  Classical_Temporal_Disaggregation = c("2.888 (0.597)", "2.902 (0.527)", "2.405 (1.733)", "1.185 (0.386)"),
  Classical_Interpolation = c("1.488 (0.321)", "2.689 (0.694)", "5.158 (0.977)", "1.809 (0.178)"),
  HighDim_Obs = c("10.089 (0.888)", "2.898 (0.558)", "- (-)", "- (-)"),
  HighDim_Temporal_Disaggregation = c("8.478 (1.696)", "2.890 (0.523)", "104.463 (28.519)", "8.136 (1.101)"),
  HighDim_Interpolation = c("4.18 (0.817)", "2.892 (0.772)", "86.095 (16.258)", "7.403 (0.735)")
)


## ----comparisons-html, fig.width = 4, fig.height = 4, eval = knitr::is_html_output()----
# # Customize the table for PDF output
# if (knitr::is_latex_output()) {
#   kable(
#     table_data,
#     format = "latex",
#     caption = "Mean and standard deviation (in parentheses) of key statistical measures for the high-frequency simulated observations, temporal disaggregated observations, and interpolated observations across 1000 Monte Carlo simulations. MAE and MSE are computed with respect to the high-frequency simulated observations.",
#     booktabs = TRUE,
#     align = c("l", rep("c", 6))
#   ) %>%
#     kable_styling(latex_options = c("hold_position", "scale_down"))
# } else {
#   # Customize the table for HTML output
#   kable(
#     table_data,
#     format = "html",
#     caption = "Mean and standard deviation (in parentheses) of key statistical measures for the high-frequency simulated observations, temporal disaggregated observations, and interpolated observations across 1000 Monte Carlo simulations. MAE and MSE are computed with respect to the high-frequency simulated observations.",
#     align = c("l", rep("c", 6))
#   ) %>%
#     kable_styling(full_width = FALSE)
# }


## ----comparisons-latex, fig.width = 5.5, fig.height = 4, eval = knitr::is_latex_output()----
# Customize the table for PDF output
if (knitr::is_latex_output()) {
  kable(
    table_data,
    format = "latex",
    caption = "Mean and standard deviation (in parentheses) of key statistical measures for the high-frequency simulated observations, temporal disaggregated observations, and interpolated observations across 1000 Monte Carlo simulations. MAE and MSE are computed with respect to the high-frequency simulated observations.",
    booktabs = TRUE,
    align = c("l", rep("c", 6))
  ) %>%
    kable_styling(latex_options = c("hold_position", "scale_down"))
} else {
  # Customize the table for HTML output
  kable(
    table_data,
    format = "html",
    caption = "Mean and standard deviation (in parentheses) of key statistical measures for the high-frequency simulated observations, temporal disaggregated observations, and interpolated observations across 1000 Monte Carlo simulations. MAE and MSE are computed with respect to the high-frequency simulated observations.",
    align = c("l", rep("c", 6))
  ) %>%
    kable_styling(full_width = FALSE)
}


## ----fig-res, fig.width = 5.5, fig.height = 4, fig.cap="Temporal disaggregated and interpolated GHG emissions observations. In this example, we used the setting `aggMat = sum`, so the sum of the quarterly disaggregated GHG sums to the actual annual observation."----
# -------------------------------
# 1. Load Necessary Libraries
# -------------------------------

# -------------------------------
# 2. Data Preparation
# -------------------------------

# Read xlsx files (Assuming the R Markdown file is in the parent directory of 'data')
Data_Y <- read.csv("./data/Total_emissions.csv", stringsAsFactors = FALSE)
Data_X <- read.csv("./data/Exogenous_variables_IBM.csv", stringsAsFactors = FALSE)

# -------------------------------
# 3. Subset Data
# -------------------------------

### Low-Frequency (LF) Data: 09-2005 (observation 7) to 09-2021 (observation 23)
Dates_LF <- Data_Y$Dates[7:23]
Dates_LF <- as.Date(Dates_LF, format = "%m/%d/%Y")
Y_LF <- as.matrix(as.numeric(Data_Y$IBM[7:23]))

### High-Frequency (HF) Data: 12-2004 (observation 21) to 09-2021 (observation 88)
Dates_HF <- Data_X$Dates[21:88]
Dates_HF <- as.Date(Dates_HF, format = "%m/%d/%Y")
X_HF <- Data_X[21:88, ]

# Convert all X_HF columns to numeric
X_HF <- sapply(X_HF, as.numeric)

# Remove columns containing NAs
X_HF <- X_HF[, colSums(is.na(X_HF)) == 0]

# -------------------------------
# 4. Filter Variables with High Correlations (>0.99)
# -------------------------------

# Compute correlation matrix
cor_matrix <- cor(X_HF)

# Zero out the upper triangle and diagonal
cor_matrix[upper.tri(cor_matrix)] <- 0
diag(cor_matrix) <- 0

# Identify columns with any correlation >= 0.99
high_corr_cols <- apply(cor_matrix, 2, function(x) any(abs(x) >= 0.99, na.rm = TRUE))

# Keep only columns without high correlations
X_filtered <- X_HF[, !high_corr_cols]

# -------------------------------
# 5. Perform Temporal Disaggregation
# -------------------------------

# Set seed for reproducibility
set.seed(27)

# Define parameters
n_l <- 17     # Number of low-frequency data points (annual)
n <- 68       # Number of high-frequency data points (quarterly)
p_sim <- ncol(X_filtered)  # Number of high-frequency exogenous variables after filtering
rho_sim <- 0.8 # Autocorrelation parameter

# Generate simulated data using TempDisaggDGP (if needed)
# Note: If you're using real data, you might skip this simulation step
# Sim_data <- TempDisaggDGP(n_l, n, aggRatio = 4, p = p_sim, rho = rho_sim)
# Y_LF <- as.matrix(as.numeric(Sim_data$Y_Gen))
# X_filtered <- Sim_data$X_Gen
# Y_HF_obs <- as.matrix(as.numeric(Sim_data$y_Gen))

# Perform temporal disaggregation using adaptive-spTD method
C_sparse <- disaggregate(Y_LF, X_filtered, aggMat = "sum", aggRatio = 4, method = "adaptive-spTD")
Y_HF <- C_sparse$y_Est[,1]  # Temporal disaggregated observations

# -------------------------------
# 6. Proportional (Linear) Interpolation
# -------------------------------

# Create xts objects for interpolation
Y_temp <- xts(Y_LF / 4, order.by = Dates_LF) # Divide by 4 as per aggregation ratio

# Merge low-frequency and high-frequency dates
Y_temp2 <- merge(Y_temp, xts(rep(NA, length(Dates_HF)), order.by = Dates_HF))

# Perform linear interpolation to fill NA values
Y_HF_approx <- as.numeric(na.approx(Y_temp2[,1], rule = 2)) # Ensure it's a numeric vector

# -------------------------------
# 7. Prepare Data for ggplot2
# -------------------------------

# Create a data frame combining all series
plot_data <- data.frame(
  Date = Dates_HF,
  Temporal_Disaggregated = Y_HF,
  Interpolated = Y_HF_approx
)

# Convert to long format suitable for ggplot2
plot_long <- pivot_longer(
  plot_data,
  cols = c("Temporal_Disaggregated", "Interpolated"),
  names_to = "Series",
  values_to = "Value"
)

# -------------------------------
# 8. Rename Series Labels to Remove Underscores
# -------------------------------

# Use dplyr's mutate and recode to rename Series labels
plot_long <- plot_long %>%
  mutate(Series = recode(Series,
                         "Temporal_Disaggregated" = "Temporal Disaggregated",
                         "Interpolated" = "Interpolated"))

# -------------------------------
# 9. Create the ggplot2 Plot
# -------------------------------

ggplot(plot_long, aes(x = Date, y = Value, color = Series, linetype = Series)) +
  geom_line(size = 0.5) +       # Plot lines for all series
  geom_point(data = filter(plot_long, Series == "Temporal Disaggregated"), size = 1.5) + # Plot points only for Temporal Disaggregated
  labs(
    title = "",
    x = "Time",
    y = "GHG Emissions"  # Added y-axis label as per original code
  ) +
  theme_minimal(base_size = 14) +  # Apply a clean minimal theme with larger base font size
  theme(
    panel.grid.major = element_blank(),    # Remove major gridlines
    panel.grid.minor = element_blank(),    # Remove minor gridlines
    legend.position = "top",               # Position legend at the top
    legend.title = element_blank(),        # Remove legend title
    legend.text = element_text(size = 12), # Increase legend text size for readability
    plot.title = element_text(
      hjust = 0.5, size = 16, face = "bold" # Center and style the plot title
    ),
    axis.text = element_text(size = 12),   # Increase axis text size
    axis.title = element_text(size = 14)   # Increase axis title size
  ) +
  scale_color_manual(
    values = c(
      "Temporal Disaggregated" = "black",
      "Interpolated" = "blue"
    )
  ) +
  scale_linetype_manual(
    values = c(
      "Temporal Disaggregated" = "solid",
      "Interpolated" = "dashed"
    )
  ) +
  guides(
    color = guide_legend(nrow = 1, byrow = TRUE),    # Arrange legend items in one row
    linetype = guide_legend(nrow = 1, byrow = TRUE) # Ensure linetype legend aligns with color
  )

