# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2025-030.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE,
                      fig.align = 'center',
                      fig.pos = 'H',
                      fig.show = 'hold')


## ----child="Introduction.Rmd"-------------------------------------------------

## ----setup1, include=FALSE----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)

library(cluster)



## ----child="Applications.Rmd"-------------------------------------------------

## ----setup2, include=FALSE----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)


## ----eval=FALSE, echo=TRUE----------------------------------------------------
# # Load necessary library
# library(EBImage)
# 
# # Load the image from the specified path
# image <- readImage("figures/beads.png")
# 
# # Display the original image
# EBImage::display(image)
# 
# # Apply a threshold to the original image to create a binary image
# img_thresh <- thresh(image, offset = 0.05)
# 
# # Read the binary image and display it
# EBImage::display(img_thresh)
# 
# # Perform watershed segmentation on the distance map of the thresholded image
# segmented <- EBImage::watershed(distmap(img_thresh))
# 
# # Color the labels of the segmented image
# segmented_col <- colorLabels(segmented)
# 
# # Display the resulting image after watershed segmentation
# EBImage::display(segmented_col)


## ----eval=FALSE, echo=FALSE---------------------------------------------------
# # Annotate images with magick
# library(magick)
# 
# # Save the original image to a temporary file
# temp_file <- tempfile(fileext = ".png")
# EBImage::writeImage(image, temp_file)
# 
# # Read the image from the temporary file using the magick package
# magick_image <- image_read(temp_file)
# 
# # Annotate the image with the letter 'A' using magick, specify size, color, and location
# magick_image <-
#   image_annotate(
#     magick_image,
#     text = "A",
#     size = 40,
#     color = 'red',
#     location = '+452+326'
#   )
# 
# EBImage::display(as_EBImage(magick_image))
# 
# # Apply a threshold to the original image to create a binary image
# img_thresh <- thresh(image, offset = 0.05)
# EBImage::writeImage(img_thresh, temp_file)
# 
# # Read the thresholded image, annotate it, and display
# magick_img_thresh <- image_read(temp_file)
# magick_img_thresh <-
#   image_annotate(
#     magick_img_thresh,
#     text = "B",
#     size = 40,
#     color = 'red',
#     location = '+452+326'
#   )
# EBImage::display(as_EBImage(magick_img_thresh))
# 
# # Perform watershed segmentation on the distance map of the thresholded image
# segmented <- EBImage::watershed(distmap(img_thresh))
# 
# # Color the labels of the segmented image
# segmented_col <- colorLabels(segmented)
# EBImage::writeImage(segmented_col, temp_file)
# 
# # Read the colored segmented image, annotate it, and display
# magick_segmented <- image_read(temp_file)
# magick_segmented <-
#   image_annotate(
#     magick_segmented,
#     text = "C",
#     size = 40,
#     color = 'red',
#     location = '+452+326'
#   )
# EBImage::display(as_EBImage(magick_segmented))


## ----echo=FALSE---------------------------------------------------------------
if(!require(knitr)) {
  install.packages("knitr")
}


## ----EBIoriginal, echo=FALSE, out.width="50%", fig.cap="(ref:EBIoriginal)"----
#EBImage::writeImage(as_EBImage(magick_segmented), "figures/EBImage3.png")
knitr::include_graphics("figures/EBImage1.png")
knitr::include_graphics("figures/EBImage2.png")
knitr::include_graphics("figures/EBImage3.png")


## ----echo=FALSE---------------------------------------------------------------
if(!require(biopixR)) {
  install.packages("biopixR")
}


## ----echo=TRUE----------------------------------------------------------------
# Loading necessary package
library(biopixR)

# Importing the image
beads <- importImage("figures/beads2.jpg")


## ----echo=TRUE, eval=FALSE----------------------------------------------------
# # Plot original image
# beads |> plot(axes = FALSE)


## ----echo=TRUE, eval=FALSE----------------------------------------------------
# # Converting the image to grayscale
# beads <- grayscale(beads)
# 
# # Detecting objects in the image using edge detection
# objects <-
#   objectDetection(beads,                # Image to process
#                   method = 'edge',      # Method for object detection
#                   alpha = 1,            # Threshold adjustment factor
#                   sigma = 0)            # Smoothing factor
# 
# # Displaying internal visualization of object detection with marked contours
# # and centers
# objects$marked_objects |> plot(axes = FALSE)
# 
# # Adding text annotations at the centers of detected objects
# text(objects$centers$mx,     # x-coordinates of object centers
#      objects$centers$my,     # y-coordinates of object centers
#      objects$centers$value,  # Text to display (value of the object center)
#      col = "green",          # Color of the text
#      cex = 1.5)


## ----biobeads0, out.width="66%", fig.cap="(ref:biobeads0)", fig.show='hold', echo=FALSE----
knitr::include_graphics("figures/beads4.png")
knitr::include_graphics("figures/beads5.png")


## ----echo=FALSE---------------------------------------------------------------
if(!require(EBImage)) {
  if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
  }
  BiocManager::install("EBImage")
}
if(!require(pliman)) {
  install.packages("pliman")
}


## ----pliman1, echo=TRUE, error=TRUE, fig.cap="(ref:pliman1)", out.width="49%"----
try({
# Loading necessary package
library(pliman)

# Import requires EBImage:
# Importing the main image
beads <- EBImage::readImage("figures/beads2.jpg")

# Importing additional images for background and foreground
foreground <- EBImage::readImage("figures/foreground.jpg")
background <- EBImage::readImage("figures/background.jpg")

# Displaying the microbead image
EBImage::display(beads)

# Combining the foreground and background images and arranging them in 2 rows
pliman::image_combine(foreground, background, nrow = 2, col = "transparent")
})


## ----pliman2, echo=TRUE, fig.cap="(ref:pliman2)", out.width="69%"-------------
# Performing segmentation based on provided background and foreground images
analyze_objects(
  img = beads,               # Main image of microbeads
  background = background,   # Background sample image
  foreground = foreground,   # Foreground sample image
  marker = "id",             # Displaying enumeration
  contour_col = "yellow"     # Color for the contour of the segmented objects
)


## ----echo=FALSE---------------------------------------------------------------
if(!require(FIELDimageR)) {
  # You may need other packages first:
  install.packages(c('terra','mapview','sf','stars','caret','mapedit','devtools',"dplyr","fields","leafem","leafsync","lwgeom","BiocManager","git2r","exactextractr"))

  # FIELDimageR:
  devtools::install_github("OpenDroneMap/FIELDimageR")
  devtools::install_github("filipematias23/FIELDimageR.Extra")
}


## ----echo=TRUE----------------------------------------------------------------
# Loading necessary packages
library(FIELDimageR)
library(FIELDimageR.Extra)
library(terra)
library(sf)
library(leafsync)
library(mapview)

# Using the same image as imported in the previous example
# Creating a SpatRaster object using the 'terra' package
EX.P <- rast("figures/beads2.jpg")
EX.P <- imgLAB(EX.P)


## ----echo=FALSE---------------------------------------------------------------
EX.P.R1 <-
  fieldMask(
    mosaic = EX.P,    # Input SpatRaster object
    index = "BIM",    # Index representing vegetation
    cropValue = 5,    # Threshold value for the index
    cropAbove = F,    # Indicates to remove values below the threshold
    plot = F
  )


## ----echo=TRUE, eval=FALSE----------------------------------------------------
# # Removing background based on a vegetation index
# EX.P.R1 <-
#   fieldMask(
#     mosaic = EX.P,    # Input SpatRaster object
#     index = "BIM",    # Index representing vegetation
#     cropValue = 5,    # Threshold value for the index
#     cropAbove = F     # Indicates to remove values below the threshold
#   )
# 
# # Displaying the original, background, and foreground images
# EX.P.R1$newMosaic


## ----FIELD1, echo=FALSE, out.width="100%", fig.cap="(ref:FIELD1)", fig.show='hold'----
knitr::include_graphics("figures/FIELDimageR1_1.png")


## ----echo=TRUE, eval=FALSE----------------------------------------------------
# # Labeling of all microbeads
# EX.P.Total <- fieldCount(mosaic = EX.P.R1$mask, plot = T)


## ----echo=FALSE---------------------------------------------------------------
# Labeling of all microbeads
EX.P.Total <- fieldCount(mosaic = EX.P.R1$mask, plot = F)


## ----FIELD2, out.width="100%", fig.cap="(ref:FIELD2)", fig.show='hold'--------
knitr::include_graphics("figures/FIELDimageR2_1.png")


## ----leaflet, echo=TRUE, eval=FALSE-------------------------------------------
# # Combining the 'FIELDimageR.Extra', 'mapview' and 'leafsync' to create an
# # interactive view
# m1 <- fieldView(EX.P, r = 1, g = 2, b = 3)
# m2 <- mapview(EX.P.Total)
# sync(m1, m2)


## ----leafletPDF, results='asis', echo=FALSE, out.width="100%", fig.cap="(ref:leafletPDF)"----
if (knitr::is_latex_output()) {
  knitr::include_graphics("figures/FIELDimageR_shiny.png")
} else {
  # Combining the `FIELDimageR.Extra`, `mapview` and `leafsync` to create an 
  # interactive view
  m1 <- fieldView(EX.P, r = 1, g = 2, b = 3)
  m2 <- mapview(EX.P.Total)
  sync(m1, m2)
}


## ----SOM, eval=FALSE, echo=TRUE-----------------------------------------------
# # Load the 'biopixR' package
# library(biopixR)
# 
# # Import an image from the specified path
# img <- importImage("figures/beads.png")
# 
# # Set seed for reproducibility
# set.seed(123)
# 
# # Extract shape features from the image
# result <- shapeFeatures(
#   img,
#   alpha = 0.8,
#   sigma = 0.7,
#   xdim = 2,
#   ydim = 1,
#   SOM = TRUE,
#   visualize = FALSE
# )
# 
# # Define colors for plotting points based on classes
# colors <- c("darkgreen", "darkred")
# 
# # Plot the image without axes and add colored points representing the classes
# img |> plot(axes = FALSE)
# with(result,
#      points(
#        result$x,
#        result$y,
#        col = colors[factor(result$class)],
#        pch = 19,
#        cex = 1.2
#      ))
# text(c(471), c(354), c("A"), col = "darkred", cex = 5)
# 
# # Create a data frame with various shape features and the pixel-intensity
# df <- data.frame(
#   size = result$size,
#   intensity = result$intensity,
#   perimeter = result$perimeter,
#   circularity = result$circularity,
#   eccentricity = result$eccentricity,
#   radius = result$mean_radius,
#   aspectRatio = result$aspect_ratio
# )
# 
# # Min-Max Normalization Function
# min_max_norm <- function(x) {
#   (x - min(x)) / (max(x) - min(x))
# }
# 
# # Applying the function to each column
# df_normalized <- as.data.frame(lapply(df, min_max_norm))
# 
# # Create a boxplot of the normalized data
# boxplot(
#   df_normalized,
#   ylab = "normalized values",
#   xaxt = "n",
#   cex.lab = 1.25,
#   cex.axis = 1.25
# )
# 
# # Add axis ticks and diagonal labels
# axis(1, at = 1:ncol(df), labels = FALSE)  # Add axis ticks but no labels
# text(
#   cex = 1.2,
#   x = seq_len(ncol(df_normalized)),
#   y = -0.07,
#   labels = colnames(df_normalized),
#   adj = 0,
#   srt = -45,
#   xpd = TRUE
# )
# 
# # Highlight specific rows based on class
# highlight_rows <-
#   which(result$class == 2)  # Example row indices to highlight
# 
# # Add points for the specific rows
# # Adding points for each column
# for (col in 1:ncol(df_normalized)) {
#   points(
#     rep(col, length(highlight_rows)),
#     df_normalized[highlight_rows, col],
#     col = "red",
#     pch = 19,
#     cex = 1.5
#   )
# }
# 
# text(c(0.5),
#      c(0.98),
#      c("B"),
#      col = "darkred",
#      cex = 5)


## ----shapefeatures, out.width="85%", fig.cap="(ref:shapefeatures)"------------
knitr::include_graphics("figures/shape_test2.png")
knitr::include_graphics("figures/shape_test1.png")



## ----child="Essentials.Rmd"---------------------------------------------------

## ----setup3, include=FALSE----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)



## ----eval = FALSE, echo = FALSE, fig.show='hold', fig.align='center'----------
# library(digitize)
# library(imager)
# 
# img <- load.image("test3.png")
# img |> dim()
# plot(img)
# 
# digitize("test3.png")


## ----echo=FALSE---------------------------------------------------------------
if(!require(EBImage)) {
  if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
  }
  BiocManager::install("EBImage")
}


## ----digitize, echo=FALSE, fig.cap="(ref:digitize)", fig.show='hold', out.width="89%", fig.align='center'----
img <- EBImage::readImage("figures/digitize.png")
EBImage::display(img)


## ----echo=FALSE---------------------------------------------------------------
if(!require(image2data)) {
  install.packages("image2data")
}
if(!require(data.table)) {
  install.packages("data.table")
}


## ----img2data, eval = TRUE, echo = TRUE, out.width="65%", fig.cap="(ref:img2data)", fig.show='hold'----
# Loading the required packages
library(image2data)
library(data.table)

# Path to the image file
image <- "figures/test3.png"
img <- EBImage::readImage(image)

# Subsampling the image data
beads_subsample <- image2data(
  path = image,                    # Path to the image file
  reduce = .2,                     # Reduction factor for subsampling 
                                   # (20 % of original number of pixels)
  seed = 42,                       # Seed for random number generation by
                                   # return (for reproducibility)
  showplot = FALSE                 # Whether to show a plot of the subsampled data
) |> as.data.table()               # Converting the result to a data.table

# Display a part of the subsampled data
beads_subsample

EBImage::display(img)

# Plotting the subsampled data
plot(beads_subsample$x,            # x-coordinates
     beads_subsample$y,            # y-coordinates
     col = beads_subsample$g,      # Color based on hex code extracted by image2data()
     pch = 19,                     # Plotting character (solid circle)
     xlab = "",
     ylab = "")


## ----echo=FALSE---------------------------------------------------------------
if(!require(knitr)) {
  install.packages("knitr")
}


## ----colocrGUI, fig.align='center', fig.show='hold', fig.cap="(ref:colocrGUI)", out.width="69%"----
knitr::include_graphics("figures/colocr_gui.png")


## ----echo=FALSE---------------------------------------------------------------
if(!require(kableExtra)) {
  install.packages("kableExtra")
}


## ----overview1----------------------------------------------------------------
library(knitr)
library(kableExtra)

if (knitr::is_latex_output()) {
  data <- read.csv("data/honorable_mentions_pdf.csv")
} else {
  data <- read.csv("data/honorable_mentions_html.csv")
}

kable(
  data,
  format = "markdown",
  booktabs = TRUE,
  caption = "Overview of `R` packages for tailored applications in image processing. This table summarizes key aspects such as general application, repository (Repo) hosting (CRAN, Bioconductor (Bioc), GitLab), linked libraries, and package dependencies. It also includes information on licensing and current status. The current status is divided into the date of first publication on the corresponding repository (*). Active repository status is indicated by a circle, with the date of the latest update (°). Some packages that are no longer maintained are marked as archived (†).",
  col.names = c(
    "",
    "Application",
    "Repo",
    "based on",
    "License",
    "Status"
  ),
  align = "lccccc",
  escape = FALSE
)



## ----child="Discussion.Rmd"---------------------------------------------------

## ----setup5, include=FALSE----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)



## ----DSBanalysis, eval=FALSE, echo=TRUE---------------------------------------
# # Load the 'biopixR' package
# library(biopixR)
# 
# # Import image from specified path
# DSB_img <- importImage("figures/tim_242602_c_s3c1+2+3m4.tif")
# 
# # Extract the blue color channel representing the nuclei and
# # the green color channel representing yH2AX foci
# core <- as.cimg(DSB_img[, , , 3])
# yH2AX <- as.cimg(DSB_img[, , , 2])
# 
# # Process the nuclei: thresholding, labeling, and converting to a data frame
# cores <-
#   threshold(core) |> label() |> as.data.frame() |> subset(value > 0)
# 
# # Calculate the center and size for the nuclei
# DT <- as.data.table(cores)
# cores_center <-
#   DT[, list(mx = mean(x),
#             my = mean(y),
#             size = length(x)), by = value]
# 
# # Filter the nuclei based on size, to discard noise
# cores_clean <-
#   sizeFilter(cores_center,
#              cores,
#              lowerlimit = 150,
#              upperlimit = Inf)
# 
# # Detect objects yH2AX foci in green color channel
# DSB <- objectDetection(yH2AX, alpha = 1.1, sigma = 0)
# 
# # Function to compare coordinates from two data frames and count matches
# compareCoordinates <- function(df1, df2) {
#   # Create a single identifier for each coordinate pair
#   df1$coord_id <- paste(round(df1$mx), round(df1$my), sep = ",")
#   df2$coord_id <- paste(df2$x, df2$y, sep = ",")
# 
#   # Find matches by checking if coordinates from df2 exist in df1
#   matches <- df2$coord_id %in% df1$coord_id
# 
#   # Convert df2 to a data table and add a column indicating matches
#   DT <- data.table(df2)
#   DT$DSB <- matches
# 
#   # Summarize the results
#   result <-
#     DT[, list(count = length(which(DSB == TRUE))), by = value]
# 
#   return(result)
# }
# 
# # Compare coordinates between detected DSB centers and cleaned nuclei coordinates
# count <- compareCoordinates(DSB$centers, cores_clean$coordinates)
# 
# # Extract the count column for further analysis
# to_analyze <- count[, 2]


## ----DSB, out.width="95%", fig.cap="(ref:DSB)", fig.show='hold'---------------
knitr::include_graphics("figures/fig_DSB.png")


## ----countfitteR, out.width="89%", fig.cap="(ref:countfitteR)"----------------
knitr::include_graphics("figures/count_distr.png")


## ----overview2----------------------------------------------------------------
library(knitr)
library(kableExtra)

if (knitr::is_latex_output()) {
  data <- read.csv("data/package_summary_pdf.csv")
} else {
  data <- read.csv("data/package_summary_html.csv")
}

kable(
  data,
  format = "markdown",
  booktabs = TRUE,
  caption = "Summary of key characteristics of major `R` packages for image processing. The table details general applications, repository (Repo) sources (CRAN, Bioconductor (Bioc), and GitHub), primary package or library dependencies, and licensing information. The status column indicates the date of first publication (*) and the most recent update (°) for each package.",
  col.names = c(
    "",
    "Application",
    "Repo",
    "based on",
    "License",
    "Status"
  ),
  align = "lccccc",
  escape = FALSE
)


## ----dendro, echo=FALSE, message=FALSE, fig.cap="(ref:dendro)", fig.show='hold', out.width="79%", fig.align='center'----
# to do: check if all packages are installed [x] 

# list of packages
packages <-
  c(
    "imager",
    "magick",
    "EBImage",
    "biopixR",
    "pliman",
    "mxnorm",
    "DIMPLE",       # not available for R4.3.3
    "cytomapper",   # not available for R4.3.3
    "SPIAT",        # not available for R4.3.3
    "spatialTIME",
    "celltrackR",
    "FIELDimageR",
    "fslr",
    "colocr",
    "imageseg",
    "SimpleITK",
    "pixelclasser",
    "OpenImageR",
    "RNiftyReg"
  )

# install all packages
# for (pkg in packages) {
#   # check if package is installed
#   if (!requireNamespace(pkg, quietly = TRUE)) {
#     if (pkg == "SimpleITK") {
#       install.packages("remotes")
#       remotes::install_github("SimpleITK/SimpleITKRInstaller")
#     }
#
#     if(!require(pkg == "SPIAT")) {
#       BiocManager::install("SPIAT")
#     }
#
#     install.packages(pkg)
#   }
# }

# function to generate dependency matrix
generate_dependancy_matrix <- function(packages) {
  dependency_matrix <-
    matrix(
      0,
      nrow = length(packages),
      ncol = length(packages),
      dimnames = list(packages, packages)
    )

  # iterate over each package
  for (pkg in packages) {
    # check if package is installed
    if (requireNamespace(pkg, quietly = TRUE)) {
      # load packages
      library(pkg, character.only = TRUE)

      # check for dependencies and imports of the packages
      dependencies <-
        c(packageDescription(pkg)$Depends,
          packageDescription(pkg)$Imports)
      dependencies <- unlist(strsplit(dependencies, ", |,"))

      # add new packages to the list of packages
      new_packages <- setdiff(dependencies, packages)
      packages <- c(packages, new_packages)

      # update dependency matrix
      if (length(new_packages) > 0) {
        dependency_matrix <-
          cbind(dependency_matrix,
                matrix(
                  0,
                  nrow = nrow(dependency_matrix),
                  ncol = length(new_packages)
                ))
        #dependency_matrix <- rbind(dependency_matrix, matrix(0, nrow = length(new_packages), ncol = ncol(dependency_matrix)))
        colnames(dependency_matrix) <- packages
      }

      # check which dependencies are also in the list of packages and change value
      for (dep in unlist(strsplit(dependencies, ","))) {
        dep <- gsub("", "", dep)
        if (dep %in% packages) {
          # update packages matrix
          dependency_matrix[pkg, dep] <- 1
        }
      }
    }
  }

  # return the dependency matrix and update list of packages
  return(list(dependency_matrix, packages))
}

result <- generate_dependancy_matrix(packages)
dependency_matrix <- result[[1]]

#print(dependency_matrix)

# Load necessary library
library(stats)

# Calculate distance matrix for rows
row_dist <- stats::dist(dependency_matrix, method = "binary")

# Perform hierarchical clustering
row_clusters <- hclust(row_dist, method = "complete")

plot(as.dendrogram(row_clusters), ann = FALSE)
#mtext("Distance", side = 1, line = 2) 
mtext("Relation", side = 2, line = 2)



## ----child="Conclusion.Rmd"---------------------------------------------------

## ----setup4, include=FALSE----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)



## ----fig.show='hold', fig.align='center', echo=FALSE--------------------------
sup_formats <- read.csv("data/supported_formats.csv")
knitr::kable(
  sup_formats,
  format = "markdown",
  booktabs = TRUE,
  caption = "Supported File Formats by Main Image Processing Packages",
  col.names = c("",
                "`imager`",
                "`magick`",
                "`EBImage`",
                "`OpenImageR`",
                "`SimpleITK`"),
  align = "lccccc",
  escape = FALSE
)


## -----------------------------------------------------------------------------
sessionInfo()


