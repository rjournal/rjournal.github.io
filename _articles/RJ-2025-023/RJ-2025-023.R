# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2025-023.Rmd to modify this file

## ----setup, include=FALSE---------------------------------------------------------------------------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(dplyr)
library(ggplot2)
library(tsibble)
library(theft)
library(theftdlc)


## ----workflow, out.width = "400px", out.height = "450px", dpi = 300, fig.align = 'center', fig.cap = "theft and theftdlc together implement a workflow for extracting features from univariate time series and processing and analyzing the results. First, the user can install the relevant Python libraries (A) within R and point it to the correctly installed versions (B). Next, a time-series dataset (C) is converted into a tsibble (D) with key variables, a time index variable, and a measured variable. One or more feature sets or custom user-supplied features are then computed on the dataset (E). A range of statistical analysis and data visualization functionality is available in theftdlc on the resulting feature data, including: (F) normalized time series x feature matrix visualization; (G) normalized feature x feature correlation matrix visualization; (H) violin plots of feature distributions (including by group/class where applicable); (I) basic feature selection using penalized maximum likelihood generalized linear models; (J) low-dimensional projections of the feature space; (K) time-series classification procedures (a common application of feature-based time-series analysis); (L) evaluating the uncertainty intervals of the resulting performance metrics through a range of distributional summary methods; and uncovering hidden structure in time-series data through cluster analysis in the feature space.", fig.alt = "Workflow of the theft and theftdlc packages for R which takes the user from tidy time-series data through to feature extraction through to visualization and statistical analysis of features."----
knitr::include_graphics("figures/workflow-graphic_ecosystem-final.png")


## ----echo=FALSE-------------------------------------------------------------------------------------------------------------------------------
temp <- tempfile()
download.file(
  "https://github.com/hendersontrent/bonn-eeg-data/raw/refs/heads/main/INP_Bonn_EEG.txt.zip",
  temp
)
bonn_eeg <- read.table(unz(temp, "INP_Bonn_EEG.txt"))
unlink(temp)
bonn_eeg <- as_tsibble(bonn_eeg, key = c("id", "group"), index = "timepoint")


## ----message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE--------------------------------------------------------------------------------------
# install_python_pkgs(venv = "theft-eco-py", python = "/usr/local/bin/python3.10")
# init_theft("theft-eco-py")


## ----message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE--------------------------------------------------------------------------------------
# all_features <- calculate_features(
#   data = bonn_eeg,
#   feature_set = c("catch22", "feasts", "tsfeatures",
#                   "tsfresh", "tsfel", "kats"),
#   use_compengine = FALSE, catch24 = TRUE)


## ----message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE--------------------------------------------------------------------------------------
# all_features_msd <- calculate_features(
#                         data = bonn_eeg,
#                         feature_set = c("catch22", "feasts", "tsfeatures",
#                                         "tsfresh", "tsfel", "kats"),
#                         features = list("mean" = mean, "sd" = sd),
#                         use_compengine = FALSE)


## ----echo=TRUE--------------------------------------------------------------------------------------------------------------------------------
files <- c("all_features", "mf_results", "feature_classifiers")

for(f in files){
  temp <- tempfile()
  download.file(paste0("https://github.com/hendersontrent/bonn-eeg-data/raw/refs/heads/main/", 
                       f, ".Rda"), temp)
  load(temp)
  unlink(temp)
}


## ----featureMatrix, echo=TRUE, fig.height = 5, fig.width = 5, fig.cap = "A time series by feature matrix heatmap produced by generating a matrix plot on the feature calculations object. Extracted feature vectors for each time series (500) in the Bonn EEG dataset using all six feature sets in theft (1005 features in total, after filtering out 85 features with NaN values) are represented as a heatmap. Similar features (columns) and time series (rows) are positioned close to each other using (average) hierarchical clustering. Each tile is a normalized value for a given time series and feature."----
plot(all_features, 
     type = "matrix", 
     norm_method = "RobustSigmoid", 
     clust_method = "average")


## ----echo = TRUE, eval = FALSE----------------------------------------------------------------------------------------------------------------
# low_dim_calc <- project(all_features,
#                         method = "MinMax",
#                         low_dim_method = "tSNE",
#                         perplexity = 15)
# 
# plot(low_dim_calc)


## ----tsne, echo=FALSE, eval = TRUE, fig.width = 6, fig.asp=1, fig.cap = "Low-dimensional projection of the Bonn EEG dataset using theft. Using t-SNE with perplexity 15, the high-dimensional feature space of >1000 features is projected into two dimensions. Each point represents a time series which is colored according to its class label. Time series that are located close in this space have similar properties, as measured by the six feature sets in theft."----
low_dim_calc <- project(all_features, 
                        method = "MinMax", 
                        low_dim_method = "tSNE", 
                        perplexity = 15)

plot(low_dim_calc) +
  guides(colour = guide_legend(nrow = 2, byrow = TRUE))


## ----message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE--------------------------------------------------------------------------------------
# mf_results <- classify(
#                 data = all_features,
#                 by_set = TRUE,
#                 train_size = 0.8,
#                 n_resamples = 100,
#                 use_null = TRUE)


## ----message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE--------------------------------------------------------------------------------------
# rbfClassifier <- function(formula, data){
#   mod <- e1071::svm(formula, data = data, kernel = "radial", scale = FALSE,
#                     probability = TRUE)
# }
# 
# mf_results_rbf <- classify(
#                     data = all_features,
#                     classifier = rbfClassifier,
#                     by_set = TRUE,
#                     train_size = 0.8,
#                     n_resamples = 100,
#                     use_null = TRUE)


## ----warning=FALSE, message=FALSE, echo=TRUE, eval=TRUE---------------------------------------------------------------------------------------
set_intervals <- theftdlc::interval(
  mf_results, 
  metric = "accuracy",
  by_set = TRUE,
  type = "sd",
  model_type = "main"
  )

set_intervals


## ----featureSetComparisons, echo=TRUE, fig.height = 4, fig.width = 5, fig.cap = "Comparison of mean classification accuracy between feature sets in theft for the five-class Bonn EEG classification task. Classification accuracy using a linear SVM is presented for each of the six feature sets in theft as well as the combination of all their features. The number of features retained for analysis after filtering is displayed in parentheses after the feature set name on the horizontal axis which has been sorted from highest to lowest mean accuracy. Mean classification accuracy across the same 100 resamples is displayed as colored points for each set with one standard deviation error bars."----
plot(set_intervals)


## ----message=FALSE, warning=FALSE, echo=TRUE, eval=FALSE--------------------------------------------------------------------------------------
# compare_features(mf_results,
#                  metric = "accuracy",
#                  by_set = TRUE,
#                  hypothesis = "null",
#                  p_adj = "none")


## ----echo=FALSE, eval=TRUE--------------------------------------------------------------------------------------------------------------------
knitr::kable(compare_features(mf_results,
                 metric = "accuracy",
                 by_set = TRUE,
                 hypothesis = "null",
                 p_adj = "none") |> 
               dplyr::select(-c(feature_set, metric)),
             booktabs = TRUE,
             digits = 3)


## ----message=FALSE, warning=FALSE, echo=TRUE, eval=FALSE--------------------------------------------------------------------------------------
# compare_features(mf_results,
#                  metric = "accuracy",
#                  by_set = TRUE,
#                  hypothesis = "pairwise",
#                  p_adj = "none")


## ----echo=FALSE-------------------------------------------------------------------------------------------------------------------------------
knitr::kable(compare_features(mf_results,
                 metric = "accuracy",
                 by_set = TRUE,
                 hypothesis = "pairwise",
                 p_adj = "none") |> 
               dplyr::select(-c(feature_set_a, feature_set_b, metric)),
             booktabs = TRUE,
             digits = 3)


## ----message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE--------------------------------------------------------------------------------------
# feature_classifiers <- classify(data = all_features,
#                                by_set = FALSE,
#                                train_size = 0.8,
#                                n_resamples = 100,
#                                use_null = TRUE)


## ----message=FALSE, warning=FALSE, echo=TRUE--------------------------------------------------------------------------------------------------
feature_vs_null <- compare_features(feature_classifiers,
                                    by_set = FALSE,
                                    hypothesis = "null",
                                    n_workers = 6)


## ----message=FALSE, warning=FALSE, echo=TRUE--------------------------------------------------------------------------------------------------
top_40 <- feature_vs_null |>
  dplyr::slice_max(feature_mean, n = 40)


## ----echo=TRUE, eval=FALSE--------------------------------------------------------------------------------------------------------------------
# top_40 |>
#   top_n(feature_mean, n = 20)


## ----echo=FALSE-------------------------------------------------------------------------------------------------------------------------------
if(knitr::is_html_output()){
  knitr::kable(top_40 |> 
               dplyr::select(-c(names, original_names, feature_set, metric)) |>
               top_n(feature_mean, n = 20),
               booktabs = TRUE,
               digits = 3)
} else{
  knitr::kable(top_40 |> 
               dplyr::select(-c(names, original_names, feature_set, metric)) |>
               top_n(feature_mean, n = 20) |>
               mutate(hypothesis = gsub('tsfresh_values\\_\\_', 'tsfresh_values\\_\\_\n', hypothesis),
                      hypothesis = gsub('attr\\_', 'attr\\_\n', hypothesis),
                      hypothesis = gsub('"mean"\\_\\_', '"mean"\\_\\_\n', hypothesis)),
               booktabs = TRUE,
               digits = 3) |>
  kableExtra::column_spec(1, width = "6cm")
}


## ----echo=TRUE, eval=FALSE, fig.height = 5, fig.width = 5, fig.cap = "A group of change quantile and difference-associated features and a group of autocorrelation-sensitive features perform the best at distinguishing between the five classes in the Bonn EEG dataset using the absolute Spearman correlation coefficient to capture feature-feature similarity. To aid the identification of similarly performing features, the matrix of correlation coefficients between features were then organized using hierarchical clustering (on Euclidean distances with average linkage) along rows and columns to order the heatmap graphic."----
# feature_matrix_filt <- all_features |>
#   dplyr::filter(feature_set %in% top_40$feature_set &
#                   names %in% top_40$original_names) |>
#   structure(class = c("feature_calculations", "data.frame"))
# 
# plot(feature_matrix_filt, type = "cor")


## ----topFeatureCorrelations, echo=FALSE, eval=TRUE, fig.height = 7, fig.width = 5, fig.cap = "A group of change quantile and difference-associated features and a group of autocorrelation-sensitive features perform the best at distinguishing between the five classes in the Bonn EEG dataset using the absolute Spearman correlation coefficient to capture feature-feature similarity. To aid the identification of similarly performing features, the matrix of correlation coefficients between features were then organized using hierarchical clustering (on Euclidean distances with average linkage) along rows and columns to order the heatmap graphic."----
# Recode part of {theftdlc} plot() function for correlation matrix as geom_tile() instead of geom_raster() so it renders in .pdf format clearly

plot_tile <- function(x, clust_method = c("average", "ward.D", "ward.D2", "single", "complete", "mcquitty", "median", "centroid"),
                      cor_method = c("pearson", "spearman"), ...){

  clust_method <- match.arg(clust_method)
  cor_method <- match.arg(cor_method)

  #------------- Clean up structure --------------

    data_id <- x %>%
      dplyr::select(c(.data$id, .data$names, .data$values, .data$feature_set)) %>%
      tidyr::drop_na() %>%
      dplyr::mutate(names = paste0(.data$feature_set, "_", .data$names)) %>% # Catches errors when using all features across sets (i.e., there's duplicates)
      dplyr::select(-c(.data$feature_set))

    #------------- Data reshaping -------------------

    features <- unique(data_id$names)

    ids_to_keep <- data_id %>%
      dplyr::group_by(.data$id) %>%
      dplyr::summarise(counter = dplyr::n()) %>%
      dplyr::ungroup() %>%
      dplyr::filter(.data$counter == length(features))

    ids_to_keep <- ids_to_keep$id

    cor_dat <- data_id %>%
      dplyr::filter(.data$id %in% ids_to_keep) %>%
      tidyr::pivot_wider(id_cols = "id", names_from = "names", values_from = "values") %>%
      dplyr::select(-c(.data$id))

    #--------- Correlation ----------

    # Calculate correlations and take absolute

    result <- abs(stats::cor(cor_dat, method = cor_method))

    #--------- Clustering -----------

    # Wrangle into tidy format

    melted <- reshape2::melt(result)

    # Perform clustering

    row.order <- stats::hclust(stats::dist(result, method = "euclidean"), method = clust_method)$order # Hierarchical cluster on rows
    col.order <- stats::hclust(stats::dist(t(result), method = "euclidean"), method = clust_method)$order # Hierarchical cluster on columns
    dat_new <- result[row.order, col.order] # Re-order matrix by cluster outputs
    cluster_out <- reshape2::melt(as.matrix(dat_new)) # Turn into dataframe

    #--------- Graphic --------------

    # Define a nice colour palette consistent with RColorBrewer in other functions

    mypalette <- c("#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC")

    p <- cluster_out %>%
      ggplot2::ggplot(ggplot2::aes(x = .data$Var1, y = .data$Var2)) +
      ggplot2::geom_tile(ggplot2::aes(fill = .data$value), ...) +
      ggplot2::labs(title = "Pairwise correlation matrix",
                    x = "Feature",
                    y = "Feature",
                    fill = "Absolute correlation coefficient") +
      ggplot2::scale_fill_stepsn(n.breaks = 6, colours = rev(mypalette),
                                 show.limits = TRUE) +
      ggplot2::theme_bw() +
      ggplot2::theme(panel.grid = ggplot2::element_blank(),
                     legend.position = "bottom")

    if(ncol(cor_dat) <= 20){
      p <- p +
        ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1))
    } else {
      p <- p +
        ggplot2::theme(axis.text = ggplot2::element_blank())
    }

    return(p)
}

feature_matrix_filt <- all_features |>
  dplyr::filter(feature_set %in% top_40$feature_set & 
                  names %in% top_40$original_names) |>
  structure(class = c("feature_calculations", "data.frame"))

plot_tile(feature_matrix_filt, type = "cor") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 4))


## ----topFeatureViolins, echo=TRUE, fig.height = 4, fig.width = 5, fig.cap = "Violin plots (on original feature value scale) of a sample of two of the top 40 features of all six feature sets in theft for classifying Bonn EEG groups. Classes differ in their variance and autocorrelation properties."----
plot(feature_matrix_filt,
     type = "violin", 
     feature_names = c("values__autocorrelation__lag_6", 
                       "0_Signal distance")) +
  theme(strip.text = element_text(size = 6))

