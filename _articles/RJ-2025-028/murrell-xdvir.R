# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit murrell-xdvir.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(warning = FALSE, message = FALSE)


## ----loadxdvir, include=FALSE-------------------------------------------------
library(xdvir)
options(xdvir.engine="xetex")


## ----pdf-graphics, echo=FALSE, eval=knitr::is_latex_output()------------------
knitr::opts_chunk$set(dev="cairo_pdf")


## ----html-graphics, echo=FALSE, eval=knitr::is_html_output()------------------
# knitr::opts_chunk$set(dev="png", dev.args=list(type="cairo-png"))


## ----echo=FALSE---------------------------------------------------------------
LaTeX <- ifelse(knitr::is_html_output(), 'LaTeX', '\\LaTeX{}')
TeX <- ifelse(knitr::is_html_output(), 'TeX', '\\TeX{}')
XeTeX <- ifelse(knitr::is_html_output(), 'XeTeX', '\\XeTeX{}')
LuaTeX <- ifelse(knitr::is_html_output(), 'LuaTeX', 'Lua\\TeX{}')
TikZ <- ifelse(knitr::is_html_output(), 'TikZ', 'Ti\\textit{k}Z')


## ----echo=FALSE---------------------------------------------------------------
## Parameter for plotting
## Set x variable for the fitness function 
x <- seq(-1, 7.5, by = .01)

## Math parameters for Fitness function 
s <- .5
m <- 1.5
t <- 1.7
u <- 3.4
div1 <- 2.4
div2 <- 3.5

## Set population parameters
## NB individuals, try with 10, and 1000 
n <- 1000 
## Get fake phenotypes
## Phenotypes for the population
pheno <- rnorm(n = n, mean = 3.2, sd = 0.5) 
## Make y height just for vizualisation purpose 
fit <- rnorm(length(pheno), mean = .12, sd =.01)


## Load functions ----------------------------------------------------------
## Mathematical fitness function (2 peaks )
## This is a speculative fitness function, you could design your own.
fit.function  <- function(x, s, m, t, u, div1 = 2, div2 = 2.5) {
    exp(-s^(-2)*(x-m)^(2))/div1+exp(-t^(-2)*(x-u)^(2))/div2
}

y <- fit.function(x = x,s = s, m = m,t = t,u = u, div1 = div1, div2 = div2)

main.plot <- function(mar = c(3, 3, .25, .25), col = 2) {
    ## Set parameter of plotting area 
    par(mar = mar)
    ## Plot fitness function 
    plot(y ~ x, 
         xlim = c(-0.5, 7),
         ylim = c(0, .7),
         axes=FALSE,
         type = "l", lwd = 5, col = col, 
         ylab = "Fitness", xlab = "Phenotypes")
    axis(1)
    axis(2, at=seq(0, .6, .2))
    box()
}

dens.xy <- density(x = pheno, n = 512, adjust = 2) # Adjust to make it smoother 

## Make a fake population 
add.fake.pop <-  function(x = dens.xy, y = fit,  alp = 1) {
    ## Line at the mean 
    ## abline(v = mean(x), lty = 3)
    ## Calculate the density of the population 
    ## Add density 
    lines(x = dens.xy$x, y = dens.xy$y/3, lty = 2)
}

drawPlot <- function() {
    par(family="TeX Gyre Adventor", mgp=c(2, .7, 0))
    main.plot()
    add.fake.pop(alp = .1)
}


## ----echo=FALSE---------------------------------------------------------------
annotationTeX <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the \textcolor{Rred}{\bf fitness function}.
\end{minipage})"


## ----typesetting, echo=FALSE, fig.width=7, fig.height=4.5, out.width="100%", fig.keep="last", fig.cap="A plot with a text annotation in the top-right corner that contains several typesetting challenges:  in-line mathematical expressions like $\\bar z_i$; changes in color so that the last two words match the colour of the thicker line in the plot; and automated line-breaks with full justification and hyphenation.", fig.alt="A line plot with two curves, the details of which do not really matter.  One line is thick and red, the other is dashed and black.  The important part is the annotation in the top-right corner of the plot, which is a paragraph of text that contains all of the typesetting features that are described in the main text."----

adventor <- fontspecPackage(font="TeX Gyre Adventor", name="adventor")

library(gggrid)

if (.Platform$OS.type == "windows") {
    TeXGyreR <- "TeXGyreAdventor"
} else {
    TeXGyreR <- "TeX Gyre Adventor"
}

ggIntro <- ggplot(data.frame(x, y)) +
    geom_line(aes(x, y), linewidth=2, colour=2) +
    geom_line(aes(x, y), data=data.frame(x=dens.xy$x, y=dens.xy$y/3),
              linetype="dashed") +
    xlab("Phenotypes") +
    ylab("Fitness") +
    theme_bw() +
    theme(text=element_text(family=TeXGyreR, size=12),
          panel.grid=element_blank())

label <- function(data, coords) {
    latexGrob(annotationTeX, packages=list(adventor, "xcolor"),
              x=max(coords$x), 
              y=max(coords$y),
              hjust="right", vjust="top", 
              gp=NULL)
}

ggIntro + 
    grid_panel(label, aes(x, y))


## -----------------------------------------------------------------------------
library(xdvir)


## ----fragment-----------------------------------------------------------------
simpleTeX <- r"(We move the original mean to $\bar z_i$)"


## ----rect, eval=FALSE, echo=FALSE---------------------------------------------
# grid.rect()

## ----gridlatex, eval=FALSE----------------------------------------------------
# grid.latex(simpleTeX)

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.latex(simpleTeX)


## -----------------------------------------------------------------------------
plotmath <- expression("We move the original mean to "*bar(italic(z))[i])

## ----plotmathexpr, eval=FALSE-------------------------------------------------
# grid.text(plotmath)

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.text(plotmath)


## ----width, eval=FALSE--------------------------------------------------------
# grid.latex(simpleTeX, width=.5)

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.latex(simpleTeX, width=.5)


## -----------------------------------------------------------------------------
library(ggplot2)


## ----elementlatex, fig.width=7, fig.height=4.5, out.width="100%", fig.cap='(ref:elementlatexFigCap)', fig.alt="This is a line plot with the same two lines as in Figure 1, but without the text annotation in the top-right corner.  Instead, there is a plot title that is rendered from a LaTeX fragment containing a mathematical expression."----
ggIntro +
    labs(title=simpleTeX) +
    theme(plot.title=element_latex())


## ----tikzmu, echo=FALSE-------------------------------------------------------
muDot <- r"(%
\begin{tikzpicture}
\node[draw,circle,thick,inner sep=0.5mm]{\vphantom{M}$\mu$};
\end{tikzpicture})"

## ----echo=FALSE---------------------------------------------------------------
samples <- data.frame(x=rnorm(50), sample=rep(1:5, each=10))
means <- aggregate(samples$x, list(sample=samples$sample), mean)
means$label <- paste0("$\\bar x_", means$sample, "$")


## -----------------------------------------------------------------------------
means$label


## ----echo=FALSE, message=FALSE------------------------------------------------
ggGeom <- ggplot(samples) +
    geom_vline(xintercept=0, linetype="solid", colour=1, linewidth=.5) +
    geom_point(aes(x, sample), colour="grey", size=4, alpha=.5) +
    xlab(NULL) +
    scale_x_continuous(breaks=0, labels=muDot) +
    scale_y_continuous(breaks=1:5, expand=expansion(.25)) +
    theme_minimal() +
    theme(axis.text.x=element_latex(size=16, packages="tikz", 
                                    margin=margin(-3, 0, 0, 0)),
          axis.ticks.x=element_blank(),
          axis.title.y=element_text(colour="grey"),
          axis.text.y=element_text(colour="grey"),
          panel.grid.major.x=element_blank(),
          panel.grid.minor.x=element_blank(),
          panel.grid.minor.y=element_blank())


## ----geomlatex, fig.width=7, fig.height=3.5, out.width="100%", fig.cap='(ref:geomlatexFigCap)', fig.alt="A scatterplot with five rows of grey dots, where each row of dots represents a random sample of values from a population.  In addition, there is a red dot on each row that represents the mean value for each sample, plus a red label above each red dot that is based on a simple LaTeX mathematical expression."----
ggGeom +
    geom_point(aes(x, sample), data=means, colour=2, size=4) +
    geom_latex(aes(x, sample, label=label), data=means, 
               size=6, vjust=-.4, colour=2)    


## -----------------------------------------------------------------------------
simpleTeX


## -----------------------------------------------------------------------------
simpleDoc <- author(simpleTeX)

## ----eval=FALSE---------------------------------------------------------------
# simpleDoc

## ----echo=FALSE---------------------------------------------------------------
output <- substring(capture.output(simpleDoc), 1, 84)
cat(output, sep="\n")


## ----typeset, echo=FALSE------------------------------------------------------
simpleDVI <- typeset(simpleDoc)

## ----dvi, echo=FALSE, eval=FALSE----------------------------------------------
# simpleDVI

## ----eval=FALSE---------------------------------------------------------------
# simpleDVI <- typeset(simpleDoc)
# simpleDVI

## ----echo=FALSE---------------------------------------------------------------
output <- substring(capture.output(simpleDVI), 1, 84)
firstDown <- grep("^down", output)[1]
firstDef <- grep("^x_fnt_def", output)[1]
firstGlyph <- grep("^x_glyph", output)[1]
cat(c(output[1:firstDown], 
      "\n...\n",
      output[(firstDef - 1):(firstGlyph + 3)],
      "\n...\n"), sep="\n")


## ----simpledvi, eval=FALSE----------------------------------------------------
# render(simpleDVI)

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
render(simpleDVI)


## -----------------------------------------------------------------------------
colourTeX <- r"(We combine to get the \textcolor{red}{Fitness Function})"


## ----colourtex, eval=FALSE----------------------------------------------------
# grid.latex(colourTeX, packages="xcolor")

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.latex(colourTeX, packages="xcolor")


## -----------------------------------------------------------------------------
colourDoc <- author(colourTeX, packages="xcolor")

## ----eval=FALSE---------------------------------------------------------------
# colourDoc

## ----echo=FALSE---------------------------------------------------------------
output <- substring(capture.output(colourDoc), 1, 84)
cat(output, sep="\n")


## ----colortypeset, echo=FALSE-------------------------------------------------
colourDVI <- typeset(colourDoc)

## ----colordvi, echo=FALSE, eval=FALSE-----------------------------------------
# colourDVI

## ----eval=FALSE---------------------------------------------------------------
# colourDVI <- typeset(colourDoc)
# colourDVI

## ----echo=FALSE---------------------------------------------------------------
output <- substring(capture.output(colourDVI), 1, 84)
firstDef <- grep("^x_fnt_def", output)[1]
firstRGB <- grep("rgb", output)[1]
cat(c(output[1:3], 
      "\n...\n",
      output[firstDef:(firstDef + 4)],
      "\n...\n",
      output[(firstRGB - 1):(firstRGB + 2)],
      "\n...\n"),
    sep="\n")


## ----colourdvi, eval=FALSE----------------------------------------------------
# render(colourDVI, packages="xcolor")

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
render(colourDVI, packages="xcolor")


## ----horiz, echo=FALSE, eval=FALSE--------------------------------------------
# grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))

## ----justcentre, eval=FALSE---------------------------------------------------
# grid.latex(simpleTeX, y=.5)

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
grid.latex(simpleTeX, y=.5)


## ----justbottom, eval=FALSE---------------------------------------------------
# grid.latex(simpleTeX, y=.5, vjust="bottom")


## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
grid.latex(simpleTeX, y=.5, vjust="bottom")


## ----justbaseline, eval=FALSE-------------------------------------------------
# grid.latex(simpleTeX, y=.5, vjust="baseline")

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
grid.latex(simpleTeX, y=.5, vjust="baseline")


## -----------------------------------------------------------------------------
rightBearingTeX <- paste0(simpleTeX, "$|$")

## ----justright, eval=FALSE----------------------------------------------------
# ggIntro +
#     labs(title=rightBearingTeX) +
#     theme(plot.title=element_latex(size=20, hjust="right"))

## ----echo=FALSE, fig.width=7, fig.height=1, out.width="95%"-------------------
pushViewport(viewport(height=100, y=1, just="top"))
gg1 <- 
ggIntro + 
    labs(title=rightBearingTeX) +
    theme(plot.title=element_latex(size=20, hjust="right"))
print(gg1, newpage=FALSE)

## ----justbbright, eval=FALSE--------------------------------------------------
# ggIntro +
#     labs(title=rightBearingTeX) +
#     theme(plot.title=element_latex(size=20, hjust="bbright"))

## ----echo=FALSE, fig.width=7, fig.height=1, out.width="95%"-------------------
pushViewport(viewport(height=100, y=1, just="top"))
gg2 <- 
ggIntro + 
    labs(title=rightBearingTeX) +
    theme(plot.title=element_latex(size=20, hjust="bbright"))
print(gg2, newpage=FALSE)


## -----------------------------------------------------------------------------
zrefTeX <- r"(We move the original\zsavepos{a} mean to \zsavepos{b}$\bar z_i$
\Rzmark{a}\Rzmark{b})"


## ----zreftex, eval=FALSE------------------------------------------------------
# grid.latex(zrefTeX, packages="zref")


## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.latex(zrefTeX, packages="zref")


## ----geta, eval=FALSE---------------------------------------------------------
# a <- getMark("a")
# grid.circle(a$devx, a$devy, r=unit(.5, "mm"), gp=gpar(col=2, fill=2))


## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.latex(zrefTeX, packages="zref")
a <- getMark("a")
grid.circle(a$devx, a$devy, r=unit(.5, "mm"), gp=gpar(col=2, fill=2))


## ----getb, eval=FALSE---------------------------------------------------------
# b <- getMark("b")
# grid.xspline(unit.c(a$devx, .5*(a$devx + b$devx), b$devx),
#              unit.c(a$devy, a$devy - unit(3, "mm"), a$devy),
#              shape=-1, gp=gpar(col=2, fill=2),
#              arrow=arrow(length=unit(2, "mm"), type="closed"))


## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.latex(zrefTeX, packages="zref")
a <- getMark("a")
grid.circle(a$devx, a$devy, r=unit(.5, "mm"), gp=gpar(col=2, fill=2))
b <- getMark("b")
grid.xspline(unit.c(a$devx, .5*(a$devx + b$devx), b$devx),
             unit.c(a$devy, a$devy - unit(3, "mm"), a$devy),
             shape=-1, gp=gpar(col=2, fill=2),
             arrow=arrow(length=unit(2, "mm"), type="closed"))


## ----justanchor, eval=FALSE---------------------------------------------------
# grid.latex(zrefTeX, packages="zref", hjust="a", vjust="a")

## ----vert, echo=FALSE, eval=FALSE---------------------------------------------
# grid.segments(.5, 0, .5, 1, gp=gpar(col="grey"))

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
grid.segments(.5, 0, .5, 1, gp=gpar(col="grey"))
grid.latex(zrefTeX, packages="zref", hjust="a", vjust="a")


## ----echo=FALSE---------------------------------------------------------------
markStr <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the 
\textcolor{Rred}{\bf \zsavepos{left}fitness function\zsavepos{right}}.
\Rzmark{left}\Rzmark{right}
\end{minipage})"


## ----zref, echo=FALSE, fig.width=7, fig.height=4.5, out.width="100%", fig.cap='(ref:zrefFigCap)', fig.alt="A line plot with two curves as in Figure 1.  The annotation is in the top-left corner as in Figure 1 and there is an additional red line from the thick red line in the plot to the last two words in the annotation, which are also red."----
markTeX <- function(data, coords) {
    latexGrob(markStr, packages=list(adventor, "xcolor", "zref"),
              x=max(coords$x), 
              y=max(coords$y),
              hjust="right", vjust="top", 
              gp=NULL)
}

makeContent.markCurve <- function(x) {
    ## Delay this calculation until drawing time so that we
    ## are in the correct viewport
    devLoc <- deviceLoc(x$x, x$y)
    addMark("curve", devLoc$x, devLoc$y)
    x
}

markCurve <- function(data, coords) {
    gTree(x=unit(coords$x[data$x == 4], "npc"),
          y=unit(coords$y[data$x == 4], "npc"),
          cl="markCurve")
}

ggIntro + 
    grid_panel(markTeX, aes(x, y)) +
    grid_panel(markCurve, aes(x, y))

left <- getMark("left")
right <- getMark("right")
curve <- getMark("curve")

grid.lines(unit.c(curve$devx, left$devx, right$devx),
           unit.c(curve$devy, left$devy - unit(1, "mm"),
                  right$devy - unit(1, "mm")),
           gp=gpar(col=2))


## ----tikztex------------------------------------------------------------------
tikzTeX <- r"(%
\path (0, 0) node[circle,minimum size=.5in,draw,thick] (x) {\sffamily{R}} 
       (3, 0) node[circle,minimum size=.5in,draw,thick] (y) {Ti\textit{k}Z!};
\draw[-{stealth},thick] (x) .. controls (1, 1) and (2, 1).. (y);
\draw[-{stealth},thick] (y) .. controls (2, -1) and (1, -1) .. (x);)"


## ----tikzpicture, eval=FALSE--------------------------------------------------
# grid.latex(tikzTeX, packages="tikzPicture")

## ----echo=FALSE, fig.width=3, fig.height=1, out.width="40%"-------------------
grid.rect()
grid.latex(tikzTeX, packages="tikzPicture")


## -----------------------------------------------------------------------------
muDot <- r"(%
\begin{tikzpicture}
\node[draw,circle,thick,inner sep=0.5mm]{\vphantom{M}$\mu$};
\end{tikzpicture})"


## ----tikz, eval=FALSE---------------------------------------------------------
# grid.latex(muDot, packages="tikz")

## ----echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"------------------
grid.rect()
grid.latex(muDot, packages="tikz")


## -----------------------------------------------------------------------------
paste0("$\\bar x_", 1:5, "$")


## ----diag, echo=FALSE, fig.width=8, fig.height=3, out.width="100%", fig.cap="The design of the `xdvir` package.", fig.alt='A diagram showing the structure of the xdvir package.  Starting from a box labelled "LaTeX fragment" on the left, wecan follow an arrow to the right labelled "author()" to a box labelled "LaTeXdocument object".  From there we can follow an arrow to the right labelled "typeset()" to a box labelled "DVI object".  From there we can follow an arrow to the right labelled "render()" to a box labelled "rendered glyphs".  Alternatively, we can start at the left with the box labelled "LaTeX fragment" and follow an arrow labelled "grid.latex()" that curves up and over to the right in one step to the box labelled "rendered glyphs".  All of those boxes and arrows are within a grey rectangle labelled "R".  There are also two boxes below, outside the grey rectangle labelled "LateX document" and "DVI file" with an arrow labelled "xelatex" from left to right between them.  We can follow an arrow up from "LaTeX document" into the grey rectangle to the box labelled "LaTeXdocument object" and an arrow up from "DVI file" into the grey rectangle labelled "DVI object".'----
diagTeX <- readLines("diagram/diag.tex")
## Have to add the {xdvir} pgfsys-driver
diagTeX <- c(diagTeX[1], 
             paste0("\\def\\pgfsysdriver{'",
                    system.file("tikz", "pgfsys-xdvir.def",
                                package="xdvir"),
                    "'}"),
             diagTeX[-1])
diagDVI <- typeset(diagTeX)
## Have to load the TikZ package
grid.newpage()
grid.dvi(diagDVI, packages="tikz")


## ----echo=FALSE---------------------------------------------------------------
source("scripts/rahlf-plot.R")

## ----rahlfplot, echo=FALSE, eval=FALSE----------------------------------------
# rahlfPlot()


## ----gridgraphics, echo=FALSE, eval=FALSE-------------------------------------
# library(gridGraphics)
# grid.echo()


## ----downvp, echo=FALSE, eval=FALSE-------------------------------------------
# downViewport("graphics-window-1-1")


## ----echo=FALSE---------------------------------------------------------------
rahlfTeX <- paste(readLines("TeX/rahlf.tex"), collapse="\n")


## ----multicol, echo=FALSE, eval=FALSE-----------------------------------------
# multicol <- LaTeXpackage("multicol",
#                          preamble="\\usepackage{multicol}")
# registerPackage(multicol)


## ----rahlflatex, echo=FALSE, eval=FALSE---------------------------------------
# grid.latex(rahlfTeX,
#            packages=c("fontspec", "multicol"),
#            x=unit(1, "cm"), y=unit(14000, "native"),
#            hjust="left", vjust="top")


## ----rahlf, echo=FALSE, fig.width=12, fig.height=9, out.width="100%", fig.cap='(ref:rahlfFigCap)', fig.keep="last", fig.alt="A line plot showing GDP of Chile increasing over time.  The important feature is an annotation in the top-left corner of the plot that consists of two fully-justified columns of text, which was produced from a fragment of LaTeX code."----
rahlfPlot()
library(gridGraphics)
grid.echo()
downViewport("graphics-window-1-1")
multicol <- LaTeXpackage("multicol",
                         preamble="\\usepackage{multicol}")
registerPackage(multicol)
grid.latex(rahlfTeX, 
           packages=c("fontspec", "multicol"),
           x=unit(1, "cm"), y=unit(14000, "native"), 
           hjust="left", vjust="top")


## ----eval=FALSE---------------------------------------------------------------
# rahlfPlot()


## ----rahlfplain, echo=FALSE, fig.width=12, fig.height=9, out.width="100%", fig.cap='(ref:rahlfplainFigCap)'----
rahlfPlot()


## ----eval=FALSE---------------------------------------------------------------
# library(gridGraphics)
# grid.echo()


## ----eval=FALSE---------------------------------------------------------------
# downViewport("graphics-window-1-1")


## ----echo=FALSE---------------------------------------------------------------
cat(rahlfTeX)


## ----eval=FALSE---------------------------------------------------------------
# multicol <- LaTeXpackage("multicol",
#                          preamble="\\usepackage{multicol}")
# registerPackage(multicol)


## ----eval=FALSE---------------------------------------------------------------
# grid.latex(rahlfTeX,
#            packages=c("fontspec", "multicol"),
#            x=unit(1, "cm"), y=unit(14000, "native"),
#            hjust="left", vjust="top")


## ----echo=FALSE---------------------------------------------------------------
source("scripts/schneider.R")

## ----schneiderplot, echo=FALSE, eval=FALSE------------------------------------
# ggSchneider


## ----echo=FALSE---------------------------------------------------------------
schneiderLines <- readLines("TeX/schneider.tex")
schneiderTeX <- paste(schneiderLines, collapse="\n")


## ----annotateequations, echo=FALSE, eval=FALSE--------------------------------
# annotateEquations <-
#     LaTeXpackage(name="annotate",
#                  preamble="\\usepackage{TeX/annotate-equations}")
# registerPackage(annotateEquations)


## ----tikznobbox, echo=FALSE, eval=FALSE---------------------------------------
# tikzNoBBox <-
#     tikzPackage(name="tikzNoBBox", bbox=FALSE)
# registerPackage(tikzNoBBox)


## ----roboto, echo=FALSE, eval=FALSE-------------------------------------------
# roboto <-
#     LaTeXpackage(name="roboto",
#                  preamble="\\usepackage[sfdefault,condensed]{roboto}")
# registerPackage(roboto)


## ----anneq, echo=FALSE, eval=FALSE--------------------------------------------
# library(gggrid)
# 
# annotation <- function(data, coords) {
#     latexGrob(schneiderTeX,
#               packages=c("tikzNoBBox", "annotate", "roboto", "xcolor"),
#               x=unit(coords$x, "npc") + 0.5*stringWidth("160"),
#               y=coords$y, hjust=1, vjust=1)
# }
# 
# ggSchneider +
#     grid_panel(annotation,
#                aes(x=x, y=y),
#                data=data.frame(x=160, y=dnorm(100, mean=100, sd=15)))


## ----schneider, echo=FALSE, out.width="100%", fig.cap='(ref:schneiderFigCap)', fig.alt="A Normal density curve plot.  The important feature is an annotation iin the top-right corner of the plot that consists of an annotated mathematical equation, which was produced from a fragment of LaTeX code."----
annotateEquations <-
    LaTeXpackage(name="annotate",
                 preamble="\\usepackage{TeX/annotate-equations}")
registerPackage(annotateEquations)
tikzNoBBox <-
    tikzPackage(name="tikzNoBBox", bbox=FALSE)
registerPackage(tikzNoBBox)
roboto <-
    LaTeXpackage(name="roboto",
                 preamble="\\usepackage[sfdefault,condensed]{roboto}")
registerPackage(roboto)
library(gggrid)

annotation <- function(data, coords) {
    latexGrob(schneiderTeX, 
              packages=c("tikzNoBBox", "annotate", "roboto", "xcolor"),
              x=unit(coords$x, "npc") + 0.5*stringWidth("160"),
              y=coords$y, hjust=1, vjust=1)
}

ggSchneider +
    grid_panel(annotation, 
               aes(x=x, y=y), 
               data=data.frame(x=160, y=dnorm(100, mean=100, sd=15)))


## ----eval=FALSE---------------------------------------------------------------
# ggSchneider


## ----schneiderplain, echo=FALSE, out.width="100%", fig.cap='(ref:schneiderplainFigCap)'----
ggSchneider


## ----echo=FALSE---------------------------------------------------------------
ann2 <- grep("[\\]annotate", schneiderLines)[2]
cat(schneiderLines[1:(ann2 - 1)], sep="\n")


## ----eval=FALSE---------------------------------------------------------------
# annotateEquations <-
#     LaTeXpackage(name="annotate",
#                  preamble="\\usepackage{TeX/annotate-equations}")
# registerPackage(annotateEquations)


## ----eval=FALSE---------------------------------------------------------------
# tikzNoBBox <-
#     tikzPackage(name="tikzNoBBox", bbox=FALSE)
# registerPackage(tikzNoBBox)


## ----eval=FALSE---------------------------------------------------------------
# roboto <-
#     LaTeXpackage(name="roboto",
#                  preamble="\\usepackage[sfdefault,condensed]{roboto}")
# registerPackage(roboto)


## ----eval=FALSE---------------------------------------------------------------
# library(gggrid)
# 
# annotation <- function(data, coords) {
#     latexGrob(schneiderTeX,
#               packages=c("tikzNoBBox", "annotate", "roboto", "xcolor"),
#               x=unit(coords$x, "npc") + 0.5*stringWidth("160"),
#               y=coords$y, hjust=1, vjust=1)
# }
# 
# ggSchneider +
#     grid_panel(annotation,
#                aes(x=x, y=y),
#                data=data.frame(x=160, y=dnorm(100, mean=100, sd=15)))


## ----echo=FALSE---------------------------------------------------------------
source("scripts/anzjs.R")


## ----anzjsplot, echo=FALSE, eval=FALSE----------------------------------------
# ggANZJS


## ----echo=FALSE---------------------------------------------------------------
closeTeX <- r"(%
\fontsize{10}{12}
\selectfont
\begin{enumerate}
\item New Zealand closes its borders to \textit{almost} all travellers at
\textbf{23:59, 19 March 2020 (NZDT)}.
\end{enumerate})"


## ----labelLeft, echo=FALSE, eval=FALSE----------------------------------------
# labelLeft <- function(data, coords) {
#     x1 <- coords$x[1]
#     x2 <- coords$x[2]
#     w <- unit(1 - x2, "npc") - unit(1, "mm")
#     gap <- 15
#     latex1 <- latexGrob(closeTeX,
#                         x=unit(x1, "npc") - unit(2, "mm"),
#                         y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
#                         hjust=1, vjust=1,
#                         width=w)
# }


## ----labelRight, echo=FALSE, eval=FALSE---------------------------------------
# labelRight <- function(data, coords) {
#     x1 <- coords$x[1]
#     x2 <- coords$x[2]
#     w <- unit(1 - x2, "npc") - unit(1, "mm")
#     gap <- 15
#     latex1 <- latexGrob(closeTeX,
#                         x=unit(x1, "npc") - unit(2, "mm"),
#                         y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
#                         hjust=1, vjust=1,
#                         width=w)
#     openTeX <- r"(%
# \fontsize{10}{12}
# \selectfont
# \begin{enumerate}\addtocounter{enumi}{1}
# \item New Zealand's international border opens to all visitors from
# \textbf{11:59PM, 31 July 2022 (NZDT)}.
# \end{enumerate})"
#     latex2 <- latexGrob(openTeX,
#                         x=unit(x2, "npc") + unit(2, "mm"),
#                         y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
#                         hjust=0, vjust=1,
#                         width=w)
#     latex2
# }

## ----ggenumlist, echo=FALSE, eval=FALSE---------------------------------------
# ggANZJS +
#     grid_panel(labelLeft,
#                aes(x=borders),
#                data=data.frame(borders=c(borderClosed, borderOpen))) +
#     grid_panel(labelRight,
#                aes(x=borders),
#                data=data.frame(borders=c(borderClosed, borderOpen)))


## ----anzjs, echo=FALSE, fig.width=8, fig.height=4.5, out.width="100%", fig.cap='(ref:anzjsFigCap)', fig.alt="A line plot of the traffic at Auckland airport, covering the period of the COVID pandemic.  The important features are two annotations below the plot, at the start and end of the border closures in New Zealand.  Each annotation is a numbered list item produced from a fragment of LaTeX code."----
labelLeft <- function(data, coords) {
    x1 <- coords$x[1]
    x2 <- coords$x[2]
    w <- unit(1 - x2, "npc") - unit(1, "mm")
    gap <- 15
    latex1 <- latexGrob(closeTeX,
                        x=unit(x1, "npc") - unit(2, "mm"), 
                        y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
                        hjust=1, vjust=1,
                        width=w)
}
labelRight <- function(data, coords) {
    x1 <- coords$x[1]
    x2 <- coords$x[2]
    w <- unit(1 - x2, "npc") - unit(1, "mm")
    gap <- 15
    latex1 <- latexGrob(closeTeX,
                        x=unit(x1, "npc") - unit(2, "mm"), 
                        y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
                        hjust=1, vjust=1,
                        width=w)
    openTeX <- r"(%
\fontsize{10}{12}
\selectfont
\begin{enumerate}\addtocounter{enumi}{1}
\item New Zealand's international border opens to all visitors from
\textbf{11:59PM, 31 July 2022 (NZDT)}.
\end{enumerate})"
    latex2 <- latexGrob(openTeX,
                        x=unit(x2, "npc") + unit(2, "mm"),
                        y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"), 
                        hjust=0, vjust=1,
                        width=w)
    latex2
}
ggANZJS +
    grid_panel(labelLeft,
               aes(x=borders),
               data=data.frame(borders=c(borderClosed, borderOpen))) +
    grid_panel(labelRight,
               aes(x=borders),
               data=data.frame(borders=c(borderClosed, borderOpen)))


## ----eval=FALSE---------------------------------------------------------------
# ggANZJS


## ----anzjsplain, echo=FALSE, fig.width=8, fig.height=4.5, out.width="100%", fig.cap='(ref:anzjsplainFigCap)'----
ggANZJS


## ----echo=FALSE---------------------------------------------------------------
cat(closeTeX)


## ----eval=FALSE---------------------------------------------------------------
# labelLeft <- function(data, coords) {
#     x1 <- coords$x[1]
#     x2 <- coords$x[2]
#     w <- unit(1 - x2, "npc") - unit(1, "mm")
#     gap <- 15
#     latex1 <- latexGrob(closeTeX,
#                         x=unit(x1, "npc") - unit(2, "mm"),
#                         y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
#                         hjust=1, vjust=1,
#                         width=w)
# }


## ----eval=FALSE---------------------------------------------------------------
# ggANZJS +
#     grid_panel(labelLeft,
#                aes(x=borders),
#                data=data.frame(borders=c(borderClosed, borderOpen))) +
#     grid_panel(labelRight,
#                aes(x=borders),
#                data=data.frame(borders=c(borderClosed, borderOpen)))


## ----latticesetup, echo=FALSE-------------------------------------------------
crime <- read.csv("data/youth-crime.csv")
crime$Month <- as.Date(crime$Month)
monthFirst <- subset(crime, Month == "2014-07-01" & Sex == "Male")
monthLevels <- monthFirst$Type[order(monthFirst$Count, decreasing=TRUE)]
monthLabels <- unlist(lapply(strwrap(monthLevels, width=30, simplify=FALSE),
                             function(x) {
                                 if (length(x) < 3)
                                     x <- c(x, rep(" ", 3 - length(x)))
                                 paste(x, collapse="\n")
                             }))
crime$Type <- factor(crime$Type, levels=monthLevels)
library(lattice)
darkGrey <- grey(.1)
lightGrey <- grey(.5)
cols <- trellis.par.get("superpose.symbol")$col[1:2]
cols[1] <- colorspace::lighten(cols[1], amount=.4)
cols[2] <- colorspace::darken(cols[2], amount=.2)
trellis.par.set(theme=list(background=list(col=darkGrey),
                           layout.heights=list(top.padding=4),
                           axis.text=list(col=lightGrey, cex=2/3),
                           axis.line=list(col=NA)))
mainPanel <- function(x, y, subscripts, groups, ...) {
    panel.superpose(x, y, subscripts, groups, 
                    col=rev(cols),
                    ...)
    panel.abline(h=0, col=lightGrey)
}
latticeCrime <- xyplot(Count ~ Month | Type, crime, groups=Sex, type="l",
       as.table=TRUE, strip=FALSE, xlab="", ylab="",
       scales=list(alternating=FALSE, axs="i",
                   y=list(limits=c(0, 1500), at=seq(0, 900, 300))),
       between=list(x=1),
       panel=mainPanel)

## ----adjustYticks, echo=FALSE, eval=FALSE-------------------------------------
# grid.edit("ticklabels.left", grep=TRUE, global=TRUE, just=c("right", "bottom"))


## ----echo=FALSE, eval=FALSE---------------------------------------------------
# ## Colours come from ...
# ## col2rgb(cols)


## ----latticetitletex, echo=FALSE----------------------------------------------
titleTeX <- r"(%
\definecolor{lightGrey}{RGB}{128,128,128}
\definecolor{lattice1}{RGB}{105,169,234}
\definecolor{lattice2}{RGB}{181,124,1}
\color{lightGrey}
Number of Incidents for \textcolor{lattice1}{Males} and 
\textcolor{lattice2}{Females}
)"


## ----latticepanel, echo=FALSE-------------------------------------------------
latexPanel <- function(x, y, subscripts, groups, ...) {
    type <- crime$Type[subscripts][1]
    labelY <- y[groups == "Male"][1]
    labelWidth <- convertWidth(unit(1, "npc"), "in", valueOnly=TRUE)
    panelTeX <- paste0("\\begin{minipage}{", labelWidth, "in}",
                       type, 
                       "\\end{minipage}")
    grid.latex(panelTeX, 
               x=0, hjust="left",
               y=unit(labelY, "native") + unit(4, "mm"), vjust="bottom",
               gp=gpar(col=lightGrey, fontsize=8))
    mainPanel(x, y, subscripts, groups, ...)
}


## ----titleX, echo=FALSE-------------------------------------------------------
titleX <- unit(ifelse(knitr::is_html_output(), 0.673, 0.653), "in")


## ----titlegrob, echo=FALSE----------------------------------------------------
latexTitle <- latexGrob(titleTeX, x=titleX, hjust="left", 
                        packages="xcolor")


## ----echo=FALSE, eval=FALSE---------------------------------------------------
# ## latexGrob(x) comes from ...
# ## downViewport("plot_01.toplevel.vp")
# ## convertWidth(sum(current.viewport()$layout$widths[1:6]), "in")


## ----latticefinal, echo=FALSE, eval=FALSE-------------------------------------
# update(latticeCrime,
#        panel=latexPanel,
#        main=latexTitle)


## ----lattice, echo=FALSE, fig.width=7, fig.height=7, fig.keep="last", out.width="100%", fig.cap='(ref:latticeFigCap)', fig.alt="A mulit-panel/facetted line plot showing crime statistics over time, with separate lines for males and females and a separate panel for each type of crime.  The important features are the labels in each panel that describe the type of crime, which are fully-justified to the widths of the panels and are based on fragments of LaTeX code.  The plot title is also based on a LaTeX fragment that colours the word Male the same blue as the lines representing males in each panel and the word Female the same yellow as the lines representing females in each panel."----
update(latticeCrime,
       panel=latexPanel,
       main=latexTitle)
grid.edit("ticklabels.left", grep=TRUE, global=TRUE, just=c("right", "bottom"))


## ----eval=FALSE---------------------------------------------------------------
# latticeCrime


## ----latticeplain, echo=FALSE, fig.width=7, fig.height=7, fig.keep="last", out.width="100%", fig.cap='(ref:latticeplainFigCap)'----
latticeCrime
grid.edit("ticklabels.left", grep=TRUE, global=TRUE, just=c("right", "bottom"))


## ----eval=FALSE---------------------------------------------------------------
# latexPanel <- function(x, y, subscripts, groups, ...) {
#     type <- crime$Type[subscripts][1]
#     labelY <- y[groups == "Male"][1]
#     labelWidth <- convertWidth(unit(1, "npc"), "in", valueOnly=TRUE)
#     panelTeX <- paste0("\\begin{minipage}{", labelWidth, "in}",
#                        type,
#                        "\\end{minipage}")
#     grid.latex(panelTeX,
#                x=0, hjust="left",
#                y=unit(labelY, "native") + unit(4, "mm"), vjust="bottom",
#                gp=gpar(col=lightGrey, fontsize=8))
#     mainPanel(x, y, subscripts, groups, ...)
# }


## ----eval=FALSE---------------------------------------------------------------
# titleTeX <- r"(%
# \definecolor{lightGrey}{RGB}{128,128,128}
# \definecolor{lattice1}{RGB}{105,169,234}
# \definecolor{lattice2}{RGB}{181,124,1}
# \color{lightGrey}
# Number of Incidents for \textcolor{lattice1}{Males} and
# \textcolor{lattice2}{Females}
# )"


## ----eval=FALSE---------------------------------------------------------------
# latexTitle <- latexGrob(titleTeX, x=titleX, hjust="left",
#                         packages="xcolor")


## ----eval=FALSE---------------------------------------------------------------
# update(latticeCrime,
#        panel=latexPanel,
#        main=latexTitle)


## ----trellisundo, echo=FALSE--------------------------------------------------
trellis.par.set(theme=list(background=list(col="white"),
                           axis.text=list(col="black", cex=.8),
                           axis.line=list(col="black")))

