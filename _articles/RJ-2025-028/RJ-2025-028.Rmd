---
title: Rendering LaTeX in R
date: '2025-10-22'
abstract: |
  The xdvir package provides functions for rendering  LaTeX fragments as labels, annotations, and data symbols in R plots.  There are convenient high-level functions for rendering LaTeX fragments, including labels on ggplot2 plots, plus lower-level functions for more fine control over the separate authoring, typesetting, and rendering steps. There is support for making use of LaTeX packages, including TikZ graphics.  The rendered LaTeX output is fully integrated with R graphics output in the sense that LaTeX output  can be positioned and sized relative to R graphics output and vice versa.
draft: no
author:
- name: Paul Murrell
  affiliation: The University of Auckland
  address:
  - Department of Statistics
  - Auckland, New Zealand
  email: paul@stat.auckland.ac.nz
  url: https://www.stat.auckland.ac.nz/~paul/
  orcid: 0000-0002-3224-8858
type: package
output:
  rjtools::rjournal_pdf_article:
    toc: no
    keep_tex: yes
  rjtools::rjournal_web_article:
    self_contained: no
    toc: no
header-includes: \usepackage{metalogo}
bibliography: murrell-xdvir.bib
date_received: '2025-03-03'
volume: 17
issue: 3
slug: RJ-2025-028
journal:
  lastpage: 187
  firstpage: 162

---


```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r loadxdvir, include=FALSE}
library(xdvir)
options(xdvir.engine="xetex")

```{r pdf-graphics, echo=FALSE, eval=knitr::is_latex_output()}
knitr::opts_chunk$set(dev="cairo_pdf")
```

```{r html-graphics, echo=FALSE, eval=knitr::is_html_output()}
knitr::opts_chunk$set(dev="png", dev.args=list(type="cairo-png"))
```

```{r echo=FALSE}
LaTeX <- ifelse(knitr::is_html_output(), 'LaTeX', '\\LaTeX{}')
TeX <- ifelse(knitr::is_html_output(), 'TeX', '\\TeX{}')
XeTeX <- ifelse(knitr::is_html_output(), 'XeTeX', '\\XeTeX{}')
LuaTeX <- ifelse(knitr::is_html_output(), 'LuaTeX', 'Lua\\TeX{}')
TikZ <- ifelse(knitr::is_html_output(), 'TikZ', 'Ti\\textit{k}Z')
```

# Introduction

Text labels, titles, and annotations are essential components of 
any data visualization.  Viewers focus a lot of their attention
on text [@massvis], 
text is the most effective way to communicate some types of 
information [@hearst],
and the message obtained from a data visualization can be
heavily influenced by the text on a plot [@kong].

R provides relatively flexible tools for adding text labels to plots.
For example, in the `graphics` package, we can specify an
overall plot title and axis titles via the `main`,
`xlab`, and `ylab` arguments to the `plot()` function
and we can add text at arbitrary locations on the plot with the `text()` 
and `mtext()` functions.

Unfortunately, these core tools for drawing text are quite limited
in terms of the formatting of the text.
For example, there is no facility for emphasizing an individual word using
a **bold** or *italic* face within a text label.

The \CRANpkg{ggtext} [@pkg-ggtext] and \CRANpkg{gridtext} [@pkg-gridtext] 
packages greatly improved the situation by allowing text labels
to include a small subset of
markdown and HTML (plus CSS).  This allowed, for example, changes in font face
and color within text labels.

More recently, the \CRANpkg{marquee} package [@pkg-marquee]
improved the situation a great deal further by providing full support for
markdown within text labels.  This made it possible to lay out more
complex arrangements of text and even graphical content within text labels.

However, despite these advances, there are still some text formatting tasks that
remain out of reach.  For example, Figure \@ref(fig:typesetting) 
shows a plot with a text annotation in the top-right corner that contains
a combination of features that cannot be produced using the 
available text-drawing tools.

```{r echo=FALSE}
## Parameter for plotting
## Set x variable for the fitness function 
x <- seq(-1, 7.5, by = .01)

## Math parameters for Fitness function 
s <- .5
m <- 1.5
t <- 1.7
u <- 3.4
div1 <- 2.4
div2 <- 3.5

## Set population parameters
## NB individuals, try with 10, and 1000 
n <- 1000 
## Get fake phenotypes
## Phenotypes for the population
pheno <- rnorm(n = n, mean = 3.2, sd = 0.5) 
## Make y height just for vizualisation purpose 
fit <- rnorm(length(pheno), mean = .12, sd =.01)

## Load functions ----------------------------------------------------------
## Mathematical fitness function (2 peaks )
## This is a speculative fitness function, you could design your own.
fit.function  <- function(x, s, m, t, u, div1 = 2, div2 = 2.5) {
    exp(-s^(-2)*(x-m)^(2))/div1+exp(-t^(-2)*(x-u)^(2))/div2
}

y <- fit.function(x = x,s = s, m = m,t = t,u = u, div1 = div1, div2 = div2)

main.plot <- function(mar = c(3, 3, .25, .25), col = 2) {
    ## Set parameter of plotting area 
    par(mar = mar)
    ## Plot fitness function 
    plot(y ~ x, 
         xlim = c(-0.5, 7),
         ylim = c(0, .7),
         axes=FALSE,
         type = "l", lwd = 5, col = col, 
         ylab = "Fitness", xlab = "Phenotypes")
    axis(1)
    axis(2, at=seq(0, .6, .2))
    box()
}

dens.xy <- density(x = pheno, n = 512, adjust = 2) # Adjust to make it smoother 

## Make a fake population 
add.fake.pop <-  function(x = dens.xy, y = fit,  alp = 1) {
    ## Line at the mean 
    ## abline(v = mean(x), lty = 3)
    ## Calculate the density of the population 
    ## Add density 
    lines(x = dens.xy$x, y = dens.xy$y/3, lty = 2)
}

drawPlot <- function() {
    par(family="TeX Gyre Adventor", mgp=c(2, .7, 0))
    main.plot()
    add.fake.pop(alp = .1)
}
```

```{r, echo=FALSE}
annotationTeX <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the \textcolor{Rred}{\bf fitness function}.
\end{minipage})"
```

```{r, typesetting, echo=FALSE, fig.width=7, fig.height=4.5, out.width="100%", fig.keep="last", fig.cap="A plot with a text annotation in the top-right corner that contains several typesetting challenges:  in-line mathematical expressions like $\\bar z_i$; changes in color so that the last two words match the colour of the thicker line in the plot; and automated line-breaks with full justification and hyphenation.", fig.alt="A line plot with two curves, the details of which do not really matter.  One line is thick and red, the other is dashed and black.  The important part is the annotation in the top-right corner of the plot, which is a paragraph of text that contains all of the typesetting features that are described in the main text."}

adventor <- fontspecPackage(font="TeX Gyre Adventor", name="adventor")

library(gggrid)

if (.Platform$OS.type == "windows") {
    TeXGyreR <- "TeXGyreAdventor"
} else {
    TeXGyreR <- "TeX Gyre Adventor"
}

ggIntro <- ggplot(data.frame(x, y)) +
    geom_line(aes(x, y), linewidth=2, colour=2) +
    geom_line(aes(x, y), data=data.frame(x=dens.xy$x, y=dens.xy$y/3),
              linetype="dashed") +
    xlab("Phenotypes") +
    ylab("Fitness") +
    theme_bw() +
    theme(text=element_text(family=TeXGyreR, size=12),
          panel.grid=element_blank())

label <- function(data, coords) {
    latexGrob(annotationTeX, packages=list(adventor, "xcolor"),
              x=max(coords$x), 
              y=max(coords$y),
              hjust="right", vjust="top", 
              gp=NULL)
}

ggIntro + 
    grid_panel(label, aes(x, y))
```

The annotation in Figure \@ref(fig:typesetting)
may not appear to be particularly special nor particularly complicated 
at first glance, but it harbors several important details:

* The text is a mixture of plain text and mathematical expressions (like
  $\bar{z}_i$). Furthermore, the mathematical expressions use a different font
  (Latin Modern) than the plain text (TeX Gyre Adventor)
  and the mixture is broken across multiple lines.

  The R graphics system can draw mathematical expressions [@plotmath]
  and that includes a mixture of plain text and mathematical expressions.
  Furthermore, the R graphics system uses a separate symbol font
  for mathematical expressions compared to plain text.  However,
  further changes in font within the plain text are not possible and line
  breaks are not supported.
  There is also the problem
  that the typesetting of mathematical expressions in R graphics is not
  of a very high quality.

* The text is not all the same color; the final two words (but not the full
  stop) are red.  Furthermore, the final two words are **bold**;
  they have a different
  font face compared to the rest of the text.

  The R graphics system can only draw a character value with a single color
  and a single font face.
  The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages make it possible to change color within
  a character value, but they do not allow a mixture of character values and
  R mathematical expressions.  Furthermore, they do not provide support for
  MathML `<math>` tags.

* The text is broken over multiple lines. Furthermore, the text is fully
  justified (not ragged-left or ragged-right justified) and one word
  has been split across lines and hyphenated. Although it is not
  obvious from the plot itself, the line breaks were also automatically
  generated to fit the text into a fixed width.

  The R graphics system can draw a character value across multiple lines, but
  only if explicit newlines are embedded in the character value (i.e., the line
  breaks are manual).  The base function `strwrap()` can be used to break
  lines, but it is only designed for monospaced terminal output
  and ragged-right justification.
  The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages can calculate simple
  automated line breaks, but they will not break a word across lines (or
  hyphenate) and they cannot fully justify the resulting text. The
  \CRANpkg{marquee} package can automate line breaks and fully justify
  text, but it cannot hyphenate nor can it produce mathematical expressions.

The features outlined above are all examples of *typesetting*; determining an
arrangement of individual characters and symbols (glyphs) that could be as
simple as placing one character after another (from left to right), but could
also be as complex as arranging mathematical symbols, splitting text into
multiple columns, or writing text vertically from top to bottom.

From R 4.3.0, it has been
possible to draw text from a set of typeset glyphs using the
functions `grDevices::glyphInfo()` and `grid::grid.glyph()`
[@murrell-pedersen-urbanek-glyphs-2023]. This facility
offers the promise of being able to render arbitrary typeset text
in R. However, it
presupposes that we are able to generate a set of typeset glyphs.

The \CRANpkg{marquee} package provides an example of a package
that can generate typeset glyphs.  It is capable of converting
markdown input into a set of glyphs and their positions, which are
then rendered in R.

This article describes the `xdvir` package, which is another example
of a package that can generate typeset glyphs.
In this case, the input is `r LaTeX`, a `r TeX` engine processes the
`r LaTeX` source to create DVI output, which is essentially 
a set of glyphs and their positions, 
and then `xdvir` reads the DVI output and 
renders the result in R.^[This process 
mirrors one way of working with `r LaTeX` documents:
`r LaTeX` source (a `.tex` file) is processed by a `r TeX` engine
to produce DVI output (a `.dvi` file) and then the DVI output is
processed to render PDF output (a `.pdf` file).  The final processing
step is performed by a \emph{DVI driver}, for example `dvipdf` for PDF output
or `dvips` for PostScript output.  Different `r TeX` engines produce different
DVI output. For example, `r LuaTeX` produces a `.dvi` file, but 
`r XeTeX` produces 
a slightly different DVI output in the form of a `.xdv` file.
Consequently, there are different DVI drivers for different DVI output,
for example `xdvipdfmx` for processing a `.xdv` file to a `.pdf` file.
The `xdvir` package is essentially a DVI driver that works for both
`.dvi` files and `.xdv` files and produces R output, hence the name 
`xdvir`.]
The benefit of the `xdvir` package is that it provides access to the
typesetting capabilities of `r LaTeX`, which includes hyphenation,
fully justified text, mixtures of plain text and mathematical expressions---all
of the features demonstrated in Figure \@ref(fig:typesetting)---and much more.

The next section describes the basic usage of the `xdvir` package.
This is followed by a section that breaks down the 
design of the `xdvir` package to show the steps that are
required to render `r LaTeX` output in R.
Subsequent sections explore several of the complexities 
that can arise with rendering `r LaTeX` text in R graphics and 
some of the solutions that 
the `xdvir` package provides.
The article ends with several extended examples of rendering `r LaTeX` text in R.

# `r LaTeX` text labels in R {#userinterface}

The simplest way to draw `r LaTeX` text with the `xdvir` package 
is to call the `grid.latex()` function.  The first argument to
this function is a character value, which is interpreted as
a fragment of `r LaTeX` code.
For example, the following code draws a text label that contains
a subset of the larger annotation from 
Figure \@ref(fig:typesetting).  We use just a subset here in order
to keep the code readable.

Because `r LaTeX` code tends to contain 
a large number of backslashes, the code below uses the `r"(...)"`
syntax for raw character constants, so that we do not have to
escape each backslash with a double backslash.
The resulting image is shown below the code.
Although it is not immediately obvious from that image, 
the text, or rather the glyphs, in the image are rendered by R.

```{r}
library(xdvir)
```

```{r, fragment}
simpleTeX <- r"(We move the original mean to $\bar z_i$)"
```

```{r rect, eval=FALSE, echo=FALSE}
grid.rect()
```
```{r gridlatex, eval=FALSE}
grid.latex(simpleTeX)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<gridlatex>>
```

It is possible to produce something similar to this result using 
the *plotmath* feature in R, as shown in the following code (and the image
below the code).  However, this demonstrates that
one advantage of using `xdvir`, even for a simple
piece of text like this, is the superior quality of the `r LaTeX` 
fonts and typesetting for mathematical expressions.

```{r}
plotmath <- expression("We move the original mean to "*bar(italic(z))[i])
```
```{r plotmathexpr, eval=FALSE}
grid.text(plotmath)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<plotmathexpr>>
```

Another immediate benefit of `xdvir` is that we can automatically fit
the text within a specified width.
For example, the following code draws the `r LaTeX` fragment `tex`
again, but this time forces it to fit within a column that is half
the width of the image.

```{r width, eval=FALSE}
grid.latex(simpleTeX, width=.5)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<width>>
```

As the function name `grid.latex()` suggests, that function
produces low-level 
drawing in the `grid` package graphics system.
The text is just drawn relative to the current `grid` viewport,
wherever that may be on the page.
While this is extremely flexible, it is more likely that 
we want to combine and coordinate the text with a high-level plot
of some sort, like the annotation in Figure \@ref(fig:typesetting).
There are various ways that low-level `grid` drawing can be combined
with a high-level plot, but we will leave those demonstrations to
later sections.

Instead, for now, we will demonstrate a more common scenario:
drawing `r LaTeX` text labels on a \CRANpkg{ggplot2} plot [@pkg-ggplot2].
For this purpose, the `xdvir` package provides the
`element_latex()` function.  This allows us to specify a `r LaTeX` fragment
as a plot label and then we can indicate the special nature of the label
via the `ggplot2::theme()` function.

For example, the following code uses the same `r LaTeX` fragment 
from the example above as the title of a \CRANpkg{ggplot2} plot.
The resulting plot is shown in Figure \@ref(fig:elementlatex).
One detail about this result is that the text in this title is larger 
than the text drawn by the call to `grid.latex()` above,
even though exactly the same `r TeX` fragment is being drawn.
A closer inspection reveals that the font is also different.
These differences reflect the fact that `grid.latex()` and `element_latex()`
respect the graphical parameter settings---font families and font sizes---that
are in effect when the `r LaTeX` fragment is drawn.  In Figure
\@ref(fig:elementlatex) that means respecting the theme settings
of the \CRANpkg{ggplot2} plot.
The `ggIntro` object in the code below
contains a description of the main \CRANpkg{ggplot2} 
plot from Figure 
\@ref(fig:typesetting).
The code for generating 
`ggIntro` is not shown in order to keep the code below readable,
but it is available in the supplementary materials for this article.

```{r}
library(ggplot2)
```

(ref:elementlatexFigCap) The `ggplot2` plot from Figure \@ref(fig:typesetting), without the text annotation, but with a title that was specified using a `r LaTeX` fragment and the function `element_latex()`.

```{r, elementlatex, fig.width=7, fig.height=4.5, out.width="100%", fig.cap='(ref:elementlatexFigCap)', fig.alt="This is a line plot with the same two lines as in Figure 1, but without the text annotation in the top-right corner.  Instead, there is a plot title that is rendered from a LaTeX fragment containing a mathematical expression."}
ggIntro +
    labs(title=simpleTeX) +
    theme(plot.title=element_latex())
```

The `xdvir` package also provides a `geom_latex()` function for
drawing text labels, similar to the standard `ggplot2::geom_text()` function.
The values specified for the 
`label` aesthetic for `geom_latex()` are treated as fragments of `r LaTeX`
code.
For example, Figure \@ref(fig:geomlatex)
shows a plot with a set of red points
and a set of red labels, one for each point.
The points are drawn using the standard `ggplot::geom_point()` function,
but the labels are drawn using `geom_latex()` from the `xdvir` package.
The red labels for the red points in Figure \@ref(fig:geomlatex)
are small `r LaTeX` fragments that each describe 
a simple `r LaTeX` mathematical expression.
The data set used for the red points and labels is stored
in a data frame called `means` and the `r LaTeX` fragments are
in a column called `label`, as shown below.

```{r tikzmu, echo=FALSE}
muDot <- r"(%
\begin{tikzpicture}
\node[draw,circle,thick,inner sep=0.5mm]{\vphantom{M}$\mu$};
\end{tikzpicture})"
```
```{r echo=FALSE}
samples <- data.frame(x=rnorm(50), sample=rep(1:5, each=10))
means <- aggregate(samples$x, list(sample=samples$sample), mean)
means$label <- paste0("$\\bar x_", means$sample, "$")
```

```{r}
means$label
```

```{r, echo=FALSE, message=FALSE}
ggGeom <- ggplot(samples) +
    geom_vline(xintercept=0, linetype="solid", colour=1, linewidth=.5) +
    geom_point(aes(x, sample), colour="grey", size=4, alpha=.5) +
    xlab(NULL) +
    scale_x_continuous(breaks=0, labels=muDot) +
    scale_y_continuous(breaks=1:5, expand=expansion(.25)) +
    theme_minimal() +
    theme(axis.text.x=element_latex(size=16, packages="tikz", 
                                    margin=margin(-3, 0, 0, 0)),
          axis.ticks.x=element_blank(),
          axis.title.y=element_text(colour="grey"),
          axis.text.y=element_text(colour="grey"),
          panel.grid.major.x=element_blank(),
          panel.grid.minor.x=element_blank(),
          panel.grid.minor.y=element_blank())
```

The following code draws the plot in Figure \@ref(fig:geomlatex).
A call to `ggplot2::geom_point()` draws the red points and a call
to `geom_latex()` draws the red labels.
The `ggGeom` object in the code below describes the 
main plot, which consists of gray dots, horizontal and vertical lines,
and y-axis labels.
The code for generating 
`ggGeom` is not shown in order to keep the code below readable,
but it is available in the supplementary materials for this article.

(ref:geomlatexFigCap) A `ggplot2` plot with text labels specified as `r LaTeX` fragments and drawn using the `geom_latex()` function.

```{r, geomlatex, fig.width=7, fig.height=3.5, out.width="100%", fig.cap='(ref:geomlatexFigCap)', fig.alt="A scatterplot with five rows of grey dots, where each row of dots represents a random sample of values from a population.  In addition, there is a red dot on each row that represents the mean value for each sample, plus a red label above each red dot that is based on a simple LaTeX mathematical expression."}
ggGeom +
    geom_point(aes(x, sample), data=means, colour=2, size=4) +
    geom_latex(aes(x, sample, label=label), data=means, 
               size=6, vjust=-.4, colour=2)    
```

# Under the hood {#underhood}

The previous section showed that simple usage of the `xdvir` package
only requires specifying a `r LaTeX` fragment as the text to draw.
For example, several examples used the `r LaTeX` fragment shown below.

```{r}
simpleTeX
```

The `grid.latex()` function has three tasks to perform in order to
draw that `r LaTeX` fragment in R:

**Authoring:**

: The `r LaTeX` fragment has to be turned into a complete
  `r LaTeX` document.

: The `author()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the following code
  takes the `r LaTeX` fragment `simpleTeX` and produces a complete `r LaTeX`
  document, `simpleDoc`, that is ready to typeset.

```{r}
simpleDoc <- author(simpleTeX)
```
```{r eval=FALSE}
simpleDoc
```
```{r echo=FALSE}
output <- substring(capture.output(simpleDoc), 1, 84)
cat(output, sep="\n")
```

**Typesetting:**

: The `r LaTeX` document has to be typeset to produce a set of 
  glyphs and their positions.

: The `typeset()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the following code takes the `r LaTeX` document `simpleDoc` and
  produces a `"DVI"` object, `simpleDVI`,
  that contains instructions specifying the fonts to
  use (lines that contain `x_fnt_def` and `fnt_num` in the output below), 
  the glyphs to use from those fonts (lines that contain
  `x_glyph` in the output below), and where to draw those glyphs
  (lines that contain `down` and `right` and `x_glyph`).
  The output shown below has been trimmed to save space and to
  make it easier to read.

```{r typeset, echo=FALSE}
simpleDVI <- typeset(simpleDoc)
```
```{r dvi, echo=FALSE, eval=FALSE}
simpleDVI
```  
```{r eval=FALSE}
<<typeset>>
<<dvi>>
```
```{r echo=FALSE}
output <- substring(capture.output(simpleDVI), 1, 84)
firstDown <- grep("^down", output)[1]
firstDef <- grep("^x_fnt_def", output)[1]
firstGlyph <- grep("^x_glyph", output)[1]
cat(c(output[1:firstDown], 
      "\n...\n",
      output[(firstDef - 1):(firstGlyph + 3)],
      "\n...\n"), sep="\n")
```

**Rendering:**

: The result of the typesetting step has to be drawn in R.

: The `render()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the code below renders the typesetting information from
  the `simpleDVI` object
  in R.  The resulting image is shown below the code.

```{r simpledvi, eval=FALSE}
render(simpleDVI)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<simpledvi>>
```

One detail about the output above is that the rendered text from this
`render()` call is 
smaller and in a different font compared to the example from
the previous section,
which was produced by a `grid.latex()` call.
This reflects the fact that `grid.latex()`,
in the authoring step, respects the font family and
font size that are in effect when the text is rendered.
By contrast, the `render()` call is drawing typeset information 
from a `r LaTeX` document that just makes use of the default `r LaTeX` font,
Computer Modern (or to be more precise, a modernized version called
Latin Modern) at 10pt.

# `r LaTeX` packages {#packages}

The code examples so far have dealt with relatively simple fragments of 
`r LaTeX` code that consist of just text plus some simple mathematical expressions.
While this is already useful, it barely scratches the surface of 
what is possible with
`r LaTeX` code.

Many additional effects can be obtained with `r LaTeX` code by loading
`r LaTeX` packages.  As a simple example, changing the color of text
requires loading the `r LaTeX` package `xcolor`.
These `r LaTeX` packages can be loaded using the `packages` argument of the 
`grid.latex()` function (or the `element_latex()` function
or the `geom_latex()` function).
For example, the following code draws text with the last two
words in red.  

```{r}
colourTeX <- r"(We combine to get the \textcolor{red}{Fitness Function})"
```

```{r colourtex, eval=FALSE}
grid.latex(colourTeX, packages="xcolor")
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<colourtex>>
```

The argument `packages="xcolor"` is used in the authoring step to load the
package in the `r LaTeX` document preamble.  This is demonstrated below
with an explicit call to the `author()` function.  We can see that
`\usepackage{xcolor}` has been added to the `r LaTeX` document.

```{r}
colourDoc <- author(colourTeX, packages="xcolor")
```
```{r eval=FALSE}
colourDoc
```
```{r echo=FALSE}
output <- substring(capture.output(colourDoc), 1, 84)
cat(output, sep="\n")
```

This in turn affects the typesetting step:  without the `xcolor` package, the
`r LaTeX` command `\textcolor` would not be recognized;
with the `xcolor` package, 
the `\textcolor` command produces instructions to change color 
in the `"DVI"` output.  This is demonstrated below with an
explicit call to the `typeset()` function.  An example of the color-change
instructions is the line containing `color push` in the output below the code.

```{r colortypeset, echo=FALSE}
colourDVI <- typeset(colourDoc)
```
```{r colordvi, echo=FALSE, eval=FALSE}
colourDVI
```  
```{r eval=FALSE}
<<colortypeset>>
<<colordvi>>
```
```{r echo=FALSE}
output <- substring(capture.output(colourDVI), 1, 84)
firstDef <- grep("^x_fnt_def", output)[1]
firstRGB <- grep("rgb", output)[1]
cat(c(output[1:3], 
      "\n...\n",
      output[firstDef:(firstDef + 4)],
      "\n...\n",
      output[(firstRGB - 1):(firstRGB + 2)],
      "\n...\n"),
    sep="\n")
```

The argument `packages="xcolor"` is also 
used in the rendering step because, without it,
the rendering would not take any notice of the instructions to
change color.  This is demonstrated below with an explicit
call to the `render()` function.  The resulting image differs from
the previous one because it uses the default `r LaTeX` font, but we can see the
same change in color for the last two words.

```{r colourdvi, eval=FALSE}
render(colourDVI, packages="xcolor")
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<colourdvi>>
```

There are several `r LaTeX` packages with predefined support in the
`xdvir` package, including 
`xcolor` for changes in color and `fontspec` for changes in font.
Support can be added for other `r LaTeX` packages with the
`LaTeXpackage()` function.  We will see other predefined packages
and an example of defining a new `r LaTeX`
package in later sections.

# Justifying text

By default, the `r LaTeX` text drawn by `grid.latex()`
is centered upon a specified location.
For example, the following code draws the `simpleTeX` 
fragment vertically centered
at a location half-way up the image (as indicated by the gray line).

```{r horiz, echo=FALSE, eval=FALSE}
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
```
```{r justcentre, eval=FALSE}
grid.latex(simpleTeX, y=.5)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<horiz>>
<<justcentre>>
```

We can specify a different justification using the `vjust` argument.
For example, the following code draws the same `simpleTeX` fragment
at the same location, but with a bottom-justification.
Notice that the bottom of the text is based on the bounding box 
of the text, so the bottom of the text is the bottom of the subscript "i".

```{r justbottom, eval=FALSE}
grid.latex(simpleTeX, y=.5, vjust="bottom")
```

```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<horiz>>
<<justbottom>>
```

In some situations it will be much more useful to
justify text relative to the text baseline, as shown by the following code.  

```{r justbaseline, eval=FALSE}
grid.latex(simpleTeX, y=.5, vjust="baseline")
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<horiz>>
<<justbaseline>>
```

The `xdvir` package has a very simple algorithm for determining the text 
baseline, but there is also predefined support for the `r LaTeX` package `preview`, 
which produces a more reliable baseline.  That baseline can be accessed,
assuming the `preview` package is loaded, by
specifying `vjust="preview-baseline"`.

There is also an `hjust` argument for horizontal justification.
This accepts the standard values, `"left"`, `"centre"`, and `"right"`, but
also accepts `"bbleft"`, `"bbcentre"`, and `"bbright"`.
The latter three are based on a bounding box around the actual ink 
that is drawn, which does not include space before or after glyphs 
(left-side bearing and right-side bearing).
The following code provides a demonstration of the difference
by drawing the simple `r LaTeX` fragment from previous examples as the title
of a ggplot2 plot.
We add a (mathematical) vertical bar to the end of the `r LaTeX` fragment
and draw the title larger than normal and justify the text against the
right side of the plot region, using `"right"` justification first and
then using `"bbright"` justification.
The output below the code just shows the very top of the plot in order to save
space.

```{r}
rightBearingTeX <- paste0(simpleTeX, "$|$")
```
```{r justright, eval=FALSE}
ggIntro + 
    labs(title=rightBearingTeX) +
    theme(plot.title=element_latex(size=20, hjust="right"))
```
```{r echo=FALSE, fig.width=7, fig.height=1, out.width="95%"}
pushViewport(viewport(height=100, y=1, just="top"))
gg1 <- 
<<justright>>
print(gg1, newpage=FALSE)
```
```{r justbbright, eval=FALSE}
ggIntro + 
    labs(title=rightBearingTeX) +
    theme(plot.title=element_latex(size=20, hjust="bbright"))
```
```{r echo=FALSE, fig.width=7, fig.height=1, out.width="95%"}
pushViewport(viewport(height=100, y=1, just="top"))
gg2 <- 
<<justbbright>>
print(gg2, newpage=FALSE)
```

The difference between the two plots is that the second vertical bar is
precisely aligned with the right edge of the plot region whereas the
first vertical bar is slightly to the left of the right edge of the plot
region (because of the right-side bearing of the vertical bar glyph).
This is a very small detail, but it is something that can be visually 
jarring if we are trying to align components of a plot in order
to produce a clean design.  This fine level of control is exactly 
the sort of precision that we are seeking by working with `r LaTeX` typesetting.

# Integrating text

Justifying `r LaTeX` text is a simple example of a larger problem:
*integrating* `r LaTeX` text.  For example,
the text annotation in Figure \@ref(fig:typesetting)
is integrated with the plot in the sense that it is positioned
relative to the plot region.  In fact, closer inspection reveals
that the text annotation
is carefully top-justified with the maximum y-value of the 
red line and right-justified with the maximum x-value of the red line.

Put in terms of *integration* rather than justification, 
the text annotation in Figure \@ref(fig:typesetting)
is integrated with the plot because the `r LaTeX` text is drawn at a location
that is coordinated with the location of other R graphics drawing in the plot.

Another example of integration, that reverses the roles, is coordinating
other R graphics drawing with the location of `r LaTeX` text.
The following code provides a simple example.
The `r LaTeX` fragment is the simple one from previous examples with
two additions:  there are `\zsavepos` commands to mark specific locations
within the text and associate them with labels (`"a"` and `"b"`);
and there are `\Rzmark` commands to export those
locations for R to see.

```{r}
zrefTeX <- r"(We move the original\zsavepos{a} mean to \zsavepos{b}$\bar z_i$
\Rzmark{a}\Rzmark{b})"
```

If we render this `r LaTeX` fragment, we just get the familiar output.
The commands that we added to the `r LaTeX` fragment
are based on the `r LaTeX` package `zref`,
so we must load that package.

```{r zreftex, eval=FALSE}
grid.latex(zrefTeX, packages="zref")
```

```{r, echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<zreftex>>
```

However, we can now access the special locations in the `r LaTeX` 
output using the
`getMark()` function from the `xdvir` package.
For example, the following code accesses location `"a"`, which is just after
the word "original", and draws 
a small red dot at that location.

```{r geta, eval=FALSE}
a <- getMark("a")
grid.circle(a$devx, a$devy, r=unit(.5, "mm"), gp=gpar(col=2, fill=2))
```

```{r, echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<zreftex>>
<<geta>>
```

The following code accesses location `"b"`, which is just before the letter "z",
and draws a curved arrow
from `"a"` to `"b"`.

```{r getb, eval=FALSE}
b <- getMark("b")
grid.xspline(unit.c(a$devx, .5*(a$devx + b$devx), b$devx),
             unit.c(a$devy, a$devy - unit(3, "mm"), a$devy),
             shape=-1, gp=gpar(col=2, fill=2),
             arrow=arrow(length=unit(2, "mm"), type="closed"))
```

```{r, echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<zreftex>>
<<geta>>
<<getb>>
```

The exported locations also produce "anchors" that we can use to justify
`r LaTeX` text.  For example, the following code
draws the simple `r LaTeX` fragment with position `"a"` at 
the center of the image (which is indicated by gray lines).

```{r justanchor, eval=FALSE}
grid.latex(zrefTeX, packages="zref", hjust="a", vjust="a")
```
```{r vert, echo=FALSE, eval=FALSE}
grid.segments(.5, 0, .5, 1, gp=gpar(col="grey"))
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<horiz>>
<<vert>>
<<justanchor>>
```

Figure \@ref(fig:zref) provides a more realistic demonstration.
This figure shows the plot from Figure \@ref(fig:typesetting)
with a line added to visually connect the thick red line with 
the red part of the `r LaTeX` annotation.
The code for this plot is not shown for reasons of space, but it 
makes use of the same basic idea as the code above by saving locations within
the `r LaTeX` output and then accessing them with the `getMark()` function.
The full code is available in the supplementary materials for this article.

```{r, echo=FALSE}
markStr <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the 
\textcolor{Rred}{\bf \zsavepos{left}fitness function\zsavepos{right}}.
\Rzmark{left}\Rzmark{right}
\end{minipage})"
```

(ref:zrefFigCap) The `ggplot2` plot from Figure \@ref(fig:typesetting), including the `r LaTeX` annotation, with a line added relative to marked locations within the `r LaTeX` annotation (and relative to the thick red line).

```{r, zref, echo=FALSE, fig.width=7, fig.height=4.5, out.width="100%", fig.cap='(ref:zrefFigCap)', fig.alt="A line plot with two curves as in Figure 1.  The annotation is in the top-left corner as in Figure 1 and there is an additional red line from the thick red line in the plot to the last two words in the annotation, which are also red."}
markTeX <- function(data, coords) {
    latexGrob(markStr, packages=list(adventor, "xcolor", "zref"),
              x=max(coords$x), 
              y=max(coords$y),
              hjust="right", vjust="top", 
              gp=NULL)
}

makeContent.markCurve <- function(x) {
    ## Delay this calculation until drawing time so that we
    ## are in the correct viewport
    devLoc <- deviceLoc(x$x, x$y)
    addMark("curve", devLoc$x, devLoc$y)
    x
}

markCurve <- function(data, coords) {
    gTree(x=unit(coords$x[data$x == 4], "npc"),
          y=unit(coords$y[data$x == 4], "npc"),
          cl="markCurve")
}

ggIntro + 
    grid_panel(markTeX, aes(x, y)) +
    grid_panel(markCurve, aes(x, y))

left <- getMark("left")
right <- getMark("right")
curve <- getMark("curve")

grid.lines(unit.c(curve$devx, left$devx, right$devx),
           unit.c(curve$devy, left$devy - unit(1, "mm"),
                  right$devy - unit(1, "mm")),
           gp=gpar(col=2))
```

# `r LaTeX` graphics

The examples so far have demonstrated using `r LaTeX` code to describe
text labels, combined with using R to draw general
graphics---lines and circles and so on.
It is also possible to use `r LaTeX` to draw general graphics.
In particular, the `r LaTeX` package `r TikZ` provides very powerful and flexible
graphics facilities.
The `xdvir` package provides support for the `r LaTeX` package `r TikZ`,
so we are able to render `r TikZ` graphics in R.

For example, the following `r LaTeX` code describes a `r TikZ` picture
consisting of two text labels enclosed within circles, with
arrows connecting the circles.

```{r tikztex}
tikzTeX <- r"(%
\path (0, 0) node[circle,minimum size=.5in,draw,thick] (x) {\sffamily{R}} 
       (3, 0) node[circle,minimum size=.5in,draw,thick] (y) {Ti\textit{k}Z!};
\draw[-{stealth},thick] (x) .. controls (1, 1) and (2, 1).. (y);
\draw[-{stealth},thick] (y) .. controls (2, -1) and (1, -1) .. (x);)"
```

The following code draws this `r TikZ` picture in R.
The argument 
`packages="tikzPicture"` is necessary to ensure that the `r TikZ` package
is loaded in the authoring step, that `r TikZ` output is produced in the
typesetting step, and that R takes notice of the `r TikZ`
output in the rendering step.

```{r tikzpicture, eval=FALSE}
grid.latex(tikzTeX, packages="tikzPicture")
```
```{r echo=FALSE, fig.width=3, fig.height=1, out.width="40%"}
<<rect>>
<<tikzpicture>>
```

The label on the x-axis of Figure \@ref(fig:geomlatex) 
is another simple `r TikZ` picture that
uses `r TikZ` commands to draw the Greek letter mu
within a circle.
This example is not completely trivial because it uses the
`r LaTeX` concept of "phantom" text to make the circle large enough to fit
a capital "M" even though no such character is drawn.
This is another example of the detailed typesetting capabilities
that access to `r LaTeX` provides.

```{r}
<<tikzmu>>
```

The `r LaTeX` code this time includes an explicit `\begin{tikzpicture}`
and `\end{tikzpicture}`.  Those commands were implicitly added in the previous
example because we specified `packages="tikzPicture"`.
This time, we have explicitly provided the commands, so we
just specify `packages="tikz"`.

```{r tikz, eval=FALSE}
grid.latex(muDot, packages="tikz")
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<tikz>>
```

We will see a more complex example of `r TikZ` output in a later section.
Figure \@ref(fig:diag) is also a `r TikZ` picture that has been rendered
in R.

# Programmatic generation of `r LaTeX`

One obstacle to adopting the `xdvir` package is that it
assumes that the user knows how to create a `r LaTeX` fragment
(i.e., write `r LaTeX` code).  While the `xdvir` package provides
some assistance so that the user is only required to write a `r LaTeX`
fragment rather than a complete `r LaTeX` document, `r LaTeX` fragments
for text labels tend to be more complex than 
plain text labels, thanks to the additional markup that is required.

However, `r LaTeX` code is still
just text.  This means that all of the text-generating tools in R
are available to help with authoring `r LaTeX` fragments.
For example, the labels used to render text data symbols in 
Figure 3 could be generated via a simple call to the `paste0()` function,
as shown below.

```{r}
paste0("$\\bar x_", 1:5, "$")
```

There are also packages that can generate larger fragments of 
`r LaTeX` code.  For example, there are packages like \CRANpkg{xtable} 
[@pkg:xtable] and \CRANpkg{latexpdf} [@pkg:latexpdf]
for generating `r LaTeX` tables and the \CRANpkg{rmarkdown} 
package [@pkg:rmarkdown]
can generate `r LaTeX` documents from Markdown input.
The Literate Programming section of the [Reproducible Research
CRAN Task View](https://cran.r-project.org/web/views/ReproducibleResearch.html)
provides a more comprehensive list of relevant R packages.
The \CRANpkg{texPreview} package [@pkg:texPreview]
may also be helpful for previewing
the output of `r LaTeX` code within an R session.

Some of 
these tools can be particularly
useful for generating larger chunks of `r LaTeX` code,
although the `r LaTeX` code that is produced may consist of
entire documents rather than just `r LaTeX` fragments.
The next section describes how we can cope with that situation.

# Customization and debugging

Most of the examples in this article take a fragment of `r LaTeX` code
and pass it to the `grid.latex()` function, which performs an
authoring step, a typesetting step, and a rendering step.
We saw in a previous section that there are functions
`author()`, `typeset()`, and `render()`
that allow us to perform these steps separately (see Figure \@ref(fig:diag)).
This provides more control over the individual steps and allows
us to inspect the results of the individual steps, which can be
useful for debugging.
In this section, we explore further options for controlling the 
authoring, typesetting, and rendering steps.

```{r diag, echo=FALSE, fig.width=8, fig.height=3, out.width="100%", fig.cap="The design of the `xdvir` package.", fig.alt='A diagram showing the structure of the xdvir package.  Starting from a box labelled "LaTeX fragment" on the left, wecan follow an arrow to the right labelled "author()" to a box labelled "LaTeXdocument object".  From there we can follow an arrow to the right labelled "typeset()" to a box labelled "DVI object".  From there we can follow an arrow to the right labelled "render()" to a box labelled "rendered glyphs".  Alternatively, we can start at the left with the box labelled "LaTeX fragment" and follow an arrow labelled "grid.latex()" that curves up and over to the right in one step to the box labelled "rendered glyphs".  All of those boxes and arrows are within a grey rectangle labelled "R".  There are also two boxes below, outside the grey rectangle labelled "LateX document" and "DVI file" with an arrow labelled "xelatex" from left to right between them.  We can follow an arrow up from "LaTeX document" into the grey rectangle to the box labelled "LaTeXdocument object" and an arrow up from "DVI file" into the grey rectangle labelled "DVI object".'}
diagTeX <- readLines("diagram/diag.tex")
## Have to add the {xdvir} pgfsys-driver
diagTeX <- c(diagTeX[1], 
             paste0("\\def\\pgfsysdriver{'",
                    system.file("tikz", "pgfsys-xdvir.def",
                                package="xdvir"),
                    "'}"),
             diagTeX[-1])
diagDVI <- typeset(diagTeX)
## Have to load the TikZ package
grid.newpage()
grid.dvi(diagDVI, packages="tikz")
```

The `author()` function transforms a `r LaTeX` fragment into a 
complete `r LaTeX` document.  Although there are arguments to the `author()`
function that allow some control over that transformation,
e.g., the `packages` argument, it does not allow full control
over the composition of the `r LaTeX` document.
Fortunately, a `r LaTeX` document within R is essentially just a character vector,
so another way to author a `r LaTeX` document is to create an external text file
and read that into R.  This allows complete control over the content
of the `r LaTeX` document.
Another possibility is that we want to use a `r LaTeX` document that
we did not create, for example, if we write Markdown code and 
convert it to `r LaTeX` code.  

The `typeset()` function transforms a `r LaTeX` document into a `"DVI"` object
that contains a set of typeset glyphs.  There is limited control over this
process as well, with only the `engine` argument allowing us to select between
`"xetex"` or `"luatex"`.  Again, one way to 
obtain greater control is to 
perform this step outside of R by running
a `r TeX` engine, e.g., `xelatex`, on an external text file to produce a DVI
file.  The `xdvir` package provides the `readDVI()` function
to read external DVI files into R and these can then be passed to
the `render()` function for drawing.

One important caveat is that both 
a `"LaTeXdocument"` object that is produced by
the `author()` function and a `"DVI"` object that is produced by the 
`typeset()` function contain information about how they were created,
for example, the `r TeX` `engine` that was specified and the `r LaTeX`
packages that were loaded.
The `typeset()` function checks this information and warns if we ask
to typeset a `"LaTeXdocument"` that was produced for a different `r TeX` engine.
Similarly, the `render()` function, which also has an `engine` argument,
checks and warns if we ask to render a
`"DVI"` object that was produced using a different `r TeX` engine.

External `r LaTeX` documents and DVI files do not (explicitly) contain this
information so it is up to the user to ensure that the `r TeX` engine,
and any `r LaTeX` packages, are consistent with the arguments provided
to the functions `typeset()` and `render()`.
In some situations, even with the appropriate level of care,
it will be impossible to avoid warnings.

# Example 1

```{r echo=FALSE}
source("scripts/rahlf-plot.R")
```
```{r rahlfplot, echo=FALSE, eval=FALSE}
rahlfPlot()
```

```{r gridgraphics, echo=FALSE, eval=FALSE}
library(gridGraphics)
grid.echo()
```

```{r downvp, echo=FALSE, eval=FALSE}
downViewport("graphics-window-1-1")
```

```{r echo=FALSE}
rahlfTeX <- paste(readLines("TeX/rahlf.tex"), collapse="\n")
```

```{r multicol, echo=FALSE, eval=FALSE}
multicol <- LaTeXpackage("multicol",
                         preamble="\\usepackage{multicol}")
registerPackage(multicol)
```

```{r rahlflatex, echo=FALSE, eval=FALSE}
grid.latex(rahlfTeX, 
           packages=c("fontspec", "multicol"),
           x=unit(1, "cm"), y=unit(14000, "native"), 
           hjust="left", vjust="top")
```

This section demonstrates a more complete example of rendering `r LaTeX` text
within a plot.  The plot, shown in Figure \@ref(fig:rahlf), 
provides a clear example of the more advanced typesetting 
capabilities of `r LaTeX`;  the text annotation in the top-left corner
of the plot is not only typeset into two columns,
but both columns are fully justified and feature several examples of
hyphenation.

This example also demonstrates one way to integrate a
`grid.latex()` call with a plot that was drawn using functions
from the `graphics` package.  We will also see a simple 
demonstration of the `LaTeXpackage()` function to allow use of 
a `r LaTeX` package that has no predefined support in `xdvir`.

(ref:rahlfFigCap) A plot with a two-column text annotation. This plot is an adaptation of Figure 4.1 from Thomas Rahlf's book "Data Visualisation with R" [@rahlf].

```{r, rahlf, echo=FALSE, fig.width=12, fig.height=9, out.width="100%", fig.cap='(ref:rahlfFigCap)', fig.keep="last", fig.alt="A line plot showing GDP of Chile increasing over time.  The important feature is an annotation in the top-left corner of the plot that consists of two fully-justified columns of text, which was produced from a fragment of LaTeX code."}
<<rahlfplot>>
<<gridgraphics>>
<<downvp>>
<<multicol>>
<<rahlflatex>>
```

The details of the code that produces the main plot---everything except
the two columns of text in the top-left corner---are not relevant 
to this article so we perform this drawing
just with a call to a `rahlfPlot()` function that is defined in the
supplementary material for the article.  The result is shown in
Figure \@ref(fig:rahlfplain).

```{r eval=FALSE}
<<rahlfplot>>
```

(ref:rahlfplainFigCap) The main plot from Figure \@ref(fig:rahlf) without the two columns of text annotation.  This plot is drawn using functions from the `graphics` package.

```{r, rahlfplain, echo=FALSE, fig.width=12, fig.height=9, out.width="100%", fig.cap='(ref:rahlfplainFigCap)'}
<<rahlfplot>>
```

Because the main plot is drawn using functions from the `graphics` package, 
in order to integrate the output from `grid.latex()` with the plot,
we need to convert the plot to an equivalent drawing that uses
functions from the `grid` package.
This can be achieved with the `grid.echo()` function from the
\CRANpkg{gridGraphics} package [@pkg-gridgraphics], as shown below.

```{r eval=FALSE}
<<gridgraphics>>
``` 

We want to integrate
the `r LaTeX` text with the main plot.  In particular, we want
the top of the text to be aligned with the value 14,000 on the y-scale
of the plot.  There is also a 1cm gap between the left of the text 
and the y-axis line.
In order to achieve this, we can navigate to the `grid` viewport
that corresponds to the main plot region, which also has scales 
that match the plot scales.
The naming scheme for the `grid` viewports that `grid.echo()` 
generates is described in @RJ-2015-012.

```{r eval=FALSE}
<<downvp>>
```

We are now ready to render the `r LaTeX` text within the plot.
The `r LaTeX` code for this example is shown below. 
This is a larger `r LaTeX` fragment than we have previously seen,
but more importantly it contains a larger number of `r LaTeX` commands 
to control the typesetting of the text.
For example, we control the font family with a `\setmainfont` command,
we control font size and vertical line spacing
with a `\fontsize` command, 
we control the overall width of the text using a `minipage`
environment, 
we set the number of columns using a `multicol` environment,
and we control the horizontal spacing between columns with
a `\setlength` command.

```{r echo=FALSE}
cat(rahlfTeX)
```

The `\setmainfont` and 
`\fontsize` commands in the `r LaTeX` code require the `r LaTeX` package `fontspec`
to be loaded, but this is not a problem because there is predefined support
for `fontspec` in the `xdvir` package.  However, the `multicol` environment
in the `r LaTeX` code requires the `r LaTeX` package `multicol` and there is no
predefined support for that in `xdvir`.  The following code uses the
`LaTeXpackage()` function to provide support for the `r LaTeX` package `multicol`.
In a simple case like this, all we have to do is provide a name for the 
package (`"multicol"`) and use the `preamble` argument to
provide the `r LaTeX` code that should be added in the
authoring step to load the `r LaTeX` package.
We also call the `registerPackage()` function so that we can refer to this 
`r LaTeX` package just by its name.

```{r eval=FALSE}
<<multicol>>
```

Finally, we call `grid.latex()` to add the `r LaTeX` text to the plot.
The object `rahlfTeX` contains the `r LaTeX` code,
we specify the `r LaTeX` packages that have to be loaded, including
the `"multicol"` package that we just registered, and
we position the text 1cm in from the left of the
the plot viewport and at 14,000 on the y-axis.
The final result is shown in Figure \@ref(fig:rahlf).

```{r eval=FALSE}
<<rahlflatex>>
```

# Example 2

This section looks at another more complete example of a plot with
a `r LaTeX` annotation (Figure \@ref(fig:schneider)).  This example
demonstrates the sophisticated effects that are possible by
combining `r TikZ` graphics with `r LaTeX` typesetting, in this case
to produce an annotated mathematical expression.
This example also demonstrates a way to integrate lower-level
`grid.latex()` output with a \CRANpkg{ggplot2} plot
(rather than using `element_latex()` or `geom_latex()`).

```{r echo=FALSE}
source("scripts/schneider.R")
```
```{r schneiderplot, echo=FALSE, eval=FALSE}
ggSchneider
```

```{r echo=FALSE}
schneiderLines <- readLines("TeX/schneider.tex")
schneiderTeX <- paste(schneiderLines, collapse="\n")
```

```{r annotateequations, echo=FALSE, eval=FALSE}
annotateEquations <-
    LaTeXpackage(name="annotate",
                 preamble="\\usepackage{TeX/annotate-equations}")
registerPackage(annotateEquations)
```

```{r tikznobbox, echo=FALSE, eval=FALSE}
tikzNoBBox <-
    tikzPackage(name="tikzNoBBox", bbox=FALSE)
registerPackage(tikzNoBBox)
```

```{r roboto, echo=FALSE, eval=FALSE}
roboto <-
    LaTeXpackage(name="roboto",
                 preamble="\\usepackage[sfdefault,condensed]{roboto}")
registerPackage(roboto)
```

```{r anneq, echo=FALSE, eval=FALSE}
library(gggrid)

annotation <- function(data, coords) {
    latexGrob(schneiderTeX, 
              packages=c("tikzNoBBox", "annotate", "roboto", "xcolor"),
              x=unit(coords$x, "npc") + 0.5*stringWidth("160"),
              y=coords$y, hjust=1, vjust=1)
}

ggSchneider +
    grid_panel(annotation, 
               aes(x=x, y=y), 
               data=data.frame(x=160, y=dnorm(100, mean=100, sd=15)))
```

(ref:schneiderFigCap) A plot with annotated mathematical expression. This plot is an adaptation of the plot in @schneider2023.

```{r, schneider, echo=FALSE, out.width="100%", fig.cap='(ref:schneiderFigCap)', fig.alt="A Normal density curve plot.  The important feature is an annotation iin the top-right corner of the plot that consists of an annotated mathematical equation, which was produced from a fragment of LaTeX code."}
<<annotateequations>>
<<tikznobbox>>
<<roboto>>
<<anneq>>
```

The main plot in this example is a \CRANpkg{ggplot2} plot.
The details of the code that generates the main plot
are not particularly relevant to this article, so the
main plot is described in the object `ggSchneider`, which
is defined in the supplementary materials for the article.
One point worth noting is that the labeling on the x-axis, which
combines italic Greek letters with upright digits and signs, is produced
using the \CRANpkg{ggtext} package.
In other words, this example combines two levels of text annotation:
labels on the x-axis that are relatively simple, but still beyond the
capabilities of core R text drawing;  and much more sophisticated 
text annotations that require access to a complex system like `r LaTeX`.
The main plot produced by `ggSchneider` is shown in Figure 
\@ref(fig:schneiderplain).

```{r eval=FALSE}
ggSchneider
```

(ref:schneiderplainFigCap) The main plot from Figure \@ref(fig:schneider) without the annotated mathematical expression. This plot is produced using the packages \CRANpkg{ggplot2} and \CRANpkg{ggtext}.

```{r, schneiderplain, echo=FALSE, out.width="100%", fig.cap='(ref:schneiderplainFigCap)'}
ggSchneider
```

The start of the `r LaTeX` code for the annotated expression is shown below
(the full code is included in the supplementary materials for this article).
The `r LaTeX` code
is arranged in three blocks: the first block of code defines some colors;
the second block describes the main mathematical expression, but includes
some `\eqnmark` commands to save locations within the expression;
and the third block shows one of the additional mathematical
expression annotations, which
refers to one of the saved locations within the main mathematical 
expression, in this case
the "z", and positions a
label relative to that location, in this case the label "z-score",
which is positioned
above and to the left of the "z".

```{r echo=FALSE}
ann2 <- grep("[\\]annotate", schneiderLines)[2]
cat(schneiderLines[1:(ann2 - 1)], sep="\n")
```

There are several `r LaTeX` packages required by this `r LaTeX` code,
in particular the `\eqnmark` and `\annotate` commands require the `r LaTeX` 
package `annotate-equations`.
As in the previous example, we can add support for this package
using the `LaTeXpackage()` and `registerPackage()` functions.
One difference this time is that the `annotate-equations` package is being
loaded from a local `TeX` directory.  The previous example
relied on the `r LaTeX` package being available as part of the 
user's (or the system-wide) `r TeX` installation.

```{r eval=FALSE}
<<annotateequations>>
```

The `r LaTeX` package `annotate-equations` is built on `r TikZ` graphics.
We do not need to load the `r LaTeX` package `tikz` because `annotate-equations`
will do that automatically.  However, `xdvir` by default makes use 
of the bounding box information from `r TikZ` graphics and, for images with
saved locations like this, that bounding box is unreliable.
The predefined support for the `r LaTeX` package `tikz` in the `xdvir` package
includes a `tikzPackage()` function that allows us to load TikZ, but 
ignore its bounding boxes, as shown in the following code.

```{r eval=FALSE}
<<tikznobbox>>
```

Finally, we will use the `r LaTeX` package `roboto` to access 
specific variations of the Roboto font for the text labels
in the annotated mathematical expressions.

```{r eval=FALSE}
<<roboto>>
```

Rendering the annotated mathematical expression on the plot
requires integrating the `r LaTeX` output with the
\CRANpkg{ggplot2} plot.  In particular, we want to align the top of the `r LaTeX`
output with the top of the density curve and we want to align the right side
of the `r LaTeX` output with the right edge of the label "160" on the x-axis.

We saw in an earlier section
how to use `element_latex()` to draw `r LaTeX` text
in labels such as the plot title on a \CRANpkg{ggplot2} plot
and how to use `geom_latex()` to draw `r LaTeX` text
as data symbols.
In this example, we are adding a single `r LaTeX` annotation at a specific
position within a \CRANpkg{ggplot2} plot, so 
we use the \CRANpkg{gggrid} package [@pkg-gggrid].
This package provides the `grid_panel()` function, which we can 
add to a \CRANpkg{ggplot2} plot, much like the standard `ggplot2::geom_point()`
function, to add `grid` drawing to a `ggplot2` plot.
The first argument to `grid_panel()` is a function that must
generate a `grid` grob for \CRANpkg{ggplot2} to draw, based on the
data values that \CRANpkg{ggplot2} passes to it.
In this case, we define a function called `annotation()`, which
calls the `xdvir` function `latexGrob()`.  The `latexGrob()` function
is similar to 
`grid.latex()` except that it creates a description of something to draw
rather than immediately drawing it.
We pass to `latexGrob()` the `r LaTeX` code to draw the annotated
mathematical expression (`schneiderTeX`), 
a set of `packages` to load, and arguments that position
the output relative to the plot.
The final result is shown in Figure \@ref(fig:schneider).

```{r eval=FALSE}
<<anneq>>
```

# Example 3

This section 
provides another demonstration of the range of possibilities that is
provided by 
`r LaTeX` typesetting.  This
time we add annotations that are formatted as numbered
list items below a plot (Figure \@ref(fig:anzjs)).

```{r, echo=FALSE}
source("scripts/anzjs.R")
```

```{r anzjsplot, echo=FALSE, eval=FALSE}
ggANZJS
```

```{r echo=FALSE}
closeTeX <- r"(%
\fontsize{10}{12}
\selectfont
\begin{enumerate}
\item New Zealand closes its borders to \textit{almost} all travellers at
\textbf{23:59, 19 March 2020 (NZDT)}.
\end{enumerate})"
```

```{r labelLeft, echo=FALSE, eval=FALSE}
labelLeft <- function(data, coords) {
    x1 <- coords$x[1]
    x2 <- coords$x[2]
    w <- unit(1 - x2, "npc") - unit(1, "mm")
    gap <- 15
    latex1 <- latexGrob(closeTeX,
                        x=unit(x1, "npc") - unit(2, "mm"), 
                        y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
                        hjust=1, vjust=1,
                        width=w)
}
```

```{r labelRight, echo=FALSE, eval=FALSE}
labelRight <- function(data, coords) {
    x1 <- coords$x[1]
    x2 <- coords$x[2]
    w <- unit(1 - x2, "npc") - unit(1, "mm")
    gap <- 15
    latex1 <- latexGrob(closeTeX,
                        x=unit(x1, "npc") - unit(2, "mm"), 
                        y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
                        hjust=1, vjust=1,
                        width=w)
    openTeX <- r"(%
\fontsize{10}{12}
\selectfont
\begin{enumerate}\addtocounter{enumi}{1}
\item New Zealand's international border opens to all visitors from
\textbf{11:59PM, 31 July 2022 (NZDT)}.
\end{enumerate})"
    latex2 <- latexGrob(openTeX,
                        x=unit(x2, "npc") + unit(2, "mm"),
                        y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"), 
                        hjust=0, vjust=1,
                        width=w)
    latex2
}
```
```{r ggenumlist, echo=FALSE, eval=FALSE}
ggANZJS +
    grid_panel(labelLeft,
               aes(x=borders),
               data=data.frame(borders=c(borderClosed, borderOpen))) +
    grid_panel(labelRight,
               aes(x=borders),
               data=data.frame(borders=c(borderClosed, borderOpen)))
```

(ref:anzjsFigCap) A plot with numbered list items as annotations below the plot. This plot is an adaptation of Figure 10 from @anzjs2025.

```{r, anzjs, echo=FALSE, fig.width=8, fig.height=4.5, out.width="100%", fig.cap='(ref:anzjsFigCap)', fig.alt="A line plot of the traffic at Auckland airport, covering the period of the COVID pandemic.  The important features are two annotations below the plot, at the start and end of the border closures in New Zealand.  Each annotation is a numbered list item produced from a fragment of LaTeX code."}
<<labelLeft>>
<<labelRight>>
<<ggenumlist>>
```

The main plot is a \CRANpkg{ggplot2} plot with a number of relatively
simple annotations already added.
The details of the code are not particularly relevant to this
article, so the main plot is described in the object `ggANZJS`,
which is defined in the supplementary materials for the article.
One point worth noting is that the `r LaTeX` annotations that we will
be adding are required to fit within the lines that extend below the plot.
In other words, we will be specifying a fixed width for the `r LaTeX` output
to fit into.
The main plot produced by `ggANZJS` is shown in Figure \@ref(fig:anzjsplain).

```{r eval=FALSE}
ggANZJS
```

(ref:anzjsplainFigCap) The main plot from Figure \@ref(fig:anzjs) without the numbered list items as annotations.  This plot is produced using the \CRANpkg{ggplot2} package.

```{r, anzjsplain, echo=FALSE, fig.width=8, fig.height=4.5, out.width="100%", fig.cap='(ref:anzjsplainFigCap)'}
ggANZJS
```

We will focus on drawing just the left-hand `r LaTeX` annotation.
The `r LaTeX` code is shown below.
This includes commands to control the font size and an `enumerate`
environment that creates a numbered list item.

```{r echo=FALSE}
cat(closeTeX)
```

As with the previous example, we have a single annotation that we want
to position quite carefully, so we define a function that generates 
a `grid` grob to use with the `grid_panel()` function from the 
\CRANpkg{gggrid} package.
The `labelLeft()` function calls `latexGrob()`, gives it the `r LaTeX` code
to draw (`closeTeX`), specifies the position for the `r LaTeX` output,
and specifies a `width` for the output to be typeset within.

```{r eval=FALSE}
<<labelLeft>>
```

The following code combines the left-hand label annotation,
and a very similar right-hand label annotation, with the
`ggANZJS` plot.
The final result is shown in Figure \@ref(fig:anzjs).

```{r eval=FALSE}
<<ggenumlist>>
```

# Example 4

This section provides an example of integrating `grid.latex()` output
with a multi-panel \CRANpkg{lattice} plot [@pkg-lattice].
The plot is shown in
Figure \@ref(fig:lattice).

```{r latticesetup, echo=FALSE}
crime <- read.csv("data/youth-crime.csv")
crime$Month <- as.Date(crime$Month)
monthFirst <- subset(crime, Month == "2014-07-01" & Sex == "Male")
monthLevels <- monthFirst$Type[order(monthFirst$Count, decreasing=TRUE)]
monthLabels <- unlist(lapply(strwrap(monthLevels, width=30, simplify=FALSE),
                             function(x) {
                                 if (length(x) < 3)
                                     x <- c(x, rep(" ", 3 - length(x)))
                                 paste(x, collapse="\n")
                             }))
crime$Type <- factor(crime$Type, levels=monthLevels)
library(lattice)
darkGrey <- grey(.1)
lightGrey <- grey(.5)
cols <- trellis.par.get("superpose.symbol")$col[1:2]
cols[1] <- colorspace::lighten(cols[1], amount=.4)
cols[2] <- colorspace::darken(cols[2], amount=.2)
trellis.par.set(theme=list(background=list(col=darkGrey),
                           layout.heights=list(top.padding=4),
                           axis.text=list(col=lightGrey, cex=2/3),
                           axis.line=list(col=NA)))
mainPanel <- function(x, y, subscripts, groups, ...) {
    panel.superpose(x, y, subscripts, groups, 
                    col=rev(cols),
                    ...)
    panel.abline(h=0, col=lightGrey)
}
latticeCrime <- xyplot(Count ~ Month | Type, crime, groups=Sex, type="l",
       as.table=TRUE, strip=FALSE, xlab="", ylab="",
       scales=list(alternating=FALSE, axs="i",
                   y=list(limits=c(0, 1500), at=seq(0, 900, 300))),
       between=list(x=1),
       panel=mainPanel)
```
```{r adjustYticks, echo=FALSE, eval=FALSE}
grid.edit("ticklabels.left", grep=TRUE, global=TRUE, just=c("right", "bottom"))
```

```{r echo=FALSE, eval=FALSE}
## Colours come from ...
## col2rgb(cols)
```

```{r latticetitletex, echo=FALSE}
titleTeX <- r"(%
\definecolor{lightGrey}{RGB}{128,128,128}
\definecolor{lattice1}{RGB}{105,169,234}
\definecolor{lattice2}{RGB}{181,124,1}
\color{lightGrey}
Number of Incidents for \textcolor{lattice1}{Males} and 
\textcolor{lattice2}{Females}
)"
```

```{r latticepanel, echo=FALSE}
latexPanel <- function(x, y, subscripts, groups, ...) {
    type <- crime$Type[subscripts][1]
    labelY <- y[groups == "Male"][1]
    labelWidth <- convertWidth(unit(1, "npc"), "in", valueOnly=TRUE)
    panelTeX <- paste0("\\begin{minipage}{", labelWidth, "in}",
                       type, 
                       "\\end{minipage}")
    grid.latex(panelTeX, 
               x=0, hjust="left",
               y=unit(labelY, "native") + unit(4, "mm"), vjust="bottom",
               gp=gpar(col=lightGrey, fontsize=8))
    mainPanel(x, y, subscripts, groups, ...)
}
```

```{r titleX, echo=FALSE}
titleX <- unit(ifelse(knitr::is_html_output(), 0.673, 0.653), "in")
```

```{r titlegrob, echo=FALSE}
latexTitle <- latexGrob(titleTeX, x=titleX, hjust="left", 
                        packages="xcolor")
```

(ref:latticeFigCap) A \CRANpkg{lattice} plot with `r LaTeX` text used for the plot title and for annotations in each panel.

```{r echo=FALSE, eval=FALSE}
## latexGrob(x) comes from ...
## downViewport("plot_01.toplevel.vp")
## convertWidth(sum(current.viewport()$layout$widths[1:6]), "in")
```

```{r latticefinal, echo=FALSE, eval=FALSE}
update(latticeCrime,
       panel=latexPanel,
       main=latexTitle)
```

```{r lattice, echo=FALSE, fig.width=7, fig.height=7, fig.keep="last", out.width="100%", fig.cap='(ref:latticeFigCap)', fig.alt="A mulit-panel/facetted line plot showing crime statistics over time, with separate lines for males and females and a separate panel for each type of crime.  The important features are the labels in each panel that describe the type of crime, which are fully-justified to the widths of the panels and are based on fragments of LaTeX code.  The plot title is also based on a LaTeX fragment that colours the word Male the same blue as the lines representing males in each panel and the word Female the same yellow as the lines representing females in each panel."}
<<latticefinal>>
<<adjustYticks>>
```

The main plot is a \CRANpkg{lattice} plot consisting of multiple panels,
with separate lines for males and females.
The details of the code for generating the main plot are not relevant
to this article, so it is described in the object `latticeCrime`, which
is defined in the supplementary material.
The main plot produced by `latticeCrime` is shown in 
Figure \@ref(fig:latticeplain).

```{r eval=FALSE}
latticeCrime
```

(ref:latticeplainFigCap) The main plot from Figure \@ref(fig:lattice) without the title and annotations in each panel.  This plot is produced using the \CRANpkg{lattice} package.

```{r latticeplain, echo=FALSE, fig.width=7, fig.height=7, fig.keep="last", out.width="100%", fig.cap='(ref:latticeplainFigCap)'}
latticeCrime
<<adjustYticks>>
```

We can add drawing to each panel of a \CRANpkg{lattice} plot by providing
a *panel function*.  The panel function is passed the
relevant data for the panel, and the code within the panel function is run
in the panel viewport, which means that the appropriate axis scales are 
available.  This means that we can include a call to `grid.latex()` 
within a panel function in order to add `r LaTeX` text to each panel.
For example, the following code defines the panel function for
Figure \@ref(fig:lattice).
This function calculates the appropriate label for the panel
and encloses that within a `r LaTeX` `minipage` environment
that is the width of the panel.  This means that the label is typeset
to be fully-justified within the panel (unless it is a single line that is
narrower than the panel).
We use a `minipage` environment in the `r LaTeX` fragment
rather than just using the
`width` argument to `grid.latex()` because `minipage` produces a more
precise width.
The panel function then calls `grid.latex()` to draw
that `r LaTeX` fragment, placing the label slightly above the first data value
for males.  The call to the `mainPanel()` function draws the yellow and
blue lines that are part of the main plot.

```{r eval=FALSE}
<<latticepanel>>
```

The title of a \CRANpkg{lattice} plot can be specified as a `grid`
grob.  This means that we can call `latexGrob()` to generate a
title for the plot in Figure \@ref(fig:lattice).
The `r LaTeX` fragment below describes the label, first defining
three colors, and then giving the title text, with the words
"Male" and "Female" colored differently.

```{r eval=FALSE}
<<latticetitletex>>
```

The following code calls `latexGrob()` to define the title.
We pass the `r LaTeX` fragment `titleTeX`, we position the title
to line up with
the left edge of the first column of panels, and we
load the `r LaTeX` package `xcolor` so that the colors work.

```{r eval=FALSE}
<<titlegrob>>
```

The following code creates the final plot by adding the panel function 
`latexPanel` and the title `latexTitle` to the main plot `latticeCrime`.
The final result is shown in Figure \@ref(fig:lattice).

```{r eval=FALSE}
<<latticefinal>>
```

```{r trellisundo, echo=FALSE}
trellis.par.set(theme=list(background=list(col="white"),
                           axis.text=list(col="black", cex=.8),
                           axis.line=list(col="black")))
```

# Discussion

The `xdvir` package provides convenient high-level functions for 
rendering `r LaTeX` fragments as labels, annotations, or data symbols on
R plots.  The package also provides lower-level functions that
allow more fine control over the authoring, typesetting, and
rendering of `r LaTeX` code in R.

The benefit of the `xdvir` package is access to the typesetting capabilities
of `r LaTeX`.  This ranges from relatively simple features like changes in
font family, font weight, and font style, and automatic line breaks,
to intermediate features like full justification, hyphenation, and high-quality
mathematical expressions, and more advanced features like
enumerated lists, multiple columns, and `r TikZ` graphics.

One limitation of the `xdvir` package is that rendering `r LaTeX`
fragments is noticeably slower than rendering simple character values.
This is mainly because the typesetting 
step requires running a `r TeX` engine to produce a DVI file.
The `xdvir` package performs some caching in order to minimize the problem,
but the time cost can still be quite large.  For example, 
Figure \@ref(fig:lattice) requires running a `r TeX` engine 17 times.

Another limitation of the `xdvir` package is that it requires a
graphics device that can render typeset glyphs.  This currently includes
the `pdf()` and `quartz()` devices, plus all devices based on the 
Cairo graphics library [@cairo], and graphics devices 
provided by the `ragg` package [@pkg:ragg].

A final major limitation of `xdvir` is that it only currently supports two
`r TeX` engines:  `r XeTeX` and recent `r LuaTeX`.
The function `TeXstatus()` can be used to 
report on whether these are available.  An implicit limitation is that
`xdvir` requires a `r TeX` installation, though that is simplified 
through a dependency on the \CRANpkg{tinytex} package [@pkg:tinytex].

Given these limitations, it is worth discussing alternative approaches.
The first section of this article mentioned \CRANpkg{gridtext},
\CRANpkg{ggtext}, and \CRANpkg{marquee}.  These packages
provide alternative ways to render non-trivial text labels, but 
do so through Markdown and/or HTML rather than `r LaTeX`.
Although they may not be able to produce as wide a range of results
compared to `r LaTeX` code, they will perform much faster and
require fewer dependencies than `xdvir`.
There are also a number of packages that perform specific
text-placement tasks, for example \CRANpkg{geomtextpath} [@pkg:geomtextpath],
which can arrange text along an arbitrary path, and
\CRANpkg{directlabels} [@pkg:directlabels} and 
\CRANpkg{ggforce} [@pkg:ggforce], which provide functions for cleverly
positioning text annotations, though without typesetting facilities.
The advantage of `xdvir` by comparison with these packages
is that it is possible to
produce more advanced typesetting results thanks to having access to `r LaTeX`.

The \CRANpkg{tikzDevice} package [@pkg:tikzDevice] is an interesting
alternative because, where `xdvir` integrates `r LaTeX` text with R graphics, 
\CRANpkg{tikzDevice} reverses the process and integrates R graphics with 
`r LaTeX`.
The \CRANpkg{tikzDevice} package provides an R graphics device that
converts R plots into `r TikZ` pictures so that R plots can include labels with 
`r LaTeX` fragments and R plots can be 
deeply integrated with `r LaTeX` documents.
There is also a \CRANpkg{ggtikz} package [@pkg:ggtikz]
that builds on \CRANpkg{tikzDevice}
to allow `r TikZ` annotations on \CRANpkg{ggplot2} plots.
The main difference compared to `xdvir` is the destination:
if we use `xdvir`, we end up with `r LaTeX` output within an R plot;
if we use \CRANpkg{tikzDevice} or \CRANpkg{ggtikz}, 
we end up with an R plot within `r LaTeX` output.
If the final destination is a `r LaTeX` document, 
then \CRANpkg{tikzDevice} or \CRANpkg{ggtikz} may provide more convenience
and greater control. However, if the final destination is 
more general, or unknown, then `xdvir` may be the more appropriate
solution.

The \CRANpkg{latex2exp} package [@pkg:latex2exp] is another package
that works in the opposite direction to `xdvir`.  This package
takes a `r LaTeX` fragment and converts it to an R *plotmath* expression.
This allows users familiar with `r LaTeX` to access R's math-drawing facility
whereas `xdvir` allows users to access `r LaTeX`'s math-drawing facility,
which is far superior.  The advantage of \CRANpkg{latex2exp}, as with
many of these alternative approaches, is that it does not have any
system dependencies, whereas `xdvir` requires a `r TeX` installation.

Another alternative approach to including `r LaTeX` output in R plots
is to import an image of the `r LaTeX` output.
This approach harks back to early solutions for including 
`r LaTeX` mathematical expressions in web pages by generating PNG images
from `r LaTeX` fragments.
However, more modern technologies, such as SVG, mean that this
approach can yield a much higher-quality result, as 
demonstrated by @schneider2023.
One simple advantage of the `xdvir` approach is the level of convenience
that it provides by automating the authoring and typesetting steps.
The `xdvir` package also provides more possibilities to integrate
`r LaTeX` output with other drawing in R through anchors and saved positions.

Some of the limitations of `xdvir` may also be overcome by further 
development.  For example, it may be possible to extend support
to more `r TeX` engines and to more graphics devices.  Providing support
for more `r LaTeX` packages is another area for
future work.

# Acknowledgments

The `xdvir` package depends on Yihui Xie's \CRANpkg{tinytex} package
for the typesetting step.  This package makes it much
simpler to make use of `r TeX` engines, 
including performing multiple runs when necessary, and much easier
to install
`r LaTeX` packages (and `r TeX` itself).

Claus O. Wilke's \CRANpkg{ggtext} package and Thomas Lin Pedersen's
\CRANpkg{marquee} package provided excellent templates for the integration
of improved text-drawing facilities with \CRANpkg{ggplot2}.

The author owes a debt of gratitude to Marc-Olivier Beausoleil 
(Figure \@ref(fig:typesetting)), 
Thomas Rahlf (Figure \@ref(fig:rahlf)), 
and Joel Schneider (Figure \@ref(fig:schneider))
for sharing their work and
for giving either implicit or explicit
permission to base several of the examples in this article
on their work.

Finally, thanks to the journal editor and an anonymous reviewer who
provided many helpful criticisms and suggestions that helped to
improve both the package and this article.

