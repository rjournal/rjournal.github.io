# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2023-090.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
options(prompt = 'R> ', continue = '+ ')
knitr::opts_chunk$set(echo = TRUE, cache = !TRUE, message = FALSE,
                      fig.height = 3, fig.width = 5, prompt = TRUE)
library(caracas)
#options(caracas.print.method = "prettyascii")
options(caracas.print.method = "compactascii")
#options(caracas.prompt = "[c]: ")
options("digits" = 3)

library(knitr)
library(kableExtra)


## ----echo=FALSE---------------------------------------------------------------
inline_code <- function(x) {
  x
}

texdot <- function(x) {
  #tex(x, zero_as_dot = TRUE, matstr = c("matrix", "r"))
  tex(x, zero_as_dot = TRUE)
}


## -----------------------------------------------------------------------------
M0 <- toeplitz(c("a", "b"))  # Character matrix
M  <- as_sym(M0)             # as_sym() converts to a caracas symbol
v  <- vector_sym(2, "v")     # vector_sym creates symbolic vector
y  <- M %*% v
Minv <- solve(M) 
w <- Minv %*% y |> simplify()


## -----------------------------------------------------------------------------
M


## -----------------------------------------------------------------------------
M2 <- subs(M, "b", "a^2")
M3 <- subs(M2, "a", 2) 


## -----------------------------------------------------------------------------
library(reticulate)
sympy <- import("sympy")
M_ <- sympy$Matrix(list(c("a_", "b_"), c("b_", "a_")))
v_ <- sympy$Matrix(list("v1_", "v2_"))
y_ <- M_ * v_
w_ <- M_$inv() * y_
sympy$simplify(w_)


## ----results="hide"-----------------------------------------------------------
rbind(v, v)
cbind(v, v)
c(v, v)
v[3] <- "v3" # Insert element
M[, 2]
M[2]


## ----echo=T, results="hide"---------------------------------------------------
v_$row_join(v_)                                                # rbind(v, v)
v_$T$col_join(v_$T)                                            # cbind(v, v)
sympy$Matrix(c(v_$tolist(), v_$tolist()))                      # c(v, v)
sympy$Matrix(c(v_$tolist(), list(list(sympy$symbols("v3_"))))) # v[3] <- "v3"
M_$col(1L)                                                     # M[, 2]
M_$row(1L)$col(0L)                                             # M[2]


## -----------------------------------------------------------------------------
M <- matrix_sym(2, 2, entry = "sigma")
D <- matrix_sym_diag(2, entry = "d")
S <- matrix_sym_symmetric(2, entry = "s")
E <- eye_sym(2, 2)
J <- ones_sym(2, 2)
b <- vector_sym(2, entry = "b")


## -----------------------------------------------------------------------------
as_func(M)
as_expr(M)


## -----------------------------------------------------------------------------
def_sym(x)
p <- 1 - x^2 + x^3 + x^4/4 - 3 * x^5 / 5 + x^6 / 6


## -----------------------------------------------------------------------------
g <- der(p, x)
g2 <- factor_(g)
h <- der2(p, x)


## -----------------------------------------------------------------------------
sol <- solve_sys(lhs = g, rhs = 0, vars = x)
sol


## -----------------------------------------------------------------------------
solve_sys(lhs = x^2 + 1, rhs = 0, vars = x)


## -----------------------------------------------------------------------------
sol_expr <- as_expr(sol) |> unlist() |> unname()
sol_expr
h_fn <- as_func(h)
h_fn(sol_expr)


## ----echo=FALSE---------------------------------------------------------------
p_fn <- as_func(p)
g_fn <- as_func(g)


## ----calculus, fig.cap="Left: A polynomial. Center: First derivative (the gradient). Right: Second derivative (the Hessian).", echo=FALSE, fig.height=1.3, fig.width=5, layout = "l-body-outset"----
dat <- data.frame(x=seq(-1.2,2.2,0.1))
dat$p <- p_fn(dat$x)
dat$g <- g_fn(dat$x)
dat$h <- h_fn(dat$x)
stationary_points <- c(-1, 0, 1, 2)
library(ggplot2)
theme_set(theme_bw())
  p1 <- dat |> ggplot(aes(x, p)) + geom_vline(xintercept = stationary_points, col='darkgrey', linetype="dashed", linewidth = 0.5) +  geom_line()
p2 <- dat |> ggplot(aes(x, g)) + geom_vline(xintercept = stationary_points, col='darkgrey', linetype="dashed", linewidth = 0.5) +  geom_line()
p3 <- dat |> ggplot(aes(x, h)) + geom_vline(xintercept = stationary_points, col='darkgrey', linetype="dashed", linewidth = 0.5) +  geom_line()
cowplot::plot_grid(p1, p2, p3, nrow=1)


## ----anova-two-way-table, echo=F----------------------------------------------
tt <- structure(c("$y_{11}$", "$y_{21}$", "$y_{12}$", "$y_{22}$"), 
                dim = c(2L, 2L), 
                dimnames = list(NULL, NULL))
tt %>%
  kable(col.names = NULL, escape = FALSE, caption = "Two-by-two layout of data.") %>%
  kable_styling(bootstrap_options = "bordered",
                latex_options = "hold_position",
                full_width = FALSE) %>%
  column_spec(column = 1,
              border_left = TRUE) %>%
  column_spec(column = 2,
              border_right = TRUE) 


## -----------------------------------------------------------------------------
y  <- as_sym(c("y_11", "y_21", "y_12", "y_22"))
dat <- expand.grid(r = factor(1:2), s = factor(1:2))
X <- model.matrix(~ r + s, data = dat) |> as_sym()
b <- vector_sym(ncol(X), "b")
mu <- X %*% b


## -----------------------------------------------------------------------------
Xty <- t(X) %*% y
b_hat <- solve(t(X) %*% X, Xty)


## -----------------------------------------------------------------------------
data(budworm, package = "doBy")
bud <- subset(budworm, sex == "male")
bud


## ----budworm, echo = TRUE, fig.cap="Insecticide mortality of the moth tobacco budworm.", echo=FALSE, fig.height=1.3, fig.width=5, layout = "l-body-outset"----
library(ggplot2)
theme_set(theme_bw())
p1<-bud  %>% ggplot(aes(x=dose, y=log((ndead+0.5) / (ntotal - ndead + 0.5)))) +
    geom_point() + geom_line() + labs(y = "Empirical\nlogit")
p2<-bud  %>% ggplot(aes(x=log2(dose), y=log((ndead + 0.5) / (ntotal - ndead + 0.5)))) +
    geom_point() + geom_line() + labs(y = "Empirical\nlogit")
cowplot::plot_grid(p1, p2, nrow=1)


## -----------------------------------------------------------------------------
DM <- cbind(model.matrix(~log2(dose), data=bud),
            bud[, c("ndead", "ntotal")])  |> as.matrix()
DM |> head(3)


## -----------------------------------------------------------------------------
def_sym(s, p) # The previous polynomial p is removed by this new declaration
sol_ <- solve_sys(lhs = log(p / (1 - p)), rhs = s, vars = p)
p_s <- sol_[[1]]$p


## -----------------------------------------------------------------------------
def_sym(y, n)
b  <- vector_sym(2, "b")
x  <- vector_sym(2, "x")
logLp_ <- y * log(p) + (n - y) * log(1 - p) # logL as fn of p
s_b <- sum(x * b)                           # s as fn of b
p_b <- subs(p_s, s, s_b)                    # p as fn of b
logLb_ <- subs(logLp_, p, p_b)              # logL as fn of b
Sb_ <- score(logLb_, b) |> simplify()
Hb_ <- hessian(logLb_, b) |> simplify()


## -----------------------------------------------------------------------------
nms <- c("x1", "x2", "y", "n")
DM_lst <- doBy::split_byrow(DM)
logLb_lst <- lapply(DM_lst, function(vls) {
    subs(logLb_, nms, vls)
})


## -----------------------------------------------------------------------------
logLb_tot <- Reduce(`+`, logLb_lst) 
logLb_fn  <- as_func(logLb_tot, vec_arg = TRUE)
opt <- optim(c(b1 = 0, b2 = 0), logLb_fn, 
              control = list(fnscale = -1), hessian = TRUE)
opt$par


## ----eval=T-------------------------------------------------------------------
m <- glm(cbind(ndead, ntotal - ndead) ~ log2(dose), family=binomial(), data=bud)
m |> coef()


## -----------------------------------------------------------------------------
N <- 6; q <- 2
X <- matrix_sym(N, q, "x")
n <- vector_sym(N, "n")
y <- vector_sym(N, "y")
p <- vector_sym(N, "p")
s <- vector_sym(N, "s")
b <- vector_sym(q, "b")


## -----------------------------------------------------------------------------
logLp <- sum(y * log(p) + (n - y) * log(1 - p)) # logL as fn of p
p_s <- exp(s) / (exp(s) + 1)                    # p as fn of s
s_b <- X %*% b                                  # s as fn of b
p_b <- subs(p_s, s, s_b)                        # p as fn of b
logLb_ <- subs(logLp, p, p_b)                   # logL as fn of b


## ----eval=T-------------------------------------------------------------------
logLb <- subs(logLb_, cbind(X, y, n), DM)
logLb_fn <- as_func(logLb, vec_arg = TRUE)
opt <- optim(c(b1 = 0, b2 = 0), logLb_fn, 
              control = list(fnscale = -1), hessian = TRUE)
opt$par


## -----------------------------------------------------------------------------
def_sym(u, r2, s2, lambda_)
y  <- as_sym(c("y_11", "y_21", "y_12", "y_22"))
p  <- as_sym(c("u", "u*r2", "u*s2", "u*r2*s2"))
logL <- sum(y * log(p))
Lag  <- -logL + lambda_ * (sum(p) - 1) 
vars <- list(u, r2, s2, lambda_)
gLag <- der(Lag, vars)
sol  <- solve_sys(gLag, vars)
print(sol, method = "ascii")
sol <- sol[[1]]


## -----------------------------------------------------------------------------
p11 <- sol$u
p21 <- sol$u * sol$r2
p12 <- sol$u * sol$s2
p22 <- sol$u * sol$r2 * sol$s2
p.hat <- matrix_(c(p11, p21, p12, p22), nrow = 2)


## -----------------------------------------------------------------------------
H <- hessian(logL, list(u, r2, s2)) |> simplify()


## ----echo=FALSE, eval=FALSE---------------------------------------------------
#> rv <- vector_sym(2, "r")
#> sv <- vector_sym(2, "s")
#> m <- rv %*% t(sv)
#> p <- c(u*m)
#> n <- vector_sym(4, "n")
#> l <- sum(n * log(p))


## ----echo=FALSE, eval=FALSE---------------------------------------------------
#> def_sym(a, a1, a2, u, r1, r2, s1, s2)
#> p <- as_sym(c("u*r1*s1", "u*r2*s1", "u*r1*s2", "u*r2*s2"))
#> l  <- sum(y * log(p))
#> L  <- -l + a * (sum(p) - 1) + a1 * (r1 - 1) + a2 * (s1 - 1)
#> vars <- list(u, r2, s2, a, a1, a2)
#> gL <- der(L, vars)
#> sol <- solve_sys(gL, vars)
#> sol <- sol[[1]]


## ----echo=F-------------------------------------------------------------------
e <- as_sym(paste0("e", 0:3))
x <- as_sym(paste0("x", 0:3))
u <- vector_sym(3, "u")
y <- vector_sym(3, "y")
eu <- c(e, u)
xy <- c(x, y)


## ----echo=FALSE---------------------------------------------------------------
L <- diff_mat(4, "-a")


## ----echo=F-------------------------------------------------------------------
n <- 4
def_sym(a)
x <- vector_sym(n, "x")
e <- vector_sym(n, "e")
L <- diff_mat(n, "-a")
L[1, 1] <- sqrt(1-a^2)


## -----------------------------------------------------------------------------
def_sym(a, v)
n <- 4
L <- diff_mat(n, "-a") # The difference matrix, L, shown above
L[1, 1] <- sqrt(1 - a^2)
Linv <- solve(L)
K <- crossprod_(L) / v
V <- tcrossprod_(Linv) * v


## ----echo=F, results="asis"---------------------------------------------------
cat(
  "\\begin{align} 
    L^{-1} &= ", texdot(Linv), " ; \\\\ 
    K &= ", texdot(scale_matrix(K, 1/v)), " ; \\\\ 
    V &= ", texdot(scale_matrix(V, v/(a^2 - 1))), "  .
  \\end{align}", sep = "")


## -----------------------------------------------------------------------------
x <- vector_sym(n, "x")
logL <- log(det(K)) - sum(K * (x %*% t(x))) |> simplify()


## -----------------------------------------------------------------------------
xt <- c(0.1, -0.9, 0.4, 0.0)
logL. <- subs(logL, x, xt) 


## -----------------------------------------------------------------------------
logL_wrap <- as_func(logL., vec_arg = TRUE)
eps <- 0.01
par <- optim(c(a=0, v=1), logL_wrap, 
             lower=c(-(1-eps), eps), upper=c((1-eps), 10),
             method="L-BFGS-B", control=list(fnscale=-1))$par
par


## ----eval=FALSE---------------------------------------------------------------
#> arima(xt, order = c(1, 0, 0), include.mean = FALSE, method = "ML")


## ----echo=FALSE---------------------------------------------------------------
n <- 3


## ----echo=FALSE---------------------------------------------------------------
R <- as_sym(toeplitz(c(1, rep("r", n-1))))


## -----------------------------------------------------------------------------
def_sym(v, r, n, j, i)
s1 <- sum_(r, j, i+1, n) # sum_{j = i+1}^n r
s2 <- sum_(s1, i, 1, n-1) |> simplify()
var_sum <- v*(n + 2 * s2) |> simplify()
w_nr <- var_sum / n^2


## -----------------------------------------------------------------------------
l_1 <- lim(w_nr, n, Inf)           # when sample size n goes to infinity
l_2 <- lim(w_nr, r, 0, dir = '+')  # when correlation r goes to zero
l_3 <- lim(w_nr, r, 1, dir = '-')  # when correlation r goes to one


## -----------------------------------------------------------------------------
def_sym(k_n)
sol <- solve_sys(w_nr - v / k_n, k_n)
k_nr <- sol[[1]]$k_n                  # effective sample size
k_r <- lim(k_nr, n, Inf)


## -----------------------------------------------------------------------------
dat <- expand.grid(r = c(.1, .2, .5), n = c(10, 50, 1000))
k_nr_fn <- as_func(k_nr)
dat$k_nr <- k_nr_fn(r = dat$r, n = dat$n)
dat$k_r <- 1 / dat$r
dat


## ----correlated, fig.pos="h", fig.cap="Effective sample size $k_{nr}$ as function of correlation $r$ for different values of $n$. The dashed line is the limit of $k_r$ as $r \\rightarrow 1$, i.e.\ 1. ", echo=FALSE, fig.height=1.7, fig.width=5, layout = "l-body-outset", out.extra = ''----
dat <- expand.grid(r=seq(0.1, 1, .01), n=c(5, 10, 50))
k_nr_fn <- as_func(k_nr)
dat$k_nr <- k_nr_fn(r=dat$r, n=dat$n)
dat$k_r <- 1 / dat$r
dat$n <- factor(dat$n)
library(ggplot2)
theme_set(theme_bw())
dat |> 
  ggplot(aes(x=r, y=k_nr, group=n, color=n)) + 
  geom_hline(yintercept=1, linetype="dashed", col = "darkgrey") +
  geom_line() + 
  labs(y = expression(k[nr]))


## -----------------------------------------------------------------------------
x <- as_sym("x")
half_circle_ <- sqrt(1 - x^2)
ad <- int(half_circle_, "x")          # Anti derivative
area <- int(half_circle_, "x", -1, 1) # Definite integral


## -----------------------------------------------------------------------------
def_sym(x, n)
y <- (1 + x/n)^n
l <- lim(y, n, Inf, doit = FALSE)
l_2 <- doit(l)


## -----------------------------------------------------------------------------
A <- diag_(c("a", "b", "c"))


## -----------------------------------------------------------------------------
M0 <- toeplitz(c("a", "b"))  # Character matrix
M  <- as_sym(M0)             # as_sym() converts to a caracas symbol
Minv  <- solve(M)
Minv2 <- scale_matrix(Minv, det(Minv))


## -----------------------------------------------------------------------------
library(reticulate)
sympy <- import("sympy")
sympy$diff("sin(x * y)", "x", "y") 


## ----eval = FALSE-------------------------------------------------------------
#> x <- sympy$symbols("x")
#> y <- sympy$symbols("y")
#> sympy$diff(sympy$sin(x*y), x, y)


## -----------------------------------------------------------------------------
def_sym(x, y)
f <- sin(x * y) 
der(f, list(x, y))


## -----------------------------------------------------------------------------
der_diff <- function(expr, ...) {
	 sympy_func(expr, "diff", ...)
}
der_diff(sin(x * y), x, y)


## ----eval=FALSE---------------------------------------------------------------
#> sympy$diff("sin(x * y)", "x", 100L)
#> der_diff(sin(x * y), x, 100L)


## -----------------------------------------------------------------------------
A <- as_sym(toeplitz(c("a", "b", 0))) # caracas symbol
B_ <- A$pyobj$minor_submatrix(0, 1)   # reticulate object (notice: 0-based indexing)
B <- B_ |> as_sym()                   # caracas symbol


## ----echo=FALSE---------------------------------------------------------------
Rex5 <- as_sym(toeplitz(c(1, "r", rep(0, 3-2))))

