# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2025-043.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(ggplot2)
library(kableExtra)

dir <- getwd()


## ----figurememshare, out.width = "100%", fig.cap = "A schematic about where the memory is located and how different sessions access it.", echo=FALSE----
knitr::include_graphics("figures/Grafik_Memshare.png")


## ----apply, echo = TRUE-------------------------------------------------------
library(memshare)
set.seed(1)
n <- 10000
p <- 2000
# Numeric double matrix (required): n rows (cases) x d columns (features)
X <- matrix(rnorm(n * p), n, p)
# Reference vector to correlate with each column
y <- rnorm(n)
f <- function(v, y) cor(v, y)

ns <- "my_namespace"
res <- memshare::memApply(
X = X, MARGIN = 2,
FUN = f,
NAMESPACE = ns,
VARS = list(y = y),
MAX.CORES = NULL # defaults to detectCores() - 1
)


## ----lapply, echo = TRUE------------------------------------------------------
  library(memshare)
  list_length <- 1000
  matrix_dim <- 100

  # Create the list of random matrices
  l <- lapply(
      1:list_length,
      function(i) matrix(rnorm(matrix_dim * matrix_dim),
      nrow = matrix_dim, ncol = matrix_dim)
      )

  y <- rnorm(matrix_dim)
  namespace <- "my_namespace"

  res <- memLapply(l, function(el, y) {
    el %*% y
  }, NAMESPACE = namespace, VARS = list(y=y),
  MAX.CORES = 1) #MAX.CORES=1 for simplicity


## ----figure1, out.width = "100%", fig.cap = "Matrix size depicted as magnitude vs median runtime (left) and vs memory overhead (MB) during the run relative to idle (right) for `memshare`, `SharedObject` as error-bar style plots with intevals given by the median Â± AMAD across 100 runs. In addition, the serial baseline is shown as a line in magenta. The top subfigures present the full range of matrix sizes, and the bottom subfigures zoom in.", echo=FALSE----
knitr::include_graphics("figures/Figure1.png")


## ----figure2,out.width = "100%", fig.cap = "The distribution of mutual information for 19637 gene expressions as a histogram, Pareto Density Estimation (PDE), QQ-plot against normal distribution and boxplot. There are no missing values (NaN).", fig.path='figures/'----
Header <- readLines(file.path(dir,"data/MI_values.lrn"), n = 2)[2]

mi_values <- read.table(file = file.path(dir,"data/MI_values.lrn"),header = TRUE,sep = "\t",skip = 5)

DataVisualizations::InspectVariable(mi_values$MI,Name = "Distribution of Mutual Information")
#length(mi_values$MI)
#Header


## ----figure1-detail, out.width = "100%", fig.cap = "Median runtime (log-scale) vs matrix size for `memshare`, `SharedObject`, and serial baseline; ribbons show IQR across 100 runs. Insets show difference in total RSS in log(MB), i,e., the memory overhead, during the run relative to idle for Mac presenting the details of Figure \ref{fig:figure1, echo=FALSE}."----
knitr::include_graphics("figures/Figure1_appendix_secs_vs_Resident_Set_Size_mac.png")


## ----appendix-figure1, out.width = "100%", fig.cap = "Median runtime (log-scale) vs matrix size for `memshare`, `SharedObject`, and serial baseline; ribbons show IQR across 100 runs. Insets show the difference in total RSS in log(MB) (i.e., memory overhead) during the run relative to idle for Windows~10 via Boot Camp.", echo=FALSE----
knitr::include_graphics("figures/Figure1_appendix_secs_vs_Resident_Set_Size_win.png")


## ----app-a-1, out.width = "100%", fig.cap = "First Screenshot of ShareObjects Computation.", echo=FALSE----
knitr::include_graphics("figures/Crash_message1.png")


## ----app-a-2, out.width = "100%", fig.cap = "Second Screenshot of ShareObjects Computation.", echo=FALSE----
knitr::include_graphics("figures/Crash_message2.png")

