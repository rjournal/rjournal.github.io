<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/>
  <meta name="generator" content="distill" />

  <style type="text/css">
  /* Hide doc at startup (prevent jankiness while JS renders/transforms) */
  body {
    visibility: hidden;
  }
  </style>

 <!--radix_placeholder_import_source-->
 <!--/radix_placeholder_import_source-->

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { color: #00769e; background-color: #f1f3f5; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span { color: #00769e; } /* Normal */
code span.al { color: #ad0000; } /* Alert */
code span.an { color: #5e5e5e; } /* Annotation */
code span.at { color: #657422; } /* Attribute */
code span.bn { color: #ad0000; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #00769e; } /* ControlFlow */
code span.ch { color: #20794d; } /* Char */
code span.cn { color: #8f5902; } /* Constant */
code span.co { color: #5e5e5e; } /* Comment */
code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
code span.dt { color: #ad0000; } /* DataType */
code span.dv { color: #ad0000; } /* DecVal */
code span.er { color: #ad0000; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #ad0000; } /* Float */
code span.fu { color: #4758ab; } /* Function */
code span.im { } /* Import */
code span.in { color: #5e5e5e; } /* Information */
code span.kw { color: #00769e; } /* Keyword */
code span.op { color: #5e5e5e; } /* Operator */
code span.ot { color: #00769e; } /* Other */
code span.pp { color: #ad0000; } /* Preprocessor */
code span.sc { color: #5e5e5e; } /* SpecialChar */
code span.ss { color: #20794d; } /* SpecialString */
code span.st { color: #20794d; } /* String */
code span.va { color: #111111; } /* Variable */
code span.vs { color: #20794d; } /* VerbatimString */
code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
</style>

<style>
  div.csl-bib-body { }
  div.csl-entry {
    clear: both;
    }
  .hanging div.csl-entry {
    margin-left:2em;
    text-indent:-2em;
  }
  div.csl-left-margin {
    min-width:2em;
    float:left;
  }
  div.csl-right-inline {
    margin-left:2em;
    padding-left:1em;
  }
  div.csl-indent {
    margin-left: 2em;
  }
</style>

  <!--radix_placeholder_meta_tags-->
  <title>LHD: An All-encompassing R Package for Constructing Optimal Latin Hypercube Designs</title>

  <meta property="description" itemprop="description" content="Optimal Latin hypercube designs (LHDs), including maximin distance&#10;LHDs, maximum projection LHDs and orthogonal LHDs, are widely used in&#10;computer experiments. It is challenging to construct such designs with&#10;flexible sizes, especially for large ones, for two main reasons. One&#10;reason is that theoretical results, such as algebraic constructions&#10;ensuring the maximin distance property or orthogonality, are only&#10;available for certain design sizes. For design sizes where theoretical&#10;results are unavailable, search algorithms can generate designs.&#10;However, their numerical performance is not guaranteed to be optimal.&#10;Another reason is that when design sizes increase, the number of&#10;permutations grows exponentially. Constructing optimal LHDs is a&#10;discrete optimization process, and enumeration is nearly impossible&#10;for large or moderate design sizes. Various search algorithms and&#10;algebraic constructions have been proposed to identify optimal LHDs,&#10;each having its own pros and cons. We develop the R package `LHD` [^1]&#10;which implements various search algorithms and algebraic&#10;constructions. We embedded different optimality criteria into each of&#10;the search algorithms, and they are capable of constructing different&#10;types of optimal LHDs even though they were originally invented to&#10;construct maximin distance LHDs only. Another input argument that&#10;controls maximum CPU time is added to each of the search algorithms to&#10;let users flexibly allocate their computational resources. We&#10;demonstrate functionalities of the package by using various examples,&#10;and we provide guidance for experimenters on finding suitable optimal&#10;designs. The `LHD` package is easy to use for practitioners and&#10;possibly serves as a benchmark for future developments in LHD."/>

  <link rel="license" href="https://creativecommons.org/licenses/by/4.0/"/>

  <!--  https://schema.org/Article -->
  <meta property="article:published" itemprop="datePublished" content="2026-01-05"/>
  <meta property="article:created" itemprop="dateCreated" content="2026-01-05"/>
  <meta name="article:author" content="Hongzhi Wang"/>
  <meta name="article:author" content="Qian Xiao"/>
  <meta name="article:author" content="Abhyuday Mandal"/>

  <!--  https://developers.facebook.com/docs/sharing/webmasters#markup -->
  <meta property="og:title" content="LHD: An All-encompassing R Package for Constructing Optimal Latin Hypercube Designs"/>
  <meta property="og:type" content="article"/>
  <meta property="og:description" content="Optimal Latin hypercube designs (LHDs), including maximin distance&#10;LHDs, maximum projection LHDs and orthogonal LHDs, are widely used in&#10;computer experiments. It is challenging to construct such designs with&#10;flexible sizes, especially for large ones, for two main reasons. One&#10;reason is that theoretical results, such as algebraic constructions&#10;ensuring the maximin distance property or orthogonality, are only&#10;available for certain design sizes. For design sizes where theoretical&#10;results are unavailable, search algorithms can generate designs.&#10;However, their numerical performance is not guaranteed to be optimal.&#10;Another reason is that when design sizes increase, the number of&#10;permutations grows exponentially. Constructing optimal LHDs is a&#10;discrete optimization process, and enumeration is nearly impossible&#10;for large or moderate design sizes. Various search algorithms and&#10;algebraic constructions have been proposed to identify optimal LHDs,&#10;each having its own pros and cons. We develop the R package `LHD` [^1]&#10;which implements various search algorithms and algebraic&#10;constructions. We embedded different optimality criteria into each of&#10;the search algorithms, and they are capable of constructing different&#10;types of optimal LHDs even though they were originally invented to&#10;construct maximin distance LHDs only. Another input argument that&#10;controls maximum CPU time is added to each of the search algorithms to&#10;let users flexibly allocate their computational resources. We&#10;demonstrate functionalities of the package by using various examples,&#10;and we provide guidance for experimenters on finding suitable optimal&#10;designs. The `LHD` package is easy to use for practitioners and&#10;possibly serves as a benchmark for future developments in LHD."/>
  <meta property="og:locale" content="en_US"/>

  <!--  https://dev.twitter.com/cards/types/summary -->
  <meta property="twitter:card" content="summary"/>
  <meta property="twitter:title" content="LHD: An All-encompassing R Package for Constructing Optimal Latin Hypercube Designs"/>
  <meta property="twitter:description" content="Optimal Latin hypercube designs (LHDs), including maximin distance&#10;LHDs, maximum projection LHDs and orthogonal LHDs, are widely used in&#10;computer experiments. It is challenging to construct such designs with&#10;flexible sizes, especially for large ones, for two main reasons. One&#10;reason is that theoretical results, such as algebraic constructions&#10;ensuring the maximin distance property or orthogonality, are only&#10;available for certain design sizes. For design sizes where theoretical&#10;results are unavailable, search algorithms can generate designs.&#10;However, their numerical performance is not guaranteed to be optimal.&#10;Another reason is that when design sizes increase, the number of&#10;permutations grows exponentially. Constructing optimal LHDs is a&#10;discrete optimization process, and enumeration is nearly impossible&#10;for large or moderate design sizes. Various search algorithms and&#10;algebraic constructions have been proposed to identify optimal LHDs,&#10;each having its own pros and cons. We develop the R package `LHD` [^1]&#10;which implements various search algorithms and algebraic&#10;constructions. We embedded different optimality criteria into each of&#10;the search algorithms, and they are capable of constructing different&#10;types of optimal LHDs even though they were originally invented to&#10;construct maximin distance LHDs only. Another input argument that&#10;controls maximum CPU time is added to each of the search algorithms to&#10;let users flexibly allocate their computational resources. We&#10;demonstrate functionalities of the package by using various examples,&#10;and we provide guidance for experimenters on finding suitable optimal&#10;designs. The `LHD` package is easy to use for practitioners and&#10;possibly serves as a benchmark for future developments in LHD."/>

  <!--  https://scholar.google.com/intl/en/scholar/inclusion.html#indexing -->
  <meta name="citation_title" content="LHD: An All-encompassing R Package for Constructing Optimal Latin Hypercube Designs"/>
  <meta name="citation_fulltext_html_url" content="https://doi.org/10.32614/RJ-2025-033"/>
  <meta name="citation_pdf_url" content="RJ-2025-033.pdf"/>
  <meta name="citation_volume" content="17"/>
  <meta name="citation_issue" content="4"/>
  <meta name="citation_doi" content="10.32614/RJ-2025-033"/>
  <meta name="citation_journal_title" content="The R Journal"/>
  <meta name="citation_issn" content="2073-4859"/>
  <meta name="citation_firstpage" content="1"/>
  <meta name="citation_fulltext_world_readable" content=""/>
  <meta name="citation_online_date" content="2026/01/05"/>
  <meta name="citation_publication_date" content="2026/01/05"/>
  <meta name="citation_author" content="Hongzhi Wang"/>
  <meta name="citation_author" content="Qian Xiao"/>
  <meta name="citation_author_institution" content="Shanghai Jiao Tong University"/>
  <meta name="citation_author" content="Abhyuday Mandal"/>
  <meta name="citation_author_institution" content="University of Georgia"/>
  <!--/radix_placeholder_meta_tags-->
  
  <!--radix_placeholder_rmarkdown_metadata-->

  <script type="text/json" id="radix-rmarkdown-metadata">
  {"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["title","description","author","date","date_received","journal","volume","issue","slug","citation_url","packages","preview","bibliography","CTV","legacy_pdf","legacy_converted","output","draft","pdf_url","doi","creative_commons","csl"]}},"value":[{"type":"character","attributes":{},"value":["LHD: An All-encompassing R Package for Constructing Optimal Latin Hypercube Designs"]},{"type":"character","attributes":{},"value":["Optimal Latin hypercube designs (LHDs), including maximin distance\nLHDs, maximum projection LHDs and orthogonal LHDs, are widely used in\ncomputer experiments. It is challenging to construct such designs with\nflexible sizes, especially for large ones, for two main reasons. One\nreason is that theoretical results, such as algebraic constructions\nensuring the maximin distance property or orthogonality, are only\navailable for certain design sizes. For design sizes where theoretical\nresults are unavailable, search algorithms can generate designs.\nHowever, their numerical performance is not guaranteed to be optimal.\nAnother reason is that when design sizes increase, the number of\npermutations grows exponentially. Constructing optimal LHDs is a\ndiscrete optimization process, and enumeration is nearly impossible\nfor large or moderate design sizes. Various search algorithms and\nalgebraic constructions have been proposed to identify optimal LHDs,\neach having its own pros and cons. We develop the R package `LHD` [^1]\nwhich implements various search algorithms and algebraic\nconstructions. We embedded different optimality criteria into each of\nthe search algorithms, and they are capable of constructing different\ntypes of optimal LHDs even though they were originally invented to\nconstruct maximin distance LHDs only. Another input argument that\ncontrols maximum CPU time is added to each of the search algorithms to\nlet users flexibly allocate their computational resources. We\ndemonstrate functionalities of the package by using various examples,\nand we provide guidance for experimenters on finding suitable optimal\ndesigns. The `LHD` package is easy to use for practitioners and\npossibly serves as a benchmark for future developments in LHD.\n"]},{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","email"]}},"value":[{"type":"character","attributes":{},"value":["Hongzhi Wang"]},{"type":"character","attributes":{},"value":["wanghongzhi.ut@gmail.com"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address","email"]}},"value":[{"type":"character","attributes":{},"value":["Qian Xiao"]},{"type":"character","attributes":{},"value":["Shanghai Jiao Tong University"]},{"type":"character","attributes":{},"value":["800 Dongchuan Road, Minhang, Shanghai, 200240","China"]},{"type":"character","attributes":{},"value":["qian.xiao@sjtu.edu.cn"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","affiliation","address","email"]}},"value":[{"type":"character","attributes":{},"value":["Abhyuday Mandal"]},{"type":"character","attributes":{},"value":["University of Georgia"]},{"type":"character","attributes":{},"value":["310 Herty Drive, Athens, GA 30602","USA"]},{"type":"character","attributes":{},"value":["amandal@stat.uga.edu"]}]}]},{"type":"character","attributes":{},"value":["2026-01-05"]},{"type":"character","attributes":{},"value":["2023-11-20"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["title","issn","firstpage","lastpage"]}},"value":[{"type":"character","attributes":{},"value":["The R Journal"]},{"type":"character","attributes":{},"value":["2073-4859"]},{"type":"double","attributes":{},"value":[1]},{"type":"NULL"}]},{"type":"integer","attributes":{},"value":[17]},{"type":"integer","attributes":{},"value":[4]},{"type":"character","attributes":{},"value":["RJ-2025-033"]},{"type":"character","attributes":{},"value":["https://doi.org/10.32614/RJ-2025-033"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["cran","bioc"]}},"value":[{"type":"list","attributes":{},"value":[]},{"type":"list","attributes":{},"value":[]}]},{"type":"character","attributes":{},"value":["preview.png"]},{"type":"character","attributes":{},"value":["wang-xiao-mandal.bib"]},{"type":"list","attributes":{},"value":[]},{"type":"logical","attributes":{},"value":[true]},{"type":"logical","attributes":{},"value":[true]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["distill::distill_article"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["self_contained","toc","mathjax","md_extension"]}},"value":[{"type":"logical","attributes":{},"value":[true]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"]},{"type":"character","attributes":{},"value":["-tex_math_single_backslash"]}]}]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["RJ-2025-033.pdf"]},{"type":"character","attributes":{},"value":["10.32614/RJ-2025-033"]},{"type":"character","attributes":{},"value":["CC BY"]},{"type":"character","attributes":{},"value":["/home/hyndman/R/x86_64-pc-linux-gnu-library/4.5/rjtools/rjournal.csl"]}]}
  </script>
  <!--/radix_placeholder_rmarkdown_metadata-->
  
  <script type="text/json" id="radix-resource-manifest">
  {"type":"character","attributes":{},"value":["RJ-2025-033_files/anchor-4.2.2/anchor.min.js","RJ-2025-033_files/bowser-1.9.3/bowser.min.js","RJ-2025-033_files/distill-2.2.21/template.v2.js","RJ-2025-033_files/header-attrs-2.30/header-attrs.js","RJ-2025-033_files/jquery-3.6.0/jquery-3.6.0.js","RJ-2025-033_files/jquery-3.6.0/jquery-3.6.0.min.js","RJ-2025-033_files/jquery-3.6.0/jquery-3.6.0.min.map","RJ-2025-033_files/popper-2.6.0/popper.min.js","RJ-2025-033_files/tippy-6.2.7/tippy-bundle.umd.min.js","RJ-2025-033_files/tippy-6.2.7/tippy-light-border.css","RJ-2025-033_files/tippy-6.2.7/tippy.css","RJ-2025-033_files/tippy-6.2.7/tippy.umd.min.js","RJ-2025-033_files/webcomponents-2.0.0/webcomponents.js","RJ-2025-033.pdf","RJ-2025-033.zip","RJournal.sty","RJwrapper.aux","RJwrapper.bbl","RJwrapper.blg","RJwrapper.brf","RJwrapper.fdb_latexmk","RJwrapper.fls","RJwrapper.log","RJwrapper.out","RJwrapper.synctex.gz","RJwrapper.tex","wang-xiao-mandal.bib","wang-xiao-mandal.tex"]}
  </script>
  <!--radix_placeholder_navigation_in_header-->
  <!--/radix_placeholder_navigation_in_header-->
  <!--radix_placeholder_distill-->

  <style type="text/css">

  body {
    background-color: white;
  }

  .pandoc-table {
    width: 100%;
  }

  .pandoc-table>caption {
    margin-bottom: 10px;
  }

  .pandoc-table th:not([align]) {
    text-align: left;
  }

  .pagedtable-footer {
    font-size: 15px;
  }

  d-byline .byline {
    grid-template-columns: 2fr 2fr;
  }

  d-byline .byline h3 {
    margin-block-start: 1.5em;
  }

  d-byline .byline .authors-affiliations h3 {
    margin-block-start: 0.5em;
  }

  .authors-affiliations .orcid-id {
    width: 16px;
    height:16px;
    margin-left: 4px;
    margin-right: 4px;
    vertical-align: middle;
    padding-bottom: 2px;
  }

  d-title .dt-tags {
    margin-top: 1em;
    grid-column: text;
  }

  .dt-tags .dt-tag {
    text-decoration: none;
    display: inline-block;
    color: rgba(0,0,0,0.6);
    padding: 0em 0.4em;
    margin-right: 0.5em;
    margin-bottom: 0.4em;
    font-size: 70%;
    border: 1px solid rgba(0,0,0,0.2);
    border-radius: 3px;
    text-transform: uppercase;
    font-weight: 500;
  }

  d-article table.gt_table td,
  d-article table.gt_table th {
    border-bottom: none;
    font-size: 100%;
  }

  .html-widget {
    margin-bottom: 2.0em;
  }

  .l-screen-inset {
    padding-right: 16px;
  }

  .l-screen .caption {
    margin-left: 10px;
  }

  .shaded {
    background: rgb(247, 247, 247);
    padding-top: 20px;
    padding-bottom: 20px;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  }

  .shaded .html-widget {
    margin-bottom: 0;
    border: 1px solid rgba(0, 0, 0, 0.1);
  }

  .shaded .shaded-content {
    background: white;
  }

  .text-output {
    margin-top: 0;
    line-height: 1.5em;
  }

  .hidden {
    display: none !important;
  }

  hr.section-separator {
    border: none;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    margin: 0px;
  }


  d-byline {
    border-top: none;
  }

  d-article {
    padding-top: 2.5rem;
    padding-bottom: 30px;
    border-top: none;
  }

  d-appendix {
    padding-top: 30px;
  }

  d-article>p>img {
    width: 100%;
  }

  d-article h2 {
    margin: 1rem 0 1.5rem 0;
  }

  d-article h3 {
    margin-top: 1.5rem;
  }

  d-article iframe {
    border: 1px solid rgba(0, 0, 0, 0.1);
    margin-bottom: 2.0em;
    width: 100%;
  }

  /* Tweak code blocks */

  d-article div.sourceCode code,
  d-article pre code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  d-article pre,
  d-article div.sourceCode,
  d-article div.sourceCode pre {
    overflow: auto;
  }

  d-article div.sourceCode {
    background-color: white;
  }

  d-article div.sourceCode pre {
    padding-left: 10px;
    font-size: 12px;
    border-left: 2px solid rgba(0,0,0,0.1);
  }

  d-article pre {
    font-size: 12px;
    color: black;
    background: none;
    margin-top: 0;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  d-article pre a {
    border-bottom: none;
  }

  d-article pre a:hover {
    border-bottom: none;
    text-decoration: underline;
  }

  d-article details {
    grid-column: text;
    margin-bottom: 0.8em;
  }

  @media(min-width: 768px) {

  d-article pre,
  d-article div.sourceCode,
  d-article div.sourceCode pre {
    overflow: visible !important;
  }

  d-article div.sourceCode pre {
    padding-left: 18px;
    font-size: 14px;
  }

  /* tweak for Pandoc numbered line within distill */
  d-article pre.numberSource code > span {
      left: -2em;
  }

  d-article pre {
    font-size: 14px;
  }

  }

  figure img.external {
    background: white;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
    padding: 18px;
    box-sizing: border-box;
  }

  /* CSS for d-contents */

  .d-contents {
    grid-column: text;
    color: rgba(0,0,0,0.8);
    font-size: 0.9em;
    padding-bottom: 1em;
    margin-bottom: 1em;
    padding-bottom: 0.5em;
    margin-bottom: 1em;
    padding-left: 0.25em;
    justify-self: start;
  }

  @media(min-width: 1000px) {
    .d-contents.d-contents-float {
      height: 0;
      grid-column-start: 1;
      grid-column-end: 4;
      justify-self: center;
      padding-right: 3em;
      padding-left: 2em;
    }
  }

  .d-contents nav h3 {
    font-size: 18px;
    margin-top: 0;
    margin-bottom: 1em;
  }

  .d-contents li {
    list-style-type: none
  }

  .d-contents nav > ul {
    padding-left: 0;
  }

  .d-contents ul {
    padding-left: 1em
  }

  .d-contents nav ul li {
    margin-top: 0.6em;
    margin-bottom: 0.2em;
  }

  .d-contents nav a {
    font-size: 13px;
    border-bottom: none;
    text-decoration: none
    color: rgba(0, 0, 0, 0.8);
  }

  .d-contents nav a:hover {
    text-decoration: underline solid rgba(0, 0, 0, 0.6)
  }

  .d-contents nav > ul > li > a {
    font-weight: 600;
  }

  .d-contents nav > ul > li > ul {
    font-weight: inherit;
  }

  .d-contents nav > ul > li > ul > li {
    margin-top: 0.2em;
  }


  .d-contents nav ul {
    margin-top: 0;
    margin-bottom: 0.25em;
  }

  .d-article-with-toc h2:nth-child(2) {
    margin-top: 0;
  }


  /* Figure */

  .figure {
    position: relative;
    margin-bottom: 2.5em;
    margin-top: 1.5em;
  }

  .figure .caption {
    color: rgba(0, 0, 0, 0.6);
    font-size: 12px;
    line-height: 1.5em;
  }

  .figure img.external {
    background: white;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
    padding: 18px;
    box-sizing: border-box;
  }

  .figure .caption a {
    color: rgba(0, 0, 0, 0.6);
  }

  .figure .caption b,
  .figure .caption strong, {
    font-weight: 600;
    color: rgba(0, 0, 0, 1.0);
  }

  /* Citations */

  d-article .citation {
    color: inherit;
    cursor: inherit;
  }

  div.hanging-indent{
    margin-left: 1em; text-indent: -1em;
  }

  /* Citation hover box */

  .tippy-box[data-theme~=light-border] {
    background-color: rgba(250, 250, 250, 0.95);
  }

  .tippy-content > p {
    margin-bottom: 0;
    padding: 2px;
  }


  /* Tweak 1000px media break to show more text */

  @media(min-width: 1000px) {
    .base-grid,
    distill-header,
    d-title,
    d-abstract,
    d-article,
    d-appendix,
    distill-appendix,
    d-byline,
    d-footnote-list,
    d-citation-list,
    distill-footer {
      grid-template-columns: [screen-start] 1fr [page-start kicker-start] 80px [middle-start] 50px [text-start kicker-end] 65px 65px 65px 65px 65px 65px 65px 65px [text-end gutter-start] 65px [middle-end] 65px [page-end gutter-end] 1fr [screen-end];
      grid-column-gap: 16px;
    }

    .grid {
      grid-column-gap: 16px;
    }

    d-article {
      font-size: 1.06rem;
      line-height: 1.7em;
    }
    figure .caption, .figure .caption, figure figcaption {
      font-size: 13px;
    }
  }

  @media(min-width: 1180px) {
    .base-grid,
    distill-header,
    d-title,
    d-abstract,
    d-article,
    d-appendix,
    distill-appendix,
    d-byline,
    d-footnote-list,
    d-citation-list,
    distill-footer {
      grid-template-columns: [screen-start] 1fr [page-start kicker-start] 60px [middle-start] 60px [text-start kicker-end] 60px 60px 60px 60px 60px 60px 60px 60px [text-end gutter-start] 60px [middle-end] 60px [page-end gutter-end] 1fr [screen-end];
      grid-column-gap: 32px;
    }

    .grid {
      grid-column-gap: 32px;
    }
  }


  /* Get the citation styles for the appendix (not auto-injected on render since
     we do our own rendering of the citation appendix) */

  d-appendix .citation-appendix,
  .d-appendix .citation-appendix {
    font-size: 11px;
    line-height: 15px;
    border-left: 1px solid rgba(0, 0, 0, 0.1);
    padding-left: 18px;
    border: 1px solid rgba(0,0,0,0.1);
    background: rgba(0, 0, 0, 0.02);
    padding: 10px 18px;
    border-radius: 3px;
    color: rgba(150, 150, 150, 1);
    overflow: hidden;
    margin-top: -12px;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  /* Include appendix styles here so they can be overridden */

  d-appendix {
    contain: layout style;
    font-size: 0.8em;
    line-height: 1.7em;
    margin-top: 60px;
    margin-bottom: 0;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    color: rgba(0,0,0,0.5);
    padding-top: 60px;
    padding-bottom: 48px;
  }

  d-appendix h3 {
    grid-column: page-start / text-start;
    font-size: 15px;
    font-weight: 500;
    margin-top: 1em;
    margin-bottom: 0;
    color: rgba(0,0,0,0.65);
  }

  d-appendix h3 + * {
    margin-top: 1em;
  }

  d-appendix ol {
    padding: 0 0 0 15px;
  }

  @media (min-width: 768px) {
    d-appendix ol {
      padding: 0 0 0 30px;
      margin-left: -30px;
    }
  }

  d-appendix li {
    margin-bottom: 1em;
  }

  d-appendix a {
    color: rgba(0, 0, 0, 0.6);
  }

  d-appendix > * {
    grid-column: text;
  }

  d-appendix > d-footnote-list,
  d-appendix > d-citation-list,
  d-appendix > distill-appendix {
    grid-column: screen;
  }

  /* Include footnote styles here so they can be overridden */

  d-footnote-list {
    contain: layout style;
  }

  d-footnote-list > * {
    grid-column: text;
  }

  d-footnote-list a.footnote-backlink {
    color: rgba(0,0,0,0.3);
    padding-left: 0.5em;
  }



  /* Anchor.js */

  .anchorjs-link {
    /*transition: all .25s linear; */
    text-decoration: none;
    border-bottom: none;
  }
  *:hover > .anchorjs-link {
    margin-left: -1.125em !important;
    text-decoration: none;
    border-bottom: none;
  }

  /* Social footer */

  .social_footer {
    margin-top: 30px;
    margin-bottom: 0;
    color: rgba(0,0,0,0.67);
  }

  .disqus-comments {
    margin-right: 30px;
  }

  .disqus-comment-count {
    border-bottom: 1px solid rgba(0, 0, 0, 0.4);
    cursor: pointer;
  }

  #disqus_thread {
    margin-top: 30px;
  }

  .article-sharing a {
    border-bottom: none;
    margin-right: 8px;
  }

  .article-sharing a:hover {
    border-bottom: none;
  }

  .sidebar-section.subscribe {
    font-size: 12px;
    line-height: 1.6em;
  }

  .subscribe p {
    margin-bottom: 0.5em;
  }


  .article-footer .subscribe {
    font-size: 15px;
    margin-top: 45px;
  }


  .sidebar-section.custom {
    font-size: 12px;
    line-height: 1.6em;
  }

  .custom p {
    margin-bottom: 0.5em;
  }

  /* Styles for listing layout (hide title) */
  .layout-listing d-title, .layout-listing .d-title {
    display: none;
  }

  /* Styles for posts lists (not auto-injected) */


  .posts-with-sidebar {
    padding-left: 45px;
    padding-right: 45px;
  }

  .posts-list .description h2,
  .posts-list .description p {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
  }

  .posts-list .description h2 {
    font-weight: 700;
    border-bottom: none;
    padding-bottom: 0;
  }

  .posts-list h2.post-tag {
    border-bottom: 1px solid rgba(0, 0, 0, 0.2);
    padding-bottom: 12px;
  }
  .posts-list {
    margin-top: 60px;
    margin-bottom: 24px;
  }

  .posts-list .post-preview {
    text-decoration: none;
    overflow: hidden;
    display: block;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    padding: 24px 0;
  }

  .post-preview-last {
    border-bottom: none !important;
  }

  .posts-list .posts-list-caption {
    grid-column: screen;
    font-weight: 400;
  }

  .posts-list .post-preview h2 {
    margin: 0 0 6px 0;
    line-height: 1.2em;
    font-style: normal;
    font-size: 24px;
  }

  .posts-list .post-preview p {
    margin: 0 0 12px 0;
    line-height: 1.4em;
    font-size: 16px;
  }

  .posts-list .post-preview .thumbnail {
    box-sizing: border-box;
    margin-bottom: 24px;
    position: relative;
    max-width: 500px;
  }
  .posts-list .post-preview img {
    width: 100%;
    display: block;
  }

  .posts-list .metadata {
    font-size: 12px;
    line-height: 1.4em;
    margin-bottom: 18px;
  }

  .posts-list .metadata > * {
    display: inline-block;
  }

  .posts-list .metadata .publishedDate {
    margin-right: 2em;
  }

  .posts-list .metadata .dt-authors {
    display: block;
    margin-top: 0.3em;
    margin-right: 2em;
  }

  .posts-list .dt-tags {
    display: block;
    line-height: 1em;
  }

  .posts-list .dt-tags .dt-tag {
    display: inline-block;
    color: rgba(0,0,0,0.6);
    padding: 0.3em 0.4em;
    margin-right: 0.2em;
    margin-bottom: 0.4em;
    font-size: 60%;
    border: 1px solid rgba(0,0,0,0.2);
    border-radius: 3px;
    text-transform: uppercase;
    font-weight: 500;
  }

  .posts-list img {
    opacity: 1;
  }

  .posts-list img[data-src] {
    opacity: 0;
  }

  .posts-more {
    clear: both;
  }


  .posts-sidebar {
    font-size: 16px;
  }

  .posts-sidebar h3 {
    font-size: 16px;
    margin-top: 0;
    margin-bottom: 0.5em;
    font-weight: 400;
    text-transform: uppercase;
  }

  .sidebar-section {
    margin-bottom: 30px;
  }

  .categories ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }

  .categories li {
    color: rgba(0, 0, 0, 0.8);
    margin-bottom: 0;
  }

  .categories li>a {
    border-bottom: none;
  }

  .categories li>a:hover {
    border-bottom: 1px solid rgba(0, 0, 0, 0.4);
  }

  .categories .active {
    font-weight: 600;
  }

  .categories .category-count {
    color: rgba(0, 0, 0, 0.4);
  }


  @media(min-width: 768px) {
    .posts-list .post-preview h2 {
      font-size: 26px;
    }
    .posts-list .post-preview .thumbnail {
      float: right;
      width: 30%;
      margin-bottom: 0;
    }
    .posts-list .post-preview .description {
      float: left;
      width: 45%;
    }
    .posts-list .post-preview .metadata {
      float: left;
      width: 20%;
      margin-top: 8px;
    }
    .posts-list .post-preview p {
      margin: 0 0 12px 0;
      line-height: 1.5em;
      font-size: 16px;
    }
    .posts-with-sidebar .posts-list {
      float: left;
      width: 75%;
    }
    .posts-with-sidebar .posts-sidebar {
      float: right;
      width: 20%;
      margin-top: 60px;
      padding-top: 24px;
      padding-bottom: 24px;
    }
  }


  /* Improve display for browsers without grid (IE/Edge <= 15) */

  .downlevel {
    line-height: 1.6em;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
    margin: 0;
  }

  .downlevel .d-title {
    padding-top: 6rem;
    padding-bottom: 1.5rem;
  }

  .downlevel .d-title h1 {
    font-size: 50px;
    font-weight: 700;
    line-height: 1.1em;
    margin: 0 0 0.5rem;
  }

  .downlevel .d-title p {
    font-weight: 300;
    font-size: 1.2rem;
    line-height: 1.55em;
    margin-top: 0;
  }

  .downlevel .d-byline {
    padding-top: 0.8em;
    padding-bottom: 0.8em;
    font-size: 0.8rem;
    line-height: 1.8em;
  }

  .downlevel .section-separator {
    border: none;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
  }

  .downlevel .d-article {
    font-size: 1.06rem;
    line-height: 1.7em;
    padding-top: 1rem;
    padding-bottom: 2rem;
  }


  .downlevel .d-appendix {
    padding-left: 0;
    padding-right: 0;
    max-width: none;
    font-size: 0.8em;
    line-height: 1.7em;
    margin-bottom: 0;
    color: rgba(0,0,0,0.5);
    padding-top: 40px;
    padding-bottom: 48px;
  }

  .downlevel .footnotes ol {
    padding-left: 13px;
  }

  .downlevel .base-grid,
  .downlevel .distill-header,
  .downlevel .d-title,
  .downlevel .d-abstract,
  .downlevel .d-article,
  .downlevel .d-appendix,
  .downlevel .distill-appendix,
  .downlevel .d-byline,
  .downlevel .d-footnote-list,
  .downlevel .d-citation-list,
  .downlevel .distill-footer,
  .downlevel .appendix-bottom,
  .downlevel .posts-container {
    padding-left: 40px;
    padding-right: 40px;
  }

  @media(min-width: 768px) {
    .downlevel .base-grid,
    .downlevel .distill-header,
    .downlevel .d-title,
    .downlevel .d-abstract,
    .downlevel .d-article,
    .downlevel .d-appendix,
    .downlevel .distill-appendix,
    .downlevel .d-byline,
    .downlevel .d-footnote-list,
    .downlevel .d-citation-list,
    .downlevel .distill-footer,
    .downlevel .appendix-bottom,
    .downlevel .posts-container {
    padding-left: 150px;
    padding-right: 150px;
    max-width: 900px;
  }
  }

  .downlevel pre code {
    display: block;
    border-left: 2px solid rgba(0, 0, 0, .1);
    padding: 0 0 0 20px;
    font-size: 14px;
  }

  .downlevel code, .downlevel pre {
    color: black;
    background: none;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
  }

  .downlevel .posts-list .post-preview {
    color: inherit;
  }



  </style>

  <script type="application/javascript">

  function is_downlevel_browser() {
    if (bowser.isUnsupportedBrowser({ msie: "12", msedge: "16"},
                                   window.navigator.userAgent)) {
      return true;
    } else {
      return window.load_distill_framework === undefined;
    }
  }

  // show body when load is complete
  function on_load_complete() {

    // add anchors
    if (window.anchors) {
      window.anchors.options.placement = 'left';
      window.anchors.add('d-article > h2, d-article > h3, d-article > h4, d-article > h5');
    }


    // set body to visible
    document.body.style.visibility = 'visible';

    // force redraw for leaflet widgets
    if (window.HTMLWidgets) {
      var maps = window.HTMLWidgets.findAll(".leaflet");
      $.each(maps, function(i, el) {
        var map = this.getMap();
        map.invalidateSize();
        map.eachLayer(function(layer) {
          if (layer instanceof L.TileLayer)
            layer.redraw();
        });
      });
    }

    // trigger 'shown' so htmlwidgets resize
    $('d-article').trigger('shown');
  }

  function init_distill() {

    init_common();

    // create front matter
    var front_matter = $('<d-front-matter></d-front-matter>');
    $('#distill-front-matter').wrap(front_matter);

    // create d-title
    $('.d-title').changeElementType('d-title');

    // separator
    var separator = '<hr class="section-separator" style="clear: both"/>';
    // prepend separator above appendix
    $('.d-byline').before(separator);
    $('.d-article').before(separator);

    // create d-byline
    var byline = $('<d-byline></d-byline>');
    $('.d-byline').replaceWith(byline);

    // create d-article
    var article = $('<d-article></d-article>');
    $('.d-article').wrap(article).children().unwrap();

    // move posts container into article
    $('.posts-container').appendTo($('d-article'));

    // create d-appendix
    $('.d-appendix').changeElementType('d-appendix');

    // flag indicating that we have appendix items
    var appendix = $('.appendix-bottom').children('h3').length > 0;

    // replace footnotes with <d-footnote>
    $('.footnote-ref').each(function(i, val) {
      appendix = true;
      var href = $(this).attr('href');
      var id = href.replace('#', '');
      var fn = $('#' + id);
      var fn_p = $('#' + id + '>p');
      fn_p.find('.footnote-back').remove();
      var text = fn_p.html();
      var dtfn = $('<d-footnote></d-footnote>');
      dtfn.html(text);
      $(this).replaceWith(dtfn);
    });
    // remove footnotes
    $('.footnotes').remove();

    // move refs into #references-listing
    $('#references-listing').replaceWith($('#refs'));

    $('h1.appendix, h2.appendix').each(function(i, val) {
      $(this).changeElementType('h3');
    });
    $('h3.appendix').each(function(i, val) {
      var id = $(this).attr('id');
      $('.d-contents a[href="#' + id + '"]').parent().remove();
      appendix = true;
      $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('d-appendix'));
    });

    // show d-appendix if we have appendix content
    $("d-appendix").css('display', appendix ? 'grid' : 'none');

    // localize layout chunks to just output
    $('.layout-chunk').each(function(i, val) {

      // capture layout
      var layout = $(this).attr('data-layout');

      // apply layout to markdown level block elements
      var elements = $(this).children().not('details, div.sourceCode, pre, script');
      elements.each(function(i, el) {
        var layout_div = $('<div class="' + layout + '"></div>');
        if (layout_div.hasClass('shaded')) {
          var shaded_content = $('<div class="shaded-content"></div>');
          $(this).wrap(shaded_content);
          $(this).parent().wrap(layout_div);
        } else {
          $(this).wrap(layout_div);
        }
      });


      // unwrap the layout-chunk div
      $(this).children().unwrap();
    });

    // remove code block used to force  highlighting css
    $('.distill-force-highlighting-css').parent().remove();

    // remove empty line numbers inserted by pandoc when using a
    // custom syntax highlighting theme, except when numbering line
    // in code chunk
    $('pre:not(.numberLines) code.sourceCode a:empty').remove();

    // load distill framework
    load_distill_framework();

    // wait for window.distillRunlevel == 4 to do post processing
    function distill_post_process() {

      if (!window.distillRunlevel || window.distillRunlevel < 4)
        return;

      // hide author/affiliations entirely if we have no authors
      var front_matter = JSON.parse($("#distill-front-matter").html());
      var have_authors = front_matter.authors && front_matter.authors.length > 0;
      if (!have_authors)
        $('d-byline').addClass('hidden');

      // article with toc class
      $('.d-contents').parent().addClass('d-article-with-toc');

      // strip links that point to #
      $('.authors-affiliations').find('a[href="#"]').removeAttr('href');

      // add orcid ids
      $('.authors-affiliations').find('.author').each(function(i, el) {
        var orcid_id = front_matter.authors[i].orcidID;
        var author_name = front_matter.authors[i].author
        if (orcid_id) {
          var a = $('<a></a>');
          a.attr('href', 'https://orcid.org/' + orcid_id);
          var img = $('<img></img>');
          img.addClass('orcid-id');
          img.attr('alt', author_name ? 'ORCID ID for ' + author_name : 'ORCID ID');
          img.attr('src','data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg==');
          a.append(img);
          $(this).append(a);
        }
      });

      // hide elements of author/affiliations grid that have no value
      function hide_byline_column(caption) {
        $('d-byline').find('h3:contains("' + caption + '")').parent().css('visibility', 'hidden');
      }

      // affiliations
      var have_affiliations = false;
      for (var i = 0; i<front_matter.authors.length; ++i) {
        var author = front_matter.authors[i];
        if (author.affiliation !== "&nbsp;") {
          have_affiliations = true;
          break;
        }
      }
      if (!have_affiliations)
        $('d-byline').find('h3:contains("Affiliations")').css('visibility', 'hidden');

      // published date
      if (!front_matter.publishedDate)
        hide_byline_column("Published");

      // document object identifier
      var doi = $('d-byline').find('h3:contains("DOI")');
      var doi_p = doi.next().empty();
      if (!front_matter.doi) {
        // if we have a citation and valid citationText then link to that
        if ($('#citation').length > 0 && front_matter.citationText) {
          doi.html('Citation');
          $('<a href="#citation"></a>')
            .text(front_matter.citationText)
            .appendTo(doi_p);
        } else {
          hide_byline_column("DOI");
        }
      } else {
        $('<a></a>')
           .attr('href', "https://doi.org/" + front_matter.doi)
           .html(front_matter.doi)
           .appendTo(doi_p);
      }

       // change plural form of authors/affiliations
      if (front_matter.authors.length === 1) {
        var grid = $('.authors-affiliations');
        grid.children('h3:contains("Authors")').text('Author');
        grid.children('h3:contains("Affiliations")').text('Affiliation');
      }

      // remove d-appendix and d-footnote-list local styles
      $('d-appendix > style:first-child').remove();
      $('d-footnote-list > style:first-child').remove();

      // move appendix-bottom entries to the bottom
      $('.appendix-bottom').appendTo('d-appendix').children().unwrap();
      $('.appendix-bottom').remove();

      // hoverable references
      $('span.citation[data-cites]').each(function() {
        const citeChild = $(this).children()[0]
        // Do not process if @xyz has been used without escaping and without bibliography activated
        // https://github.com/rstudio/distill/issues/466
        if (citeChild === undefined) return true

        if (citeChild.nodeName == "D-FOOTNOTE") {
          var fn = citeChild
          $(this).html(fn.shadowRoot.querySelector("sup"))
          $(this).id = fn.id
          fn.remove()
        }
        var refs = $(this).attr('data-cites').split(" ");
        var refHtml = refs.map(function(ref) {
          // Could use CSS.escape too here, we insure backward compatibility in navigator
          return "<p>" + $('div[id="ref-' + ref + '"]').html() + "</p>";
        }).join("\n");
        window.tippy(this, {
          allowHTML: true,
          content: refHtml,
          maxWidth: 500,
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start'
        });
      });

      // fix footnotes in tables (#411)
      // replacing broken distill.pub feature
      $('table d-footnote').each(function() {
        // we replace internal showAtNode methode which is triggered when hovering a footnote
        this.hoverBox.showAtNode = function(node) {
          // ported from https://github.com/distillpub/template/pull/105/files
          calcOffset = function(elem) {
              let x = elem.offsetLeft;
              let y = elem.offsetTop;
              // Traverse upwards until an `absolute` element is found or `elem`
              // becomes null.
              while (elem = elem.offsetParent && elem.style.position != 'absolute') {
                  x += elem.offsetLeft;
                  y += elem.offsetTop;
              }

              return { left: x, top: y };
          }
          // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop
          const bbox = node.getBoundingClientRect();
          const offset = calcOffset(node);
          this.show([offset.left + bbox.width, offset.top + bbox.height]);
        }
      })

      // clear polling timer
      clearInterval(tid);

      // show body now that everything is ready
      on_load_complete();
    }

    var tid = setInterval(distill_post_process, 50);
    distill_post_process();

  }

  function init_downlevel() {

    init_common();

     // insert hr after d-title
    $('.d-title').after($('<hr class="section-separator"/>'));

    // check if we have authors
    var front_matter = JSON.parse($("#distill-front-matter").html());
    var have_authors = front_matter.authors && front_matter.authors.length > 0;

    // manage byline/border
    if (!have_authors)
      $('.d-byline').remove();
    $('.d-byline').after($('<hr class="section-separator"/>'));
    $('.d-byline a').remove();

    // remove toc
    $('.d-contents').remove();

    // move appendix elements
    $('h1.appendix, h2.appendix').each(function(i, val) {
      $(this).changeElementType('h3');
    });
    $('h3.appendix').each(function(i, val) {
      $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('.d-appendix'));
    });


    // inject headers into references and footnotes
    var refs_header = $('<h3></h3>');
    refs_header.text('References');
    $('#refs').prepend(refs_header);

    var footnotes_header = $('<h3></h3');
    footnotes_header.text('Footnotes');
    $('.footnotes').children('hr').first().replaceWith(footnotes_header);

    // move appendix-bottom entries to the bottom
    $('.appendix-bottom').appendTo('.d-appendix').children().unwrap();
    $('.appendix-bottom').remove();

    // remove appendix if it's empty
    if ($('.d-appendix').children().length === 0)
      $('.d-appendix').remove();

    // prepend separator above appendix
    $('.d-appendix').before($('<hr class="section-separator" style="clear: both"/>'));

    // trim code
    $('pre>code').each(function(i, val) {
      $(this).html($.trim($(this).html()));
    });

    // move posts-container right before article
    $('.posts-container').insertBefore($('.d-article'));

    $('body').addClass('downlevel');

    on_load_complete();
  }


  function init_common() {

    // jquery plugin to change element types
    (function($) {
      $.fn.changeElementType = function(newType) {
        var attrs = {};

        $.each(this[0].attributes, function(idx, attr) {
          attrs[attr.nodeName] = attr.nodeValue;
        });

        this.replaceWith(function() {
          return $("<" + newType + "/>", attrs).append($(this).contents());
        });
      };
    })(jQuery);

    // prevent underline for linked images
    $('a > img').parent().css({'border-bottom' : 'none'});

    // mark non-body figures created by knitr chunks as 100% width
    $('.layout-chunk').each(function(i, val) {
      var figures = $(this).find('img, .html-widget');
      // ignore leaflet img layers (#106)
      figures = figures.filter(':not(img[class*="leaflet"])')
      if ($(this).attr('data-layout') !== "l-body") {
        figures.css('width', '100%');
      } else {
        figures.css('max-width', '100%');
        figures.filter("[width]").each(function(i, val) {
          var fig = $(this);
          fig.css('width', fig.attr('width') + 'px');
        });

      }
    });

    // auto-append index.html to post-preview links in file: protocol
    // and in rstudio ide preview
    $('.post-preview').each(function(i, val) {
      if (window.location.protocol === "file:")
        $(this).attr('href', $(this).attr('href') + "index.html");
    });

    // get rid of index.html references in header
    if (window.location.protocol !== "file:") {
      $('.distill-site-header a[href]').each(function(i,val) {
        $(this).attr('href', $(this).attr('href').replace(/^index[.]html/, "./"));
      });
    }

    // add class to pandoc style tables
    $('tr.header').parent('thead').parent('table').addClass('pandoc-table');
    $('.kable-table').children('table').addClass('pandoc-table');

    // add figcaption style to table captions
    $('caption').parent('table').addClass("figcaption");

    // initialize posts list
    if (window.init_posts_list)
      window.init_posts_list();

    // implmement disqus comment link
    $('.disqus-comment-count').click(function() {
      window.headroom_prevent_pin = true;
      $('#disqus_thread').toggleClass('hidden');
      if (!$('#disqus_thread').hasClass('hidden')) {
        var offset = $(this).offset();
        $(window).resize();
        $('html, body').animate({
          scrollTop: offset.top - 35
        });
      }
    });
  }

  document.addEventListener('DOMContentLoaded', function() {
    if (is_downlevel_browser())
      init_downlevel();
    else
      window.addEventListener('WebComponentsReady', init_distill);
  });

  </script>

  <!--/radix_placeholder_distill-->
  <script src="RJ-2025-033_files/header-attrs-2.30/header-attrs.js"></script>
  <script src="RJ-2025-033_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
  <script src="RJ-2025-033_files/popper-2.6.0/popper.min.js"></script>
  <link href="RJ-2025-033_files/tippy-6.2.7/tippy.css" rel="stylesheet" />
  <link href="RJ-2025-033_files/tippy-6.2.7/tippy-light-border.css" rel="stylesheet" />
  <script src="RJ-2025-033_files/tippy-6.2.7/tippy.umd.min.js"></script>
  <script src="RJ-2025-033_files/anchor-4.2.2/anchor.min.js"></script>
  <script src="RJ-2025-033_files/bowser-1.9.3/bowser.min.js"></script>
  <script src="RJ-2025-033_files/webcomponents-2.0.0/webcomponents.js"></script>
  <script src="RJ-2025-033_files/distill-2.2.21/template.v2.js"></script>
  <!--radix_placeholder_site_in_header-->
  <!--/radix_placeholder_site_in_header-->
  <script>
    $(function() {
      console.log("Starting...")

      // Mathjax config (add automatic linebreaks when supported)
      // MathJax = {
      //    tex: {
      //        inlineMath: [['$', '$'], ['\\(', '\\)']],
      //        displayMath: [['$$', '$$'], ['\\[', '\\]']],
      //        tags: 'ams',
      //        multline: true,
      //    },
      //    options: {
      //        linebreaks: { automatic: true },
      //    },
      // };

      // Always show Published - distill hides it if not set
      function show_byline_column(caption) {
        $('d-byline').find('h3:contains("' + caption + '")').parent().css('visibility', 'visible');
      }

      show_byline_column('Published')

      // tweak function
      var rmd_meta = JSON.parse($("#radix-rmarkdown-metadata").html());
      function get_meta(name, meta) {
        var ind = meta.attributes.names.value.findIndex((e) => e == name)
        var val = meta.value[ind]
        if (val.type != 'list') {
          return val.value.toString()
        }
        return val
      }

      // tweak description
      // Add clickable tags
      const slug = get_meta('slug', rmd_meta)
      const cite_url = get_meta('citation_url', rmd_meta)

      var title = $("d-title").text

      const buttons = $('<div class="dt-tags" style="grid-column: page;">')
      buttons.append('<a href="#citation" class="dt-tag"><i class="fas fa-quote-left"></i> Cite</a>')
      buttons.append('<a href="' + slug + '.pdf" class="dt-tag"><i class="fas fa-file-pdf"></i> PDF</a>')
      
      // Conditionally add supplementary files button
      if (document.getElementById('supplementary-materials')) {
        // create element safely
        const btn_suppl = document.createElement('a');
        btn_suppl.href = slug + '.zip';
        btn_suppl.className = 'dt-tag';
        btn_suppl.innerHTML = '<i class="fas fa-file-zipper"></i> Supplement';
        buttons.append(btn_suppl);
      }

      // adds Abstract: in front of the first <p> in the title section --
      // unless it happens to be the subtitle (FIXME: this is a bad hack - can't distill do this?)
      var tpar = $("d-title p:not(:empty)").filter(function() {
        return !$(this).hasClass("subtitle");
      }).first();
      if (tpar) {
        const abstract = $('<d-abstract>')
        abstract.append('<b>Abstract:</b><br>')
        abstract.append(tpar) // Move description to d-abstract
        $("d-title p:empty").remove() // Remove empty paragraphs after title
        abstract.append(buttons)
        abstract.insertAfter($('d-title')) // Add abstract section after title */
      }

      // tweak by-line
      var byline = $("d-byline div.byline")
      ind = rmd_meta.attributes.names.value.findIndex((e) => e == "journal")
      const journal = get_meta('journal', rmd_meta)
      const volume = get_meta('volume', rmd_meta)
      const issue = get_meta('issue', rmd_meta)
      const jrtitle = get_meta('title', journal)
      const year = ((jrtitle == "R News") ? 2000 : 2008) + parseInt(volume)
      const firstpage = get_meta('firstpage', journal)
      const lastpage = get_meta('lastpage', journal)
      byline.append('<div class="rjournal grid">')
      $('div.rjournal').append('<h3>Volume</h3>')
      $('div.rjournal').append('<h3>Pages</h3>')
      $('div.rjournal').append('<a class="volume" href="../../issues/'+year+'-'+issue+'">'+volume+'/'+issue+'</a>')
      $('div.rjournal').append('<p class="pages">'+firstpage+' - '+lastpage+'</p>')

      const received_date = new Date(get_meta('date_received', rmd_meta))
      byline.find('h3:contains("Published")').parent().append('<h3>Received</h3><p>'+received_date.toLocaleDateString('en-US', {month: 'short'})+' '+received_date.getDate()+', '+received_date.getFullYear()+'</p>')

    })
  </script>

  <style>
      /*
    .nav-dropdown-content .nav-dropdown-header {
      text-transform: lowercase;
    }
    */

    d-byline .byline {
      grid-template-columns: 2fr 2fr 2fr 2fr;
    }

    d-byline .rjournal {
      grid-column-end: span 2;
      grid-template-columns: 1fr 1fr;
      margin-bottom: 0;
    }

    d-title h1, d-title p, d-title figure,
    d-abstract p, d-abstract b {
      grid-column: page;
    }

    d-title .dt-tags {
      grid-column: page;
    }

    .dt-tags .dt-tag {
      text-transform: lowercase;
    }

    d-article h1 {
      line-height: 1.1em;
    }

    d-abstract p, d-article p {
      text-align: justify;
    }

    @media(min-width: 1000px) {
      .d-contents.d-contents-float {
        justify-self: end;
      }

      nav.toc {
        border-right: 1px solid rgba(0, 0, 0, 0.1);
        border-right-width: 1px;
        border-right-style: solid;
        border-right-color: rgba(0, 0, 0, 0.1);
      }
    }

    .posts-list .dt-tags .dt-tag {
      text-transform: lowercase;
    }

    @keyframes highlight-target {
      0% {
        background-color: #ffa;
      }
      66% {
        background-color: #ffa;
      }
      100% {
        background-color: none;
      }
    }

    d-article :target, d-appendix :target {
       animation: highlight-target 3s;
    }

    .header-section-number {
      margin-right: 0.5em;
    }
    
    d-appendix .citation-appendix,
    .d-appendix .citation-appendix {
      color: rgb(60, 60, 60);
    }

    d-article h2 {
      border-bottom: 0px solid rgba(0, 0, 0, 0.1);
      padding-bottom: 0rem;
    }
    d-article h3 {
      font-size: 20px;
    }
    d-article h4 {
      font-size: 18px;
      text-transform: none;
    }

    @media (min-width: 1024px) {
      d-article h2 {
        font-size: 32px;
      }
      d-article h3 {
        font-size: 24px;
      }
      d-article h4 {
        font-size: 20px;
      }
    }
  </style>


</head>

<body>

<!--radix_placeholder_front_matter-->

<script id="distill-front-matter" type="text/json">
{"title":"LHD: An All-encompassing R Package for Constructing Optimal Latin Hypercube Designs","description":"Optimal Latin hypercube designs (LHDs), including maximin distance\nLHDs, maximum projection LHDs and orthogonal LHDs, are widely used in\ncomputer experiments. It is challenging to construct such designs with\nflexible sizes, especially for large ones, for two main reasons. One\nreason is that theoretical results, such as algebraic constructions\nensuring the maximin distance property or orthogonality, are only\navailable for certain design sizes. For design sizes where theoretical\nresults are unavailable, search algorithms can generate designs.\nHowever, their numerical performance is not guaranteed to be optimal.\nAnother reason is that when design sizes increase, the number of\npermutations grows exponentially. Constructing optimal LHDs is a\ndiscrete optimization process, and enumeration is nearly impossible\nfor large or moderate design sizes. Various search algorithms and\nalgebraic constructions have been proposed to identify optimal LHDs,\neach having its own pros and cons. We develop the R package `LHD` [^1]\nwhich implements various search algorithms and algebraic\nconstructions. We embedded different optimality criteria into each of\nthe search algorithms, and they are capable of constructing different\ntypes of optimal LHDs even though they were originally invented to\nconstruct maximin distance LHDs only. Another input argument that\ncontrols maximum CPU time is added to each of the search algorithms to\nlet users flexibly allocate their computational resources. We\ndemonstrate functionalities of the package by using various examples,\nand we provide guidance for experimenters on finding suitable optimal\ndesigns. The `LHD` package is easy to use for practitioners and\npossibly serves as a benchmark for future developments in LHD.","doi":"10.32614/RJ-2025-033","authors":[{"author":"Hongzhi Wang","authorURL":"#","affiliation":"&nbsp;","affiliationURL":"#","orcidID":""},{"author":"Qian Xiao","authorURL":"#","affiliation":"Shanghai Jiao Tong University","affiliationURL":"#","orcidID":""},{"author":"Abhyuday Mandal","authorURL":"#","affiliation":"University of Georgia","affiliationURL":"#","orcidID":""}],"publishedDate":"2026-01-05T00:00:00.000+11:00","citationText":"Wang, et al., 2026"}
</script>

<!--/radix_placeholder_front_matter-->
<!--radix_placeholder_navigation_before_body-->
<!--/radix_placeholder_navigation_before_body-->
<!--radix_placeholder_site_before_body-->
<!--/radix_placeholder_site_before_body-->

<div class="d-title">
<h1>LHD: An All-encompassing R Package for Constructing Optimal Latin Hypercube Designs</h1>

<!--radix_placeholder_categories-->
<!--/radix_placeholder_categories-->
<p><p>Optimal Latin hypercube designs (LHDs), including maximin distance
LHDs, maximum projection LHDs and orthogonal LHDs, are widely used in
computer experiments. It is challenging to construct such designs with
flexible sizes, especially for large ones, for two main reasons. One
reason is that theoretical results, such as algebraic constructions
ensuring the maximin distance property or orthogonality, are only
available for certain design sizes. For design sizes where theoretical
results are unavailable, search algorithms can generate designs.
However, their numerical performance is not guaranteed to be optimal.
Another reason is that when design sizes increase, the number of
permutations grows exponentially. Constructing optimal LHDs is a
discrete optimization process, and enumeration is nearly impossible
for large or moderate design sizes. Various search algorithms and
algebraic constructions have been proposed to identify optimal LHDs,
each having its own pros and cons. We develop the R package <code>LHD</code> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
which implements various search algorithms and algebraic
constructions. We embedded different optimality criteria into each of
the search algorithms, and they are capable of constructing different
types of optimal LHDs even though they were originally invented to
construct maximin distance LHDs only. Another input argument that
controls maximum CPU time is added to each of the search algorithms to
let users flexibly allocate their computational resources. We
demonstrate functionalities of the package by using various examples,
and we provide guidance for experimenters on finding suitable optimal
designs. The <code>LHD</code> package is easy to use for practitioners and
possibly serves as a benchmark for future developments in LHD.</p></p>
</div>

<div class="d-byline">
  Hongzhi Wang  
  
,   Qian Xiao  (Shanghai Jiao Tong University)
  
,   Abhyuday Mandal  (University of Georgia)
  
<br/>2026-01-05
</div>

<div class="d-article">
<div class="article">
<h3 data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction</h3>
<p>Computer experiments are widely used in scientific research and
industrial production, where complex computer codes, commonly
high-fidelity simulators, generate data instead of real physical systems
(Sacks et al.1989; Fang et al.2005). The outputs from computer
experiments are deterministic (that is, free of random errors), and
therefore replications are not needed (Butler 2001; Joseph and Hung
2008; Ba et al.2015). Latin hypercube designs (LHDs, (McKay et al.
1979)) may be the most popular type of experimental designs for computer
experiments (Fang et al.2005; Xiao and Xu 2018), which avoid
replications on every dimension and have uniform one-dimensional
projections. According to practical needs, there are various types of
optimal LHDs, including space-filling LHDs, maximum projection LHDs, and
orthogonal LHDs. There is a rich literature on the construction of such
designs, but it is still very challenging to find good ones for moderate
to large design sizes (Ye 1998; Fang et al.2005; Joseph et al.2015;
Xiao and Xu 2018). One key reason is that theoretical results, such as
algebraic constructions which guarantee the maximin distance property or
orthogonality, are only established for specific design sizes. These
constructions provide theoretical guarantees on the design quality but
are limited in their applicability. For design sizes where such
theoretical guarantees do not exist, search algorithms can generate
designs. However, the performance of search-based designs depends on the
algorithm employed, the search space explored, and the computational
resources allocated, meaning they cannot be guaranteed to be optimal.
Constructing optimal LHDs is a discrete optimization process, where
enumerating all possible solutions guarantees the optimal design for a
given size. However, this approach becomes computationally infeasible as
the number of permutations grows exponentially with increasing design
sizes, making it another key reason that adds to the challenge.</p>
<p>An LHD with <span class="math inline">\(n\)</span> runs and <span class="math inline">\(k\)</span> factors is an <span class="math inline">\(n \times k\)</span> matrix with each
column being a random permutation of numbers: <span class="math inline">\(1, \ldots, n\)</span>. Throughout
this paper, <span class="math inline">\(n\)</span> denotes the run size and <span class="math inline">\(k\)</span> denotes the factor size. A
space-filling LHD has its sampled region as scattered as possible,
minimizing the unsampled region, thus accounting for the uniformity of
all dimensions. Different criteria were proposed to measure designs
space-filling properties, including the maximin and minimax distance
criteria (Johnson et al.1990; Morris and Mitchell 1995), the
discrepancy criteria (Hickernell 1998; Fang et al.2002, 2005) and the
entropy criterion (Shewry and Wynn 1987). Since there are as many as
<span class="math inline">\((n!)^{k}\)</span> candidate LHDs for a given design size, it is nearly
impossible to find the space-filling one by enumeration when <span class="math inline">\(n\)</span> and <span class="math inline">\(k\)</span>
are moderate or large. In the current literature, both the search
algorithms (Morris and Mitchell 1995; Leary et al.2003; Joseph and Hung
2008; Ba et al.2015; Ye et al.2000; Jin et al.2005; Liefvendahl and
Stocki 2006; Grosso et al.2009; Chen et al.2013) and algebraic
constructions (Zhou and Xu 2015; Xiao and Xu 2017; Wang et al.2018) are
used to construct space-filling LHDs.</p>
<p>Space-filling designs often focus on the full-dimensional space. To
further improve the space-filling properties of all possible sub-spaces,
(Joseph et al.2015) proposed to use the maximum projection designs.
Considering from two to <span class="math inline">\(k-1\)</span> dimensional sub-spaces, maximum projection
LHDs (MaxPro LHDs) are generally more space-filling compared to the
classic maximin distance LHDs. The construction of MaxPro LHDs is also
challenging, especially for large ones, and (Joseph et al.2015)
proposed a simulated annealing (SA) based algorithm. In the <code>LHD</code>
package, we incorporated the MaxPro criterion with other different
algorithms such as the particle swarm optimization (PSO) and genetic
algorithm (GA) framework, leading to many better MaxPro LHDs; see
Section 3 for examples.</p>
<p>Unlike space-filling LHDs that minimize the similarities among rows,
orthogonal LHDs (OLHDs) are another popular type of optimal design which
consider similarities among columns. For example, OLHDs have zero
column-wise correlations. Algebraic constructions are available for
certain design sizes (Ye 1998; Cioppa and Lucas 2007; Steinberg and Lin
2006; Sun et al.2010, 2009; Yang and Liu 2012; Georgiou and Efthimiou
2014; Butler 2001; Tang 1993; Lin et al.2009), but there are many
design sizes where theoretical results are not available. In the <code>LHD</code>
package, we implemented the average absolute correlation criterion and
the maximum absolute correlation criterion (Georgiou 2009) with SA, PSO,
and GA to identify both OLHDs and nearly orthogonal LHDs (NOLHDs) for
almost all design sizes.</p>
<p>This paper introduces the R package <code>LHD</code> available on the Comprehensive
R Archive Network
(<a href="https://cran.r-project.org/web/packages/LHD/index.html" class="uri">https://cran.r-project.org/web/packages/LHD/index.html</a>), which
implements some currently popular search algorithms and algebraic
constructions for constructing maximin distance LHDs, Maxpro LHDs, OLHDs
and NOLHDs. We embedded different optimality criteria including the
maximin distance criterion, the MaxPro criterion, the average absolute
correlation criterion, and the maximum absolute correlation criterion in
each of the search algorithms which were originally invented to
construct maximin distance LHDs only (Morris and Mitchell 1995; Leary et
al.2003; Joseph and Hung 2008; Liefvendahl and Stocki 2006; Chen et al.
2013), and each of them is capable of constructing different types of
optimal LHDs through the package. To let users flexibly allocate their
computational resources, we also embedded an input argument that limits
the maximum CPU time for each of the algorithms, where users can easily
define how and when they want the algorithms to stop. An algorithm can
stop in one of two ways: either when the user-defined maximum number of
iterations is reached or when the user-defined maximum CPU time is
exceeded. For example, users can either allow the algorithm to run for a
specified number of iterations without restricting the maximum CPU time
or set a maximum CPU time limit to stop the algorithm regardless of the
number of iterations completed. After an algorithm is completed or
stopped, the number of iterations completed along with the average CPU
time per iteration will be presented to users for their information. The
R package <code>LHD</code> is an integrated tool for users with little or no
background in design theory, and they can easily find optimal LHDs with
desired sizes. Many new designs that are better than the existing ones
are discovered; see Section 3.</p>
<p>The remainder of the paper is organized as follows. Section 2
illustrates different optimality criteria for LHDs. Section 3
demonstrates some popular search algorithms and their implementation
details in the <code>LHD</code> package along with examples. Section 4 discusses
some useful algebraic constructions as well as examples of how to
implement them via the developed package. Section 5 concludes with a
summary.</p>
<h3 data-number="2" id="OC"><span class="header-section-number">2</span> Optimality Criteria for LHDs</h3>
<p>Various criteria are proposed to measure designs space-filling
properties (Johnson et al.1990; Hickernell 1998; Fang et al.2002). In
this paper, we focus on the currently popular maximin distance criterion
(Johnson et al.1990), which seeks to scatter design points over
experimental domains so that the minimum distances between points are
maximized. Let <span class="math inline">\(\textbf{X}\)</span> denote an LHD matrix throughout this paper.
Define the <span class="math inline">\(L_q\)</span>-distance between two runs <span class="math inline">\(x_i\)</span> and <span class="math inline">\(x_j\)</span> of
<span class="math inline">\(\textbf{X}\)</span> as
<span class="math inline">\(d_q(x_i, x_j) =  \left\{ \sum_{m=1}^{k} \vert x_{im}-x_{jm}\vert ^q \right\}^{1/q}\)</span>
where <span class="math inline">\(q\)</span> is an integer. Define the <span class="math inline">\(L_q\)</span> distance of the design
<span class="math inline">\(\textbf{X}\)</span> as
<span class="math inline">\(d_q(\textbf{X}) = \text{min} \{d_q(x_i, x_j),  1 \leq i&lt;j \leq n \}\)</span>.
In this paper, we consider <span class="math inline">\(q=1\)</span> and <span class="math inline">\(q=2\)</span>, i.e.the Manhattan (<span class="math inline">\(L_1\)</span>)
and Euclidean (<span class="math inline">\(L_2\)</span>) distances. A design <span class="math inline">\(\textbf{X}\)</span> is called a
maximin <span class="math inline">\(L_q\)</span> distance design if it has the unique largest
<span class="math inline">\(d_q(\textbf{X})\)</span> value among all designs of the same size. When more
than one design has the same largest <span class="math inline">\(d_q(\textbf{X})\)</span>, the maximin
distance design sequentially maximizes the next minimum inter-site
distances. To evaluate the maximin distance criterion in a more
convenient way, (Morris and Mitchell 1995) and (Jin et al.2005)
proposed to minimize a scalar value:
<span class="math display" id="eq:E2">\[\begin{equation}
\label{E2}
    \phi_{p}= \bigg\{\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}d_q(x_i, x_j)^{-p} \bigg\} ^{1/p},
\end{equation}   \tag{1}\]</span>
where <span class="math inline">\(p\)</span> is a tuning parameter. This <span class="math inline">\(\phi_{p}\)</span> criterion in
Equation<a href="#eq:E2">(1)</a> is asymptotically equivalent to the Maximin
distance criterion as <span class="math inline">\(p \to \infty\)</span>. In practice, <span class="math inline">\(p=15\)</span> often suffices
(Morris and Mitchell 1995). In the <code>LHD</code> package, the function <code>phi_p()</code>
implements this criterion.</p>
<p>Maximin distance LHDs focus on the space-filling properties in the
full-dimensional space, but their space-filling properties in the
subspaces are not guaranteed. (Joseph et al.2015) proposed the maximum
projection criterion that considers designs space-filling properties in
all possible dimensional spaces. An LHD <span class="math inline">\(\textbf{X}\)</span> is called a maximum
projection LHD (MaxPro LHD) if it minimizes the maximum projection
criterion such that
<span class="math display" id="eq:E3">\[\begin{equation}
\label{E3}
    \mathop{\mathrm{min}}\limits_{\textbf{X}} \psi (\textbf{X}) = \Bigg\{ \frac{1}{{n \choose 2}} \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} \frac{1}{\Pi_{l=1}^{k}(x_{il}-x_{jl})^2}  \Bigg\}^{1/k}.
\end{equation}   \tag{2}\]</span>
From Equation<a href="#eq:E3">(2)</a>, we can see that any two design points should
be apart from each other in any projection to minimize the value of
<span class="math inline">\(\psi (\textbf{X})\)</span>. Thus, the maximum projection LHDs consider the
space-filling properties in all possible subspaces. Note that this
criterion was originally defined using design points scaled to the unit
hypercube <span class="math inline">\([0,1]^{k}\)</span> in (Joseph et al.2015), whereas our design points
are represented as integer levels. A simple transformation can be
applied to revert the scaling. For example, the transformation
<span class="math inline">\(\textbf{X}_{Scaled}*n-0.5\)</span>, can be applied, meaning that each element
of every design point in scaled unit hypercube is multiplied by its run
size <span class="math inline">\(n\)</span> and then adding <span class="math inline">\(0.5\)</span>. The illustrative example at the end of
Section 3 applies this transformation to ensure a fair comparison of
performance. In the <code>LHD</code> package, the function <code>MaxProCriterion()</code>
implements this criterion.</p>
<p>Orthogonal and nearly orthogonal designs that aim to minimize the
correlations between factors are widely used in experiments (Georgiou
2009; Steinberg and Lin 2006; Sun and Tang 2017). Two major
correlation-based criteria to measure designs orthogonality are the
average absolute correlation criterion and the maximum absolute
correlation criterion (Georgiou 2009), denoted as ave<span class="math inline">\((|q|)\)</span> and
max<span class="math inline">\(|q|\)</span>, respectively:
<span class="math display" id="eq:E4">\[\begin{equation}
\label{E4}
    \mathop{\mathrm{ave}}\limits(|q|) = \frac{2 \sum_{i=1}^{k-1} \sum_{j=i+1}^{k}|q_{ij}|}{k(k-1)} \text{ and } \mathop{\mathrm{max}}\limits|q| =  \mathop{\mathrm{max}}\limits_{i,j} |q_{ij}|,
\end{equation}   \tag{3}\]</span>
where <span class="math inline">\(q_{ij}\)</span> is the correlation between the <span class="math inline">\(i\)</span>th and <span class="math inline">\(j\)</span>th columns of
the design matrix <span class="math inline">\(\textbf{X}\)</span>. Orthogonal designs have ave<span class="math inline">\((|q|)=0\)</span> and
max<span class="math inline">\(|q|=0\)</span>, which may not exist for all design sizes. Designs with a
smaller ave<span class="math inline">\((|q|)\)</span> or max<span class="math inline">\(|q|\)</span> are generally preferred in practice. In
the <code>LHD</code> package, functions <code>AvgAbsCor()</code> and <code>MaxAbsCor()</code> implement
the criteria ave<span class="math inline">\((|q|)\)</span> and max<span class="math inline">\(|q|\)</span>, respectively.</p>
<h4 class="unnumbered" data-number="2.1" id="illustrating-examples-for-the-introduced-optimality-criteria">Illustrating Examples for the Introduced Optimality Criteria</h4>
<p>This subsection demonstrates some examples of how to use the optimality
criteria introduced above from the developed <code>LHD</code> package. To generate
a random LHD matrix, the function <code>rLHD</code> can be used. For example,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> X <span class="ot">=</span> <span class="fu">rLHD</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">k =</span> <span class="dv">3</span>); X  <span class="co">#This generates a 5 by 3 random LHD, denoted as X</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>] [,<span class="dv">2</span>] [,<span class="dv">3</span>]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">2</span>    <span class="dv">1</span>    <span class="dv">4</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">4</span>    <span class="dv">3</span>    <span class="dv">3</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">3</span>    <span class="dv">2</span>    <span class="dv">2</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">1</span>    <span class="dv">4</span>    <span class="dv">5</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">5</span>    <span class="dv">5</span>    <span class="dv">1</span> </span></code></pre></div>
<p>The input arguments for the function <code>rLHD</code> are the run-size <code>n</code> and the
factor size <code>k</code>. Continuing with the above randomly generated LHD X, we
evaluate it with respect to different optimality criteria. For example,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">phi_p</span>(X)             <span class="co">#The maximin L1-distance criterion.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="fl">0.3336608</span>          </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">phi_p</span>(X, <span class="at">p =</span> <span class="dv">10</span>, <span class="at">q =</span> <span class="dv">2</span>)    <span class="co">#The maximin L2-distance criterion.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="fl">0.5797347</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">MaxProCriterion</span>(X)   <span class="co">#The maximum projection criterion.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="fl">0.5375482</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">AvgAbsCor</span>(X)         <span class="co">#The average absolute correlation criterion.</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="fl">0.5333333</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">MaxAbsCor</span>(X)         <span class="co">#The maximum absolute correlation criterion.</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="fl">0.9</span></span></code></pre></div>
<p>The input arguments of the function <code>phi_p</code> are an LHD matrix <code>X</code>, <code>p</code>
and <code>q</code>, where <code>p</code> and <code>q</code> come directly from the equation<a href="#eq:E2">(1)</a>.
Note that the default settings within function <code>phi_p</code> are <span class="math inline">\(p=15\)</span> and
<span class="math inline">\(q=1\)</span> (the Manhattan distance) and user can change the settings. For
functions <code>MaxProCriterion</code>, <code>AvgAbsCor</code>, and <code>MaxAbsCor</code>, there is only
one input argument, which is an LHD matrix <code>X</code>.</p>
<h3 data-number="3" id="Algs"><span class="header-section-number">3</span> Search Algorithms for Optimal LHDs with Flexible Sizes</h3>
<h4 class="unnumbered" data-number="3.1" id="simulated-annealing-based-algorithms">Simulated Annealing Based Algorithms</h4>
<p>Simulated annealing (SA, (Kirkpatrick et al.1983)) is a probabilistic
optimization algorithm, whose name comes from the phenomenon of the
annealing process in metallurgy. (Morris and Mitchell 1995) proposed a
modified SA that randomly exchanges the elements in LHD to seek
potential improvements. If such an exchange leads to a better LHD under
a given optimality criterion, the exchange is maintained. Otherwise, it
is kept with a probability of
<span class="math inline">\(\hbox{exp}[-(\Phi(\textbf{X}_{new})-\Phi(\textbf{X}))/T]\)</span>, where <span class="math inline">\(\Phi\)</span>
is a given optimality criterion, <span class="math inline">\(\textbf{X}\)</span> is the original LHD,
<span class="math inline">\(\textbf{X}_{new}\)</span> is the LHD after the exchange and <span class="math inline">\(T\)</span> is the current
temperature. In this article, we focus on minimizing the optimality
criteria outlined in Section 2, meaning only minimization optimization
problems are considered. Such probability guarantees that the exchange
that leads to a slightly worse LHD has a higher chance of being kept
than the exchange that leads to a significantly worse LHD, because an
exchange which leads to a slightly worse LHD has a lower value of
<span class="math inline">\(\Phi(\textbf{X}_{new})-\Phi(\textbf{X})\)</span>. Such an exchange procedure
will be implemented iteratively to improve LHD. When there are no
improvements after certain attempts, the current temperature <span class="math inline">\(T\)</span> is
annealed. Note that a large value of
<span class="math inline">\(\Phi(\textbf{X}_{new})-\Phi(\textbf{X})\)</span> (exchange leading to a
significantly worse LHD) is more likely to remain during the early phase
of the search process when <span class="math inline">\(T\)</span> is relatively high, and it is less likely
to stay later when <span class="math inline">\(T\)</span> decreases (annealed). The best LHD is identified
after the algorithm converges or the budget constraint is reached. In
the <code>LHD</code> package, the function <code>SA()</code> implements this algorithm:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">SA</span>(n, k, <span class="at">N =</span> <span class="dv">10</span>, <span class="at">T0 =</span> <span class="dv">10</span>, <span class="at">rate =</span> <span class="fl">0.1</span>, <span class="at">Tmin =</span> <span class="dv">1</span>, <span class="at">Imax =</span> <span class="dv">5</span>, <span class="at">OC =</span> <span class="st">&quot;phi_p&quot;</span>, </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="at">p =</span> <span class="dv">15</span>, <span class="at">q =</span> <span class="dv">1</span>, <span class="at">maxtime =</span> <span class="dv">5</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>Table<a href="#tab:T1" data-reference-type="ref" data-reference="T1">1</a> provides an
overview of all the input arguments in <code>SA()</code>. <code>n</code> and <code>k</code> are the
desired run size and factor size. <code>T0</code> is an initial temperature, <code>rate</code>
is the temperature decreasing rate, and <code>Tmin</code> is the minimum
temperature. If the current temperature is smaller than <code>Tmin</code>, the
current loop in the algorithm will stop and the current number of
iterations will increase by one. There are two stopping criteria for the
entire function: when the current number of iterations reaches the
maximum (denoted as <code>N</code> in the function) or when the cumulative CPU time
reaches the maximum (denoted as <code>maxtime</code> in the function),
respectively. Either of those will trigger the stop of the function,
whichever is earlier. For input argument <code>OC</code> (optimality criterion),
phi_p" returns maximin distance LHDs,MaxProCriterion" returns
MaxPro LHDs, and AvgAbsCor" orMaxAbsCor" returns orthogonal LHDs.</p>
<div class="center">
<div id="T1">
<table style="width:98%;">
<caption><span id="tab:T1">Table 1: </span> Overview of Input Arguments of the <code>SA</code> Function</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Argument</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>n</code></td>
<td style="text-align: left;">A positive integer that defines the number of rows (or run size) of output LHD.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>k</code></td>
<td style="text-align: left;">A positive integer that defines the number of columns (or factor size) of output LHD.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>N</code></td>
<td style="text-align: left;">A positive integer that defines the maximum number of iterations in the algorithm.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">A large value of <code>N</code> will result in a high CPU time, and it is recommended to be no</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">greater than 500. The default is set to be 10.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>T0</code></td>
<td style="text-align: left;">A positive number that defines the initial temperature. The default is set to be 10,</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">which means the temperature anneals from 10 in the algorithm.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>rate</code></td>
<td style="text-align: left;">A positive percentage that defines the temperature decrease rate, and it should be</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">in (0,1). For example, rate=0.25 means the temperature decreases by 25% each time.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">The default is set to be 10%.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Tmin</code></td>
<td style="text-align: left;">A positive number that defines the minimum temperature allowed. When current</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">temperature becomes smaller or equal to <code>Tmin</code>, the stopping criterion for current</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">loop is met. The default is set to be 1.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Imax</code></td>
<td style="text-align: left;">A positive integer that defines the maximum perturbations the algorithm will try</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">without improvements before temperature is reduced. The default is set to be 5.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">For CPU time consideration, <code>Imax</code> is recommended to be no greater than 5.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>OC</code></td>
<td style="text-align: left;">An optimality criterion. The default setting is phi_p", and it could be one of</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">the following: phi_p",AvgAbsCor", MaxAbsCor",MaxProCriterion".</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>p</code></td>
<td style="text-align: left;">A positive integer, which is one parameter in the <span class="math inline">\(\phi_{p}\)</span> formula, and <code>p</code> is preferred</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">to be large. The default is set to be 15.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>q</code></td>
<td style="text-align: left;">A positive integer, which is one parameter in the <span class="math inline">\(\phi_{p}\)</span> formula, and <code>q</code> could be</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">either 1 or 2. If <code>q</code> is 1, the Manhattan (rectangular) distance will be calculated.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">If <code>q</code> is 2, the Euclidean distance will be calculated.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>maxtime</code></td>
<td style="text-align: left;">A positive number, which indicates the expected maximum CPU time, and it is</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">measured by minutes. For example, <code>maxtime</code>=3.5 indicates the CPU time will</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">be no greater than three and a half minutes. The default is set to be 5.</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>(Leary et al.2003) modified the SA algorithm in (Morris and Mitchell
1995) to search for optimal orthogonal array-based LHDs (OALHDs). (Tang
1993) showed that OALHDs tend to have better space-filling properties
than random LHDs. The SA in (Leary et al.2003) starts with a random
OALHD rather than a random LHD. The remaining steps are the same as the
SA in (Morris and Mitchell 1995). Note that the existence of OALHDs is
determined by the existence of the corresponding initial OAs. In the
<code>LHD</code> package, the function <code>OASA()</code> implements the modified SA
algorithm.:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">OASA</span>(OA, <span class="at">N =</span> <span class="dv">10</span>, <span class="at">T0 =</span> <span class="dv">10</span>, <span class="at">rate =</span> <span class="fl">0.1</span>, <span class="at">Tmin =</span> <span class="dv">1</span>, <span class="at">Imax =</span> <span class="dv">5</span>, <span class="at">OC =</span> <span class="st">&quot;phi_p&quot;</span>, </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="at">p =</span> <span class="dv">15</span>, <span class="at">q =</span> <span class="dv">1</span>, <span class="at">maxtime =</span> <span class="dv">5</span>),</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>where all the input arguments are the same as in <code>SA</code> except that <code>OA</code>
must be an orthogonal array.</p>
<p>(Joseph and Hung 2008) proposed another modified SA to identify the
orthogonal-maximin LHDs, which considers both the orthogonality and the
maximin distance criteria. The algorithm starts with generating a random
LHD and then chooses the column that has the largest average pairwise
correlations with all other columns. Next, the algorithm will select the
row which has the largest total row-wise distance with all other rows.
Then, the element at the selected row and column will be exchanged with
a random element from the same column. The remaining steps are the same
as the SA in (Morris and Mitchell 1995). In the <code>LHD</code> package, the
function <code>SA2008()</code> implements this algorithm:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">SA2008</span>(n, k, <span class="at">N =</span> <span class="dv">10</span>, <span class="at">T0 =</span> <span class="dv">10</span>, <span class="at">rate =</span> <span class="fl">0.1</span>, <span class="at">Tmin =</span> <span class="dv">1</span>, <span class="at">Imax =</span> <span class="dv">5</span>, <span class="at">OC =</span> <span class="st">&quot;phi_p&quot;</span>, </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="at">p =</span> <span class="dv">15</span>, <span class="at">q =</span> <span class="dv">1</span>, <span class="at">maxtime =</span> <span class="dv">5</span>),</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>where all the input arguments are the same as in <code>SA</code>.</p>
<h4 class="unnumbered" data-number="3.2" id="particle-swarm-optimization-algorithms">Particle Swarm Optimization Algorithms</h4>
<p>Particle swarm optimization (PSO, (Kennedy and Eberhart 1995)) is a
metaheuristic optimization algorithm inspired by the social behaviors of
animals. Recent research (Chen et al.2013) adapted the classic PSO
algorithm and proposed LaPSO to identify maximin distance LHDs. Since
this is a discrete optimization task, LaPSO redefines the steps in which
each particle updates its velocity and position in the general PSO
framework. In the <code>LHD</code> package, the function <code>LaPSO()</code> implements this
algorithm:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">LaPSO</span>(n, k, <span class="at">m =</span> <span class="dv">10</span>, <span class="at">N =</span> <span class="dv">10</span>, <span class="at">SameNumP =</span> <span class="dv">0</span>, <span class="at">SameNumG =</span> n<span class="sc">/</span><span class="dv">4</span>, <span class="at">p0 =</span> <span class="dv">1</span><span class="sc">/</span>(k <span class="sc">-</span> <span class="dv">1</span>), </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="at">OC =</span> <span class="st">&quot;phi_p&quot;</span>, <span class="at">p =</span> <span class="dv">15</span>, <span class="at">q =</span> <span class="dv">1</span>, <span class="at">maxtime =</span> <span class="dv">5</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>Table<a href="#tab:T2" data-reference-type="ref" data-reference="T2">2</a> provides an
overview of all the input arguments in <code>LaPSO()</code>, where <code>n</code>, <code>k</code>, <code>N</code>,
<code>OC</code>, <code>p</code>, <code>q</code>, and <code>maxtime</code> are exactly the same as the input
arguments in the function <code>SA()</code>. <code>m</code> is the number of particles, which
represents candidate solutions in the PSO framework. <code>SameNumP</code> and
<code>SameNumG</code> are two tuning parameters that denote how many exchanges
would be performed to reduce the Hamming distance towards the personal
best and the global best. <code>p0</code> is the tuning parameter that denotes the
probability of a random swap for two elements in the current column of
the current particle to prevent the algorithm from being stuck at the
local optimum. In (Chen et al.2013), they provided the following
suggestions: <code>SameNumP</code> is approximately <span class="math inline">\(n/2\)</span> when <code>SameNumG</code> is <span class="math inline">\(0\)</span>,
<code>SameNumG</code> is approximately <span class="math inline">\(n/4\)</span> when <code>SameNumP</code> is <span class="math inline">\(0\)</span>, and <code>p0</code>
should be between <span class="math inline">\(1/(k-1)\)</span> and <span class="math inline">\(2/(k-1)\)</span>. The stopping criterion of the
function is the same as that of the function <code>SA</code>.</p>
<div class="center">
<div id="T2">
<table style="width:98%;">
<caption><span id="tab:T2">Table 2: </span> Overview of Input Arguments of the <code>LaPSO</code> Function</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Argument</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>n</code></td>
<td style="text-align: left;">A positive integer that defines the number of rows (or run size) of output LHD.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>k</code></td>
<td style="text-align: left;">A positive integer that defines the number of columns (or factor size) of output LHD.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>m</code></td>
<td style="text-align: left;">A positive integer that defines the number of particles, where each particle is a</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">candidate solution. A large value of <code>N</code> will result in a high CPU time, and it is</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">recommended to be no greater than 100. The default is set to be 10.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>N</code></td>
<td style="text-align: left;">A positive integer that defines the maximum number of iterations in the algorithm.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">A large value of <code>N</code> will result in a high CPU time, and it is recommended to be no</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">greater than 500. The default is set to be 10.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SameNumP</code></td>
<td style="text-align: left;">A non-negative integer that defines how many elements in current column of</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">current particle should be the same as corresponding Personal Best. SameNumP</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">can be 0, 1, 2, , n, where 0 means to skip the element exchange, which is the</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">default setting.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SameNumG</code></td>
<td style="text-align: left;">A non-negative integer that defines how many elements in current column of</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">current particle should be the same as corresponding Global Best. SameNumG can</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">be 0, 1, 2, , n, where 0 means to skip the element exchange. The default setting</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">is n/4. Note that SameNumP and SameNumG cannot be 0 at the same time.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>p0</code></td>
<td style="text-align: left;">A probability of exchanging two randomly selected elements in current column of</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">current particle LHD. The default is set to be 1/(k - 1).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>OC</code></td>
<td style="text-align: left;">An optimality criterion. The default setting is phi_p", and it could be one of</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">the following: phi_p",AvgAbsCor", MaxAbsCor",MaxProCriterion".</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>p</code></td>
<td style="text-align: left;">A positive integer, which is one parameter in the <span class="math inline">\(\phi_{p}\)</span> formula, and <code>p</code> is preferred</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">to be large. The default is set to be 15.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>q</code></td>
<td style="text-align: left;">A positive integer, which is one parameter in the <span class="math inline">\(\phi_{p}\)</span> formula, and <code>q</code> could be</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">either 1 or 2. If <code>q</code> is 1, the Manhattan (rectangular) distance will be calculated.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">If <code>q</code> is 2, the Euclidean distance will be calculated.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>maxtime</code></td>
<td style="text-align: left;">A positive number, which indicates the expected maximum CPU time, and it is</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">measured by minutes. For example, <code>maxtime</code>=3.5 indicates the CPU time will</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">be no greater than three and a half minutes. The default is set to be 5.</td>
</tr>
</tbody>
</table>
</div>
</div>
<h4 class="unnumbered" data-number="3.3" id="genetic-algorithms">Genetic Algorithms</h4>
<p>The genetic algorithm (GA) is a nature-inspired metaheuristic
optimization algorithm that mimics Charles Darwins idea of natural
selection (<span class="nocase">Holland et al.</span> 1992; Goldberg 1989). (Liefvendahl
and Stocki 2006) proposed a version of GA for identifying maximin
distance LHDs. They implement the column exchange technique to solve the
discrete optimization task. In the <code>LHD</code> package, the function <code>GA()</code>
implements this algorithm:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">GA</span>(n, k, <span class="at">m =</span> <span class="dv">10</span>, <span class="at">N =</span> <span class="dv">10</span>, <span class="at">pmut =</span> <span class="dv">1</span><span class="sc">/</span>(k <span class="sc">-</span> <span class="dv">1</span>), <span class="at">OC =</span> <span class="st">&quot;phi_p&quot;</span>, <span class="at">p =</span> <span class="dv">15</span>, <span class="at">q =</span> <span class="dv">1</span>, </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="at">maxtime =</span> <span class="dv">5</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>Table<a href="#tab:T3" data-reference-type="ref" data-reference="T3">3</a> provides an
overview of all the input arguments in <code>GA()</code>, where <code>n</code>, <code>k</code>, <code>N</code>,
<code>OC</code>, <code>p</code>, <code>q</code>, and <code>maxtime</code> are exactly the same as the input
arguments in the function <code>SA()</code>. <code>m</code> is the population size, which
represents how many candidate solutions in each iteration, and must be
an even number. <code>pmut</code> is the tuning parameter that controls how likely
the mutation would happen. When mutation occurs, two randomly selected
elements will be exchanged in the current column of the current LHD.
<code>pmut</code> serves the same purpose as <code>p0</code> in <code>LaPSO()</code>, which prevents the
algorithm from getting stuck at the local optimum, and it is recommended
to be <span class="math inline">\(1/(k-1)\)</span>. The stopping criterion of the function is the same as
that of the function <code>SA</code>.</p>
<div class="center">
<div id="T3">
<table style="width:98%;">
<caption><span id="tab:T3">Table 3: </span> Overview of Input Arguments of the <code>GA</code> Function</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Argument</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>n</code></td>
<td style="text-align: left;">A positive integer that defines the number of rows (or run size) of output LHD.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>k</code></td>
<td style="text-align: left;">A positive integer that defines the number of columns (or factor size) of output LHD.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>m</code></td>
<td style="text-align: left;">A positive even integer, which stands for the population size and it must be an even</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">number. The default is set to be 10. A large value of m will result in a high CPU time,</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">and it is recommended to be no greater than 100.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>N</code></td>
<td style="text-align: left;">A positive integer that defines the maximum number of iterations in the algorithm.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">A large value of <code>N</code> will result in a high CPU time, and it is recommended to be no</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">greater than 500. The default is set to be 10.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>pmut</code></td>
<td style="text-align: left;">A probability for mutation. When the mutation happens, two randomly selected</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">elements in current column of current LHD will be exchanged. The default is</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">set to be 1/(k - 1).</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>OC</code></td>
<td style="text-align: left;">An optimality criterion. The default setting is phi_p", and it could be one of</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">the following: phi_p",AvgAbsCor", MaxAbsCor",MaxProCriterion".</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>p</code></td>
<td style="text-align: left;">A positive integer, which is one parameter in the <span class="math inline">\(\phi_{p}\)</span> formula, and <code>p</code> is preferred</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">to be large. The default is set to be 15.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>q</code></td>
<td style="text-align: left;">A positive integer, which is one parameter in the <span class="math inline">\(\phi_{p}\)</span> formula, and <code>q</code> could be</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">either 1 or 2. If <code>q</code> is 1, the Manhattan (rectangular) distance will be calculated.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">If <code>q</code> is 2, the Euclidean distance will be calculated.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>maxtime</code></td>
<td style="text-align: left;">A positive number, which indicates the expected maximum CPU time, and it is</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">measured by minutes. For example, <code>maxtime</code>=3.5 indicates the CPU time will</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">be no greater than three and a half minutes. The default is set to be 5.</td>
</tr>
</tbody>
</table>
</div>
</div>
<h4 class="unnumbered" data-number="3.4" id="illustrating-examples-for-the-implemented-search-algorithms">Illustrating Examples for the Implemented Search Algorithms</h4>
<p>This subsection demonstrates some examples on how to use the search
algorithms in the developed <code>LHD</code> package. In
Table<a href="#tab:T4" data-reference-type="ref" data-reference="A1">4</a>, we summarize
the R functions of the algorithms discussed in the previous subsections,
which can be used to identify different types of optimal LHDs. Users who
seek fast solutions can use the default settings of the input arguments
after specifying the design sizes. See the following examples.</p>
<div class="center">
<div id="A1">
<table style="width:98%;">
<caption><span id="tab:T4">Table 4: </span> Search algorithm functions in the <code>LHD</code> package</caption>
<colgroup>
<col style="width: 11%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SA</td>
<td style="text-align: left;">Returns an LHD via the simulated annealing algorithm (Morris and Mitchell 1995).</td>
</tr>
<tr class="even">
<td style="text-align: left;">OASA</td>
<td style="text-align: left;">Returns an LHD via the orthogonal-array-based simulated annealing algorithm</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">(Leary et al.2003), where an OA of the required design size must exist.</td>
</tr>
<tr class="even">
<td style="text-align: left;">SA2008</td>
<td style="text-align: left;">Returns an LHD via the simulated annealing algorithm with the multi-objective</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">optimization approach (Joseph and Hung 2008).</td>
</tr>
<tr class="even">
<td style="text-align: left;">LaPSO</td>
<td style="text-align: left;">Returns an LHD via the particle swarm optimization (Chen et al.2013).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">GA</td>
<td style="text-align: left;">Returns an LHD via the genetic algorithm (Liefvendahl and Stocki 2006).</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Generate a 5 by 3 maximin distance LHD by the SA function.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.SA <span class="ot">=</span> <span class="fu">SA</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">k =</span> <span class="dv">3</span>); try.SA  </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>] [,<span class="dv">2</span>] [,<span class="dv">3</span>]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">2</span>    <span class="dv">2</span>    <span class="dv">1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">5</span>    <span class="dv">3</span>    <span class="dv">2</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">4</span>    <span class="dv">5</span>    <span class="dv">5</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">3</span>    <span class="dv">1</span>    <span class="dv">4</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">1</span>    <span class="dv">4</span>    <span class="dv">3</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">phi_p</span>(try.SA)   <span class="co">#\phi_p is smaller than that of a random LHD (0.3336608).</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="fl">0.2169567</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">#Similarly, generations of 5 by 3 maximin distance LHD by the SA2008, LaPSO and GA functions.</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.SA2008 <span class="ot">=</span> <span class="fu">SA2008</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">k =</span> <span class="dv">3</span>)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.LaPSO <span class="ot">=</span> <span class="fu">LaPSO</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">k =</span> <span class="dv">3</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.GA <span class="ot">=</span> <span class="fu">GA</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">k =</span> <span class="dv">3</span>)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">#Generate an OA(9,2,3,2), an orthogonal array with 9 runs, 2 factors, 3 levels, and 2 strength.</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> OA <span class="ot">=</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">each =</span> <span class="dv">3</span>), <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">times =</span> <span class="dv">3</span>)),</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="sc">+</span>           <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">nrow =</span> <span class="dv">9</span>, <span class="at">byrow =</span> <span class="cn">FALSE</span>)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co">#Generates a maximin distance LHD with the same design size as the input OA</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co">#by the orthogonal-array-based simulated annealing algorithm.</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.OASA <span class="ot">=</span> <span class="fu">OASA</span>(OA)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> OA; try.OASA</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>      [,<span class="dv">1</span>] [,<span class="dv">2</span>]         [,<span class="dv">1</span>] [,<span class="dv">2</span>]</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">1</span>    <span class="dv">1</span>    [<span class="dv">1</span>,]    <span class="dv">1</span>    <span class="dv">2</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">1</span>    <span class="dv">2</span>    [<span class="dv">2</span>,]    <span class="dv">2</span>    <span class="dv">6</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">1</span>    <span class="dv">3</span>    [<span class="dv">3</span>,]    <span class="dv">3</span>    <span class="dv">9</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">2</span>    <span class="dv">1</span>    [<span class="dv">4</span>,]    <span class="dv">4</span>    <span class="dv">3</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">2</span>    <span class="dv">2</span>    [<span class="dv">5</span>,]    <span class="dv">6</span>    <span class="dv">5</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>[<span class="dv">6</span>,]    <span class="dv">2</span>    <span class="dv">3</span>    [<span class="dv">6</span>,]    <span class="dv">5</span>    <span class="dv">7</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>[<span class="dv">7</span>,]    <span class="dv">3</span>    <span class="dv">1</span>    [<span class="dv">7</span>,]    <span class="dv">7</span>    <span class="dv">1</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>[<span class="dv">8</span>,]    <span class="dv">3</span>    <span class="dv">2</span>    [<span class="dv">8</span>,]    <span class="dv">9</span>    <span class="dv">4</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>[<span class="dv">9</span>,]    <span class="dv">3</span>    <span class="dv">3</span>;   [<span class="dv">9</span>,]    <span class="dv">8</span>    <span class="dv">8</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>Note that the default optimality criterion embedded in all search
algorithms is phi_p" (that is, the maximin distance criterion),
leading to the maximin <span class="math inline">\(L_2\)</span>-distance LHDs. For other optimality
criteria, users should change the setting of the input argument <code>OC</code>
(with optionsphi_p", MaxProCriterion",MaxAbsCor" and
MaxProCriterion"). The following examples illustrate some details of
different argument settings.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Below try.SA is a 5 by 3 maximin distance LHD generated by the SA with 30 iterations (N = 30).</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">#The temperature starts at 10 (T0 = 10) and decreases 10% (rate = 0.1) each time.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">#The minimium temperature allowed is 1 (Tmin = 1) and the maximum perturbations that </span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">#the algorithm will try without improvements is 5 (Imax = 5). The optimality criterion </span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">#used is maximin distance criterion (OC = &quot;phi_p&quot;) with p = 15 and q = 1, and the </span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">#maximum CPU time is 5 minutes (maxtime = 5).</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.SA <span class="ot">=</span> <span class="fu">SA</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">k =</span> <span class="dv">3</span>, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">T0 =</span> <span class="dv">10</span>, <span class="at">rate =</span> <span class="fl">0.1</span>, <span class="at">Tmin =</span> <span class="dv">1</span>, <span class="at">Imax =</span> <span class="dv">5</span>, <span class="at">OC =</span> <span class="st">&quot;phi_p&quot;</span>,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="sc">+</span>           <span class="at">p =</span> <span class="dv">15</span>, <span class="at">q =</span> <span class="dv">1</span>, <span class="at">maxtime =</span> <span class="dv">5</span>); try.SA</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>] [,<span class="dv">2</span>] [,<span class="dv">3</span>]</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">1</span>    <span class="dv">3</span>    <span class="dv">4</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">2</span>    <span class="dv">5</span>    <span class="dv">2</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">5</span>    <span class="dv">4</span>    <span class="dv">3</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">4</span>    <span class="dv">1</span>    <span class="dv">5</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">3</span>    <span class="dv">2</span>    <span class="dv">1</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">phi_p</span>(try.SA)    </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="fl">0.2169567</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="co">#Below try.SA2008 is a 5 by 3 maximin distance LHD generated by SA with </span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co">#the multi-objective optimization approach. The input arguments are interpreted </span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="co">#the same as the design try.SA above.</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.SA2008 <span class="ot">=</span> <span class="fu">SA2008</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">k =</span> <span class="dv">3</span>, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">T0 =</span> <span class="dv">10</span>, <span class="at">rate =</span> <span class="fl">0.1</span>, <span class="at">Tmin =</span> <span class="dv">1</span>, <span class="at">Imax =</span> <span class="dv">5</span>, </span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="sc">+</span>                   <span class="at">OC =</span> <span class="st">&quot;phi_p&quot;</span>, <span class="at">p =</span> <span class="dv">15</span>, <span class="at">q =</span> <span class="dv">1</span>, <span class="at">maxtime =</span> <span class="dv">5</span>)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a><span class="co">#Below try.OASA is a 9 by 2 maximin distance LHD generated by the</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="co">#orthogonal-array-based simulated annealing algorithm with the input </span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="co">#OA (defined previously), and the rest input arguments are interpreted the </span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span class="co">#same as the design try.SA above.</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.OASA <span class="ot">=</span> <span class="fu">OASA</span>(OA, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">T0 =</span> <span class="dv">10</span>, <span class="at">rate =</span> <span class="fl">0.1</span>, <span class="at">Tmin =</span> <span class="dv">1</span>, <span class="at">Imax =</span> <span class="dv">5</span>,</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="sc">+</span>               <span class="at">OC =</span> <span class="st">&quot;phi_p&quot;</span>, <span class="at">p =</span> <span class="dv">15</span>, <span class="at">q =</span> <span class="dv">1</span>, <span class="at">maxtime =</span> <span class="dv">5</span>)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a><span class="co">#Below try.LaPSO is a 5 by 3 maximum projection LHD generated by the particle swarm </span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a><span class="co">#optimization algorithm with 20 particles (m = 20) and 30 iterations (N = 30).</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a><span class="co">#Zero (or two) elements in any column of the current particle should be the same as</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a><span class="co">#the elements of corresponding column from personal best (or global best), because</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span class="co">#of SameNumP = 0 (or SameNumG = 2).</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a><span class="co">#The probability of exchanging two randomly selected elements is 0.5 (p0 = 0.5).</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a><span class="co">#The optimality criterion is maximum projection criterion (OC = &quot;MaxProCriterion&quot;).</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a><span class="co">#The maximum CPU time is 5 minutes (maxtime = 5).</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.LaPSO <span class="ot">=</span> <span class="fu">LaPSO</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">k =</span> <span class="dv">3</span>, <span class="at">m =</span> <span class="dv">20</span>, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">SameNumP =</span> <span class="dv">0</span>, <span class="at">SameNumG =</span> <span class="dv">2</span>,</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a><span class="sc">+</span>                 <span class="at">p0 =</span> <span class="fl">0.5</span>, <span class="at">OC =</span> <span class="st">&quot;MaxProCriterion&quot;</span>, <span class="at">maxtime =</span> <span class="dv">5</span>); try.LaPSO</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>] [,<span class="dv">2</span>] [,<span class="dv">3</span>]</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">4</span>    <span class="dv">5</span>    <span class="dv">4</span></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">3</span>    <span class="dv">1</span>    <span class="dv">3</span></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">5</span>    <span class="dv">2</span>    <span class="dv">1</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">2</span>    <span class="dv">3</span>    <span class="dv">5</span></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">1</span>    <span class="dv">4</span>    <span class="dv">2</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a><span class="co">#Recall the value is 0.5375482 from the random LHD in Section 2.</span></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">MaxProCriterion</span>(try.LaPSO) </span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="fl">0.3561056</span></span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a><span class="co">#Below try.GA is a 5 by 3 OLHD generated by the genetic algorithm with the </span></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a><span class="co">#population size 20 (m = 20), number of iterations 30 (N = 30),  mutation </span></span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a><span class="co">#probability 0.5 (pmut = 0.5), maximum absolute correlation criterion</span></span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a><span class="co">#(OC = &quot;MaxAbsCor&quot;), and maximum CPU time 5 minutes (maxtime = 5).</span></span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.GA <span class="ot">=</span> <span class="fu">GA</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">k =</span> <span class="dv">3</span>, <span class="at">m =</span> <span class="dv">20</span>, <span class="at">N =</span> <span class="dv">30</span>, <span class="at">pmut =</span> <span class="fl">0.5</span>, <span class="at">OC =</span> <span class="st">&quot;MaxAbsCor&quot;</span>, </span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a><span class="sc">+</span>                 <span class="at">maxtime =</span> <span class="dv">5</span>); try.GA</span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>] [,<span class="dv">2</span>] [,<span class="dv">3</span>]</span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">2</span>    <span class="dv">1</span>    <span class="dv">2</span></span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">4</span>    <span class="dv">4</span>    <span class="dv">5</span></span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">3</span>    <span class="dv">5</span>    <span class="dv">1</span></span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">5</span>    <span class="dv">2</span>    <span class="dv">3</span></span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">1</span>    <span class="dv">3</span>    <span class="dv">4</span></span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a><span class="co">#Recall the value is 0.9 from the random LHD in Section 2.</span></span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">MaxAbsCor</span>(try.GA)</span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="fl">0.1</span>     <span class="co">#The maximum absolute correlation between columns is 0.1</span></span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>Next, we discuss some details of the implementation. In SA based
algorithms (<code>SA</code>, <code>SA2008</code>, and <code>OASA</code>), the number of iterations <code>N</code> is
recommended to be no greater than 500 for computing time considerations.
The input <code>rate</code> determines the percentage of the decrease in current
temperature (for example, <span class="math inline">\(0.1\)</span> means a decrease of <span class="math inline">\(10\%\)</span> each time). A
high rate would make the temperature rapidly drop, which leads to a fast
stop of the algorithm. It is recommended to set <code>rate</code> from <span class="math inline">\(0.1\)</span> to
<span class="math inline">\(0.15\)</span>. <code>Imax</code> indicates the maximum perturbations that the algorithm
will attempt without improvements before the temperature reduces, and it
is recommended to be no greater than 5 for computing time
considerations. <code>OC</code> chooses the optimality criterion, and the <code>"phi_p"</code>
criterion in <a href="#eq:E2">(1)</a> is set as default. <code>OC</code> has other options,
including <code>"MaxProCriterion"</code>, <code>"AvgAbsCor"</code> and <code>"MaxAbsCor"</code>. Our
algorithms support both the <span class="math inline">\(L_1\)</span> and <span class="math inline">\(L_2\)</span> distances.</p>
<p>For every algorithm, we incorporate a progress bar to visualize the
computing time used. After an algorithm is completed, information on
average CPU time per iteration" andnumbers of iterations completed"
will be presented. Users can set the limit for the CPU time used for
each algorithm using the argument <code>maxtime</code>, according to their
practical needs.</p>
<p>We also provide some illustrative code to demonstrate that the designs
found in the <code>LHD</code> package are better than the existing ones, and the
code in the following can be easily modified to construct other design
sizes or other LHD types. Out of 100 trials, the code below shows the GA
in the <code>LHD</code> package constructed better MaxPro LHDs 99 times compared to
the algorithm in the <code>MaxPro</code> package, when 500 iterations are set for
both algorithms. We did not compare the CPU time between these two
packages since one is written in the R environment and the other one is
written in the C++ environment, but with the same number of iterations,
the GA in the <code>LHD</code> package almost always constructs better MaxPro LHDs.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Make sure both packages are properly installed before load them</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">library</span>(LHD) </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">library</span>(MaxPro)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> count <span class="ot">=</span> <span class="dv">0</span> <span class="co">#Define a variable for counting purpose</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> k <span class="ot">=</span> <span class="dv">5</span>       <span class="co">#Factor size 5</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> n <span class="ot">=</span> <span class="dv">10</span><span class="sc">*</span>k    <span class="co">#Run size = 10*factor size</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">#Setting 500 iterations for both algorithms, below loop counts</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">#how many times the GA from LHD package outperforms the algorithm </span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">#from MaxPro package out of 100 times</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>) {</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  LHD <span class="ot">=</span> LHD<span class="sc">::</span><span class="fu">GA</span>(<span class="at">n =</span> n, <span class="at">k =</span> k, <span class="at">m =</span> <span class="dv">100</span>, <span class="at">N =</span> <span class="dv">500</span>)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  MaxPro <span class="ot">=</span> MaxPro<span class="sc">::</span><span class="fu">MaxProLHD</span>(<span class="at">n =</span> n, <span class="at">p =</span> k, <span class="at">total_iter =</span> <span class="dv">500</span>)<span class="sc">$</span>Design</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">#MaxPro * n + 0.5 applied the transformation mentioned in Section 2 </span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">#to revert the scaling.</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  Result.LHD <span class="ot">=</span> LHD<span class="sc">::</span><span class="fu">MaxProCriterion</span>(LHD)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  Result.MaxPro <span class="ot">=</span> LHD<span class="sc">::</span><span class="fu">MaxProCriterion</span>(MaxPro <span class="sc">*</span> n <span class="sc">+</span> <span class="fl">0.5</span>)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (Result.LHD <span class="sc">&lt;</span> Result.MaxPro) {count <span class="ot">=</span> count <span class="sc">+</span> <span class="dv">1</span>}</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> count</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">99</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<h3 data-number="4" id="Constr"><span class="header-section-number">4</span> Algebraic Constructions for Optimal LHDs with Certain Sizes</h3>
<p>There are algebraic constructions available for certain design sizes,
and theoretical results are developed to guarantee the efficiency of
such designs. Algebraic constructions almost do not require any
searching, which are especially attractive for large designs. In this
section, we present algebraic constructions that are available in the
<code>LHD</code> package for maximin distance LHDs and orthogonal LHDs.</p>
<h4 class="unnumbered" data-number="4.1" id="WT">Algebraic Constructions for Maximin Distance LHDs</h4>
<p>(Wang et al.2018) proposed to generate maximin distance LHDs via good
lattice point (GLP) sets (Zhou and Xu 2015) and Williams transformation
(Williams 1949). In practice, their method can lead to space-filling
designs with relatively flexible sizes, where the run size <span class="math inline">\(n\)</span> is
flexible but the factor size <span class="math inline">\(k\)</span> must be no greater than the number of
positive integers that are co-prime to <span class="math inline">\(n\)</span>. They proved that the
resulting designs of sizes <span class="math inline">\(n \times (n-1)\)</span> (with <span class="math inline">\(n\)</span> being any odd
prime) and <span class="math inline">\(n \times n\)</span> (with <span class="math inline">\(2n+1\)</span> or <span class="math inline">\(n+1\)</span> being odd prime) are
optimal under the maximin <span class="math inline">\(L_1\)</span> distance criterion. This construction
method by (Wang et al.2018) is very attractive for constructing large
maximin distance LHDs. In the <code>LHD</code> package, function <code>FastMmLHD()</code>
implements this method:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">FastMmLHD</span>(n, k, <span class="at">method =</span> <span class="st">&quot;manhattan&quot;</span>, <span class="at">t1 =</span> <span class="dv">10</span>),</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>where <code>n</code> and <code>k</code> are the desired run size and factor size. <code>method</code> is
a distance measure method which can be one of the following:
euclidean",maximum", manhattan",canberra", binary" orminkowski". Any unambiguous substring can be given. <code>t1</code> is a tuning
parameter, which determines how many repeats will be implemented to
search for the optimal design. The default is set to be 10.</p>
<p>(Tang 1993) proposed to construct orthogonal array-based LHDs (OALHDs)
from existing orthogonal arrays (OAs), and (Tang 1993) showed that the
OALHDs can have better space-filling properties than the general ones.
In the <code>LHD</code> package, function <code>OA2LHD()</code> implements this method:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">OA2LHD</span>(OA),</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>where <code>OA</code> is an orthogonal array matrix. Users only need to input an OA
and the function will return an OALHD with the same design size as the
input OA.</p>
<h4 class="unnumbered" data-number="4.2" id="sec:olhd">Algebraic Constructions for Orthogonal LHDs</h4>
<p>Orthogonal LHDs (OLHDs) have zero pairwise correlation between any two
columns, which are widely used by practitioners. There is a rich
literature on the constructions of OLHDs with various design sizes, but
they are often too hard for practitioners to replicate in practice. The
<code>LHD</code> package implements some currently popular methods (Ye 1998; Cioppa
and Lucas 2007; Sun et al.2010; Tang 1993; Lin et al.2009; Butler
2001) for practitioners and the functions are easy to use.</p>
<p>(Ye 1998) proposed a construction for OLHDs with run sizes <span class="math inline">\(n=2^m+1\)</span> and
factor sizes <span class="math inline">\(k=2m-2\)</span> where <span class="math inline">\(m\)</span> is any integer bigger than 2. In the
<code>LHD</code> package, function <code>OLHD.Y1998()</code> implements this algebraic
construction:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">OLHD.Y1998</span>(m),</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>where input argument <code>m</code> is the <span class="math inline">\(m\)</span> in the construction of (Ye 1998).
(Cioppa and Lucas 2007) extended (Ye 1998)s method to construct OLHDs
with run size <span class="math inline">\(n=2^m+1\)</span> and factor size <span class="math inline">\(k=m+ {m-1 \choose 2}\)</span>, where
<span class="math inline">\(m\)</span> is any integer bigger than 2. In the <code>LHD</code> package, function
<code>OLHD.C2007()</code> implements this algebraic construction with input
argument <code>m</code> remaining the same:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">OLHD.C2007</span>(m)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>(Sun et al.2010) extended their earlier work (Sun et al.2009) to
construct OLHDs with <span class="math inline">\(n=r2^{c+1}+1\)</span> or <span class="math inline">\(n=r2^{c+1}\)</span> and <span class="math inline">\(k=2^c\)</span>, where
<span class="math inline">\(r\)</span> and <span class="math inline">\(c\)</span> are positive integers. In the <code>LHD</code> package, function
<code>OLHD.S2010()</code> implements this algebraic construction:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">OLHD.S2010</span>(C, r, <span class="at">type =</span> <span class="st">&quot;odd&quot;</span>),</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>where input arguments <code>C</code> and <code>r</code> are <span class="math inline">\(c\)</span> and <span class="math inline">\(r\)</span> in the construction.
When input argument <code>type</code> is <code>"odd"</code>, the output design size would be
<span class="math inline">\(n=r2^{c+1}+1\)</span> by <span class="math inline">\(k=2^c\)</span>. When input argument <code>type</code> is <code>"even"</code>, the
output design size would be <span class="math inline">\(n=r2^{c+1}\)</span> by <span class="math inline">\(k=2^c\)</span>.</p>
<p>(Lin et al.2009) constructed OLHDs or NOLHDs with <span class="math inline">\(n^2\)</span> runs and <span class="math inline">\(2fp\)</span>
factors by coupling OLHD(<span class="math inline">\(n\)</span>, <span class="math inline">\(p\)</span>) or NOLHD(<span class="math inline">\(n\)</span>, <span class="math inline">\(p\)</span>) with an
OA(<span class="math inline">\(n^2,2f,n,2\)</span>). For example, an OLHD(11, 7), coupled with an
OA(121,12,11,2), would yield an OLHD(121, 84). The design size of output
OLHD or NOLHD highly depends on the existence of the OAs. In the <code>LHD</code>
package, function <code>OLHD.L2009()</code> implements this algebraic construction:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">OLHD.L2009</span>(OLHD, OA),</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<p>where input arguments <code>OLHD</code> and <code>OA</code> are the OLHD and OA to be coupled,
and their design sizes need to be aligned with the designated pattern of
the construction.</p>
<p>(Butler 2001) proposed a method to construct OLHDs with the run size <span class="math inline">\(n\)</span>
being odd primes and factor size <span class="math inline">\(k\)</span> being less than or equal to <span class="math inline">\(n-1\)</span>
via the Williams transformation (Williams 1949). In the <code>LHD</code> package,
function <code>OLHD.B2001()</code> implements this algebraic construction with
input arguments <code>n</code> and <code>k</code> exactly matching those in construction:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">OLHD.B2001</span>(n, k)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<h4 class="unnumbered" data-number="4.3" id="illustrating-examples-for-the-implemented-algebraic-constructions">Illustrating Examples for the Implemented Algebraic Constructions</h4>
<p>In Table<a href="#tab:T5" data-reference-type="ref" data-reference="A2">5</a>, we summarize
the algebraic constructions implemented by the developed <code>LHD</code> package,
where <code>FastMmLHD</code> and <code>OA2LHD</code> are for maximin distance LHDs and
<code>OLHD.Y1998</code>, <code>OLHD.C2007</code>, <code>OLHD.S2010</code>, <code>OLHD.L2009</code> and <code>OLHD.B2001</code>
are for orthogonal LHDs. The following examples will illustrate how to
use them.</p>
<div class="center">
<div id="A2">
<table style="width:98%;">
<caption><span id="tab:T5">Table 5: </span> Algebraic constructions in the <code>LHD</code> package</caption>
<colgroup>
<col style="width: 14%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">FastMmLHD</td>
<td style="text-align: left;">Returns a maximin distance LHD matrix (Wang et al.2018).</td>
</tr>
<tr class="even">
<td style="text-align: left;">OA2LHD</td>
<td style="text-align: left;">Expands an orthogonal array to an LHD (Tang 1993).</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OLHD.Y1998</td>
<td style="text-align: left;">Returns a <span class="math inline">\(2^m+1\)</span> by <span class="math inline">\(2m-2\)</span> orthogonal LHD matrix (Ye 1998)</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">where <span class="math inline">\(m\)</span> is an integer and <span class="math inline">\(m \geq 2\)</span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OLHD.C2007</td>
<td style="text-align: left;">Returns a <span class="math inline">\(2^m+1\)</span> by <span class="math inline">\(m+{m-1 \choose 2}\)</span> orthogonal LHD matrix</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">(Cioppa and Lucas 2007) where <span class="math inline">\(m\)</span> is an integer and <span class="math inline">\(m \geq 2\)</span>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OLHD.S2010</td>
<td style="text-align: left;">Returns a <span class="math inline">\(r2^{c+1}+1\)</span> or <span class="math inline">\(r2^{c+1}\)</span> by <span class="math inline">\(2^c\)</span> orthogonal LHD matrix</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">(Sun et al.2010) where <span class="math inline">\(r\)</span> and <span class="math inline">\(c\)</span> are positive integers.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">OLHD.L2009</td>
<td style="text-align: left;">Couples an <span class="math inline">\(n\)</span> by <span class="math inline">\(p\)</span> orthogonal LHD with a <span class="math inline">\(n^2\)</span> by <span class="math inline">\(2f\)</span> strength <span class="math inline">\(2\)</span> and</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">level <span class="math inline">\(n\)</span> orthogonal array to generate a <span class="math inline">\(n^2\)</span> by <span class="math inline">\(2fp\)</span> orthogonal LHD</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">(Lin et al.2009).</td>
</tr>
<tr class="even">
<td style="text-align: left;">OLHD.B2001</td>
<td style="text-align: left;">Returns an orthogonal LHD (Butler 2001) with the run size <span class="math inline">\(n\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">being odd primes and factor size <span class="math inline">\(k\)</span> being less than or equal to <span class="math inline">\(n-1\)</span> .</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">#FastMmLHD(8, 8) generates an optimal 8 by 8 maximin L_1 distance LHD.</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span>try.FastMm <span class="ot">=</span> <span class="fu">FastMmLHD</span>(<span class="at">n =</span> <span class="dv">8</span>, <span class="at">k =</span> <span class="dv">8</span>); try.FastMm</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>] [,<span class="dv">2</span>] [,<span class="dv">3</span>] [,<span class="dv">4</span>] [,<span class="dv">5</span>] [,<span class="dv">6</span>] [,<span class="dv">7</span>] [,<span class="dv">8</span>]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">0</span>    <span class="dv">1</span>    <span class="dv">2</span>    <span class="dv">3</span>    <span class="dv">4</span>    <span class="dv">5</span>    <span class="dv">6</span>    <span class="dv">7</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">1</span>    <span class="dv">3</span>    <span class="dv">5</span>    <span class="dv">7</span>    <span class="dv">6</span>    <span class="dv">4</span>    <span class="dv">2</span>    <span class="dv">0</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">2</span>    <span class="dv">5</span>    <span class="dv">7</span>    <span class="dv">4</span>    <span class="dv">1</span>    <span class="dv">0</span>    <span class="dv">3</span>    <span class="dv">6</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">3</span>    <span class="dv">7</span>    <span class="dv">4</span>    <span class="dv">0</span>    <span class="dv">2</span>    <span class="dv">6</span>    <span class="dv">5</span>    <span class="dv">1</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">4</span>    <span class="dv">6</span>    <span class="dv">1</span>    <span class="dv">2</span>    <span class="dv">7</span>    <span class="dv">3</span>    <span class="dv">0</span>    <span class="dv">5</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>[<span class="dv">6</span>,]    <span class="dv">5</span>    <span class="dv">4</span>    <span class="dv">0</span>    <span class="dv">6</span>    <span class="dv">3</span>    <span class="dv">1</span>    <span class="dv">7</span>    <span class="dv">2</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>[<span class="dv">7</span>,]    <span class="dv">6</span>    <span class="dv">2</span>    <span class="dv">3</span>    <span class="dv">5</span>    <span class="dv">0</span>    <span class="dv">7</span>    <span class="dv">1</span>    <span class="dv">4</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>[<span class="dv">8</span>,]    <span class="dv">7</span>    <span class="dv">0</span>    <span class="dv">6</span>    <span class="dv">1</span>    <span class="dv">5</span>    <span class="dv">2</span>    <span class="dv">4</span>    <span class="dv">3</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="co">#OA2LHD(OA) expands an input OA to an LHD of the same run size.</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span>try.OA2LHD <span class="ot">=</span> <span class="fu">OA2LHD</span>(OA)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span>OA; try.OA2LHD</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>] [,<span class="dv">2</span>]          [,<span class="dv">1</span>] [,<span class="dv">2</span>]     </span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">1</span>    <span class="dv">1</span>     [<span class="dv">1</span>,]    <span class="dv">1</span>    <span class="dv">2</span>    </span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">1</span>    <span class="dv">2</span>     [<span class="dv">2</span>,]    <span class="dv">2</span>    <span class="dv">4</span>     </span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">1</span>    <span class="dv">3</span>     [<span class="dv">3</span>,]    <span class="dv">3</span>    <span class="dv">9</span>     </span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">2</span>    <span class="dv">1</span>     [<span class="dv">4</span>,]    <span class="dv">4</span>    <span class="dv">3</span>     </span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">2</span>    <span class="dv">2</span>     [<span class="dv">5</span>,]    <span class="dv">5</span>    <span class="dv">5</span>     </span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>[<span class="dv">6</span>,]    <span class="dv">2</span>    <span class="dv">3</span>     [<span class="dv">6</span>,]    <span class="dv">6</span>    <span class="dv">7</span>     </span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>[<span class="dv">7</span>,]    <span class="dv">3</span>    <span class="dv">1</span>     [<span class="dv">7</span>,]    <span class="dv">9</span>    <span class="dv">1</span>    </span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>[<span class="dv">8</span>,]    <span class="dv">3</span>    <span class="dv">2</span>     [<span class="dv">8</span>,]    <span class="dv">8</span>    <span class="dv">6</span>   </span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>[<span class="dv">9</span>,]    <span class="dv">3</span>    <span class="dv">3</span>;    [<span class="dv">9</span>,]    <span class="dv">7</span>    <span class="dv">8</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">#OLHD.Y1998(m = 3) generates a 9 by 4 orthogonal LHD.</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">#Note that 2^m+1 = 9 and 2*m-2 = 4.</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.Y1998 <span class="ot">=</span> <span class="fu">OLHD.Y1998</span>(<span class="at">m =</span> <span class="dv">3</span>); try.Y1998</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>] [,<span class="dv">2</span>] [,<span class="dv">3</span>] [,<span class="dv">4</span>]</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">4</span>   <span class="sc">-</span><span class="dv">3</span>   <span class="sc">-</span><span class="dv">2</span>    <span class="dv">1</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">3</span>    <span class="dv">4</span>   <span class="sc">-</span><span class="dv">1</span>   <span class="sc">-</span><span class="dv">2</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">1</span>   <span class="sc">-</span><span class="dv">2</span>    <span class="dv">3</span>   <span class="sc">-</span><span class="dv">4</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">2</span>    <span class="dv">1</span>    <span class="dv">4</span>    <span class="dv">3</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">0</span>    <span class="dv">0</span>    <span class="dv">0</span>    <span class="dv">0</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>[<span class="dv">6</span>,]   <span class="sc">-</span><span class="dv">4</span>    <span class="dv">3</span>    <span class="dv">2</span>   <span class="sc">-</span><span class="dv">1</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>[<span class="dv">7</span>,]   <span class="sc">-</span><span class="dv">3</span>   <span class="sc">-</span><span class="dv">4</span>    <span class="dv">1</span>    <span class="dv">2</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>[<span class="dv">8</span>,]   <span class="sc">-</span><span class="dv">1</span>    <span class="dv">2</span>   <span class="sc">-</span><span class="dv">3</span>    <span class="dv">4</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>[<span class="dv">9</span>,]   <span class="sc">-</span><span class="dv">2</span>   <span class="sc">-</span><span class="dv">1</span>   <span class="sc">-</span><span class="dv">4</span>   <span class="sc">-</span><span class="dv">3</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">MaxAbsCor</span>(try.Y1998)    <span class="co">#column-wise correlations are 0.</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">0</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="co">#OLHD.C2007(m = 4) generates a 17 by 7 orthogonal LHD.</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="co">#Note that 2^m+1 = 17 and $4+{4-1 \choose 2}$ = 7.</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> try.C2007 <span class="ot">=</span> <span class="fu">OLHD.C2007</span>(<span class="at">m =</span> <span class="dv">4</span>); <span class="fu">dim</span>(try.C2007)</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">17</span>  <span class="dv">7</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">MaxAbsCor</span>(try.C2007)    <span class="co">#column-wise correlations are 0</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">0</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="co">#OLHD.S2010(C = 3, r = 3, type = &quot;odd&quot;) generates a 49 by 8 orthogonal LHD.</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a><span class="co">#Note that 3*2^4+1 = 49 and 2^3 = 8.</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">dim</span>(<span class="fu">OLHD.S2010</span>(<span class="at">C =</span> <span class="dv">3</span>, <span class="at">r =</span> <span class="dv">3</span>, <span class="at">type =</span> <span class="st">&quot;odd&quot;</span>))</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">49</span>  <span class="dv">8</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">MaxAbsCor</span>(<span class="fu">OLHD.S2010</span>(<span class="at">C =</span> <span class="dv">3</span>, <span class="at">r =</span> <span class="dv">3</span>, <span class="at">type =</span> <span class="st">&quot;odd&quot;</span>)) <span class="co">#column-wise correlations are 0</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">0</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a><span class="co">#OLHD.S2010(C = 3, r = 3, type = &quot;even&quot;) generates a 48 by 8 orthogonal LHD.</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="co">#Note that 3*2^4 = 48 and 2^3 = 8.</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">dim</span>(<span class="fu">OLHD.S2010</span>(<span class="at">C =</span> <span class="dv">3</span>, <span class="at">r =</span> <span class="dv">3</span>, <span class="at">type =</span> <span class="st">&quot;even&quot;</span>))</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">48</span>  <span class="dv">8</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">MaxAbsCor</span>(<span class="fu">OLHD.S2010</span>(<span class="at">C =</span> <span class="dv">3</span>, <span class="at">r =</span> <span class="dv">3</span>, <span class="at">type =</span> <span class="st">&quot;even&quot;</span>)) <span class="co">#column-wise correlations are 0</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">0</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a><span class="co">#Create a 5 by 2 OLHD.</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> OLHD <span class="ot">=</span> <span class="fu">OLHD.C2007</span>(<span class="at">m =</span> <span class="dv">2</span>)</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a><span class="co">#Create an OA(25, 6, 5, 2).</span></span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> OA <span class="ot">=</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">3</span>,</span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">1</span>,</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">2</span>,</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>,</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>), <span class="at">ncol =</span> <span class="dv">6</span>, <span class="at">nrow =</span> <span class="dv">25</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a><span class="co">#OLHD.L2009(OLHD, OA) generates a 25 by 12 orthogonal LHD.</span></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a><span class="co">#Note that n = 5 so n^2 = 25. p = 2 and f = 3 so 2fp = 12.</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">dim</span>(<span class="fu">OLHD.L2009</span>(OLHD, OA))</span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">25</span> <span class="dv">12</span></span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">MaxAbsCor</span>(<span class="fu">OLHD.L2009</span>(OLHD, OA))    <span class="co">#column-wise correlations are 0.</span></span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">0</span></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a><span class="co">#OLHD.B2001(n = 11, k = 5) generates a 11 by 5 orthogonal LHD.</span></span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a><span class="sc">&gt;</span> <span class="fu">dim</span>(<span class="fu">OLHD.B2001</span>(<span class="at">n =</span> <span class="dv">11</span>, <span class="at">k =</span> <span class="dv">5</span>))</span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>] <span class="dv">11</span>  <span class="dv">5</span></span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a>    </span></code></pre></div>
<h3 data-number="5" id="other-r-packages-for-latin-hypercube-and-comparative-discussion"><span class="header-section-number">5</span> Other R Packages for Latin Hypercube and Comparative Discussion</h3>
<p>Several R packages have been developed to facilitate Latin hypercube
samples and design constructions for computer experiments. Among these,
the <code>lhs</code> package (Carnell 2024) is widely recognized for its utility.
It provides functions for generating both random and optimized Latin
hypercube samples (but not designs), and its methods are particularly
useful for simulation studies where space-filling properties are desired
but design optimality is not the primary focus. The <code>SLHD</code> package (Ba
2015) was originally developed for generating sliced LHDs (Ba et al.
2015), while practitioners can set the number of slices to one to use
the package for generating maximin LHDs. The <code>MaxPro</code> package (Ba and
Joseph 2018) focuses on constructing designs that maximize projection
properties. One of its functions, <code>MaxProLHD</code>, generates MaxPro LHDs
using a simulated annealing algorithm (Joseph et al.2015).</p>
<p>While we acknowledge the contributions of other relevant R packages, we
emphasize the distinguishing features of our developed package. The
<code>LHD</code> package embeds multiple optimality criteria, enabling the
construction of various types of optimal LHDs. In contrast, <code>lhs</code> and
<code>SLHD</code> primarily focus on space-filling Latin hypercube samples and
designs, while <code>MaxPro</code> primarily focuses on maximum projection LHDs.
The <code>LHD</code> package implements various search algorithms and algebraic
constructions, whereas the other three packages do not implement
algebraic constructions, and both <code>SLHD</code> and <code>MaxPro</code> only implement one
algorithm to construct LHDs. The primary application of <code>LHD</code> is in the
design of computer experiments, whereas <code>lhs</code> is mainly used for
sampling and simulation studies. Therefore, <code>LHD</code> emphasizes design
optimality, while <code>lhs</code> emphasizes the space-filling properties of
samples.</p>
<h3 data-number="6" id="Con"><span class="header-section-number">6</span> Conclusion and Recommendation</h3>
<p><code>LHD</code> package implements popular search algorithms, including the SA
(Morris and Mitchell 1995), OASA (Leary et al.2003), SA2008 (Joseph and
Hung 2008), LaPSO (Chen et al.2013) and GA (Liefvendahl and Stocki
2006), along with some widely used algebraic constructions (Wang et al.
2018; Ye 1998; Cioppa and Lucas 2007; Sun et al.2010; Tang 1993; Lin et
al.2009; Butler 2001), for constructing three types of commonly used
optimal LHDs: the maximin distance LHDs, the maximum projection LHDs and
the (nearly) orthogonal LHDs. We aim to provide guidance and an
easy-to-use tool for practitioners to find appropriate experimental
designs. Algebraic constructions are preferred when available,
especially for large designs. Search algorithms are used to generate
optimal LHDs with flexible sizes.</p>
<p>Among very few R libraries particularly for LHDs, <code>LHD</code> is comprehensive
and self-contained as it not only has search algorithms and algebraic
constructions, but also has other useful functions for LHD research and
development such as calculating different optimality criteria,
generating random LHDs, exchanging two random elements in a matrix, and
calculating intersite distance between matrix rows. The help manual in
the package documentation contains further details and illustrative
examples for users who want to explore more of the functions in the
package.</p>
<h3 class="unnumbered" id="acknowledgments">Acknowledgments</h3>
<p>This research was partially supported by the National Science Foundation
(NSF) grant DMS-2311186 and the National Key R&amp;D Program of China
2024YFA1016200. The authors appreciate the reviewers constructive
comments and suggestions.</p>
</div>
<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-SLHD" class="csl-entry" role="listitem">
Ba, Shan. 2015. <em>SLHD: Maximin-Distance (Sliced) Latin Hypercube
Designs</em>. <a href="https://CRAN.R-project.org/package=SLHD" class="uri">https://CRAN.R-project.org/package=SLHD</a>.
</div>
<div id="ref-MaxPro" class="csl-entry" role="listitem">
Ba, Shan, and V. Roshan Joseph. 2018. <em>MaxPro: Maximum Projection
Designs</em>. <a href="https://CRAN.R-project.org/package=MaxPro" class="uri">https://CRAN.R-project.org/package=MaxPro</a>.
</div>
<div id="ref-ba2015optimal" class="csl-entry" role="listitem">
Ba, Shan, William R Myers, and William A Brenneman. 2015. Optimal
Sliced Latin Hypercube Designs. <em>Technometrics</em> 57 (4): 47987.
</div>
<div id="ref-butler2001optimal" class="csl-entry" role="listitem">
Butler, Neil A. 2001. Optimal and Orthogonal Latin Hypercube Designs
for Computer Experiments. <em>Biometrika</em> 88 (3): 84757.
</div>
<div id="ref-lhs" class="csl-entry" role="listitem">
Carnell, Rob. 2024. <em>Lhs: Latin Hypercube Samples</em>.
<a href="https://CRAN.R-project.org/package=lhs" class="uri">https://CRAN.R-project.org/package=lhs</a>.
</div>
<div id="ref-chen2013optimizing" class="csl-entry" role="listitem">
Chen, Ray-Bing, Dai-Ni Hsieh, Ying Hung, and Weichung Wang. 2013.
Optimizing Latin Hypercube Designs by Particle Swarm. <em>Statistics and
Computing</em> 23 (5): 66376.
</div>
<div id="ref-cioppa2007efficient" class="csl-entry" role="listitem">
Cioppa, Thomas M, and Thomas W Lucas. 2007. Efficient Nearly Orthogonal
and Space-Filling Latin Hypercubes. <em>Technometrics</em> 49 (1): 4555.
</div>
<div id="ref-fang2005design" class="csl-entry" role="listitem">
Fang, Kai-Tai, Runze Li, and Agus Sudjianto. 2005. <em>Design and Modeling
for Computer Experiments</em>. CRC press.
</div>
<div id="ref-fang2002centered" class="csl-entry" role="listitem">
Fang, Kai-Tai, Chang-Xing Ma, and Peter Winker. 2002. Centered
<span class="math inline">\({L}_{2}\)</span>-Discrepancy of Random Sampling and Latin Hypercube Design, and
Construction of Uniform Designs. <em>Mathematics of Computation</em> 71 (237):
27596.
</div>
<div id="ref-georgiou2009orthogonal" class="csl-entry" role="listitem">
Georgiou, Stelios D. 2009. Orthogonal Latin Hypercube Designs from
Generalized Orthogonal Designs. <em>Journal of Statistical Planning and
Inference</em> 139 (4): 153040.
</div>
<div id="ref-georgiou2014some" class="csl-entry" role="listitem">
Georgiou, Stelios D, and Ifigenia Efthimiou. 2014. Some Classes of
Orthogonal Latin Hypercube Designs. <em>Statistica Sinica</em> 24 (1):
10120.
</div>
<div id="ref-goldberg1989genetic" class="csl-entry" role="listitem">
Goldberg, David E. 1989. Genetic Algorithms in Search. <em>Optimization,
and MachineLearning</em>.
</div>
<div id="ref-grosso2009finding" class="csl-entry" role="listitem">
Grosso, Andrea, ARMJU Jamali, and Marco Locatelli. 2009. Finding
Maximin Latin Hypercube Designs by Iterated Local Search Heuristics.
<em>European Journal of Operational Research</em> 197 (2): 54147.
</div>
<div id="ref-hickernell1998generalized" class="csl-entry" role="listitem">
Hickernell, Fred. 1998. A Generalized Discrepancy and Quadrature Error
Bound. <em>Mathematics of Computation</em> 67 (221): 299322.
</div>
<div id="ref-holland1992adaptation" class="csl-entry" role="listitem">
<span class="nocase">Holland, John Henry et al.</span> 1992. <em>Adaptation in Natural and
Artificial Systems: An Introductory Analysis with Applications to
Biology, Control, and Artificial Intelligence</em>. MIT press.
</div>
<div id="ref-jin2005efficient" class="csl-entry" role="listitem">
Jin, Ruichen, Wei Chen, and Agus Sudjianto. 2005. An Efficient
Algorithm for Constructing Optimal Design of Computer Experiments.
<em>Journal of Statistical Planning and Inference</em> 134 (1): 26887.
</div>
<div id="ref-johnson1990minimax" class="csl-entry" role="listitem">
Johnson, Mark E, Leslie M Moore, and Donald Ylvisaker. 1990. Minimax
and Maximin Distance Designs. <em>Journal of Statistical Planning and
Inference</em> 26 (2): 13148.
</div>
<div id="ref-joseph2015maximum" class="csl-entry" role="listitem">
Joseph, V Roshan, Evren Gul, and Shan Ba. 2015. Maximum Projection
Designs for Computer Experiments. <em>Biometrika</em> 102 (2): 37180.
</div>
<div id="ref-joseph2008orthogonal" class="csl-entry" role="listitem">
Joseph, V Roshan, and Ying Hung. 2008. Orthogonal-Maximin Latin
Hypercube Designs. <em>Statistica Sinica</em>, 17186.
</div>
<div id="ref-kennedy1995particle" class="csl-entry" role="listitem">
Kennedy, James, and Russell Eberhart. 1995. Particle Swarm
Optimization. <em>Proceedings of ICNN95-International Conference on
Neural Networks</em> 4: 194248.
</div>
<div id="ref-kirkpatrick1983optimization" class="csl-entry" role="listitem">
Kirkpatrick, Scott, C Daniel Gelatt, and Mario P Vecchi. 1983.
Optimization by Simulated Annealing. <em>Science</em> 220 (4598): 67180.
</div>
<div id="ref-leary2003optimal" class="csl-entry" role="listitem">
Leary, Stephen, Atul Bhaskar, and Andy Keane. 2003. Optimal
Orthogonal-Array-Based Latin Hypercubes. <em>Journal of Applied
Statistics</em> 30 (5): 58598.
</div>
<div id="ref-liefvendahl2006study" class="csl-entry" role="listitem">
Liefvendahl, Mattias, and Rafa Stocki. 2006. A Study on Algorithms for
Optimization of Latin Hypercubes. <em>Journal of Statistical Planning and
Inference</em> 136 (9): 323147.
</div>
<div id="ref-lin2009construction" class="csl-entry" role="listitem">
Lin, C. Devon, Rahul Mukerjee, and Boxin Tang. 2009. Construction of
Orthogonal and Nearly Orthogonal Latin Hypercubes. <em>Biometrika</em> 96 (1):
24347.
</div>
<div id="ref-mckay1979comparison" class="csl-entry" role="listitem">
McKay, Michael D, Richard J Beckman, and William J Conover. 1979.
Comparison of Three Methods for Selecting Values of Input Variables in
the Analysis of Output from a Computer Code. <em>Technometrics</em> 21 (2):
23945.
</div>
<div id="ref-morris1995exploratory" class="csl-entry" role="listitem">
Morris, Max D, and Toby J Mitchell. 1995. Exploratory Designs for
Computational Experiments. <em>Journal of Statistical Planning and
Inference</em> 43 (3): 381402.
</div>
<div id="ref-sacks1989designs" class="csl-entry" role="listitem">
Sacks, Jerome, Susannah B Schiller, and William J Welch. 1989. Designs
for Computer Experiments. <em>Technometrics</em> 31 (1): 4147.
</div>
<div id="ref-shewry1987maximum" class="csl-entry" role="listitem">
Shewry, Michael C, and Henry P Wynn. 1987. Maximum Entropy Sampling.
<em>Journal of Applied Statistics</em> 14 (2): 16570.
</div>
<div id="ref-steinberg2006construction" class="csl-entry" role="listitem">
Steinberg, David M, and Dennis K. J. Lin. 2006. A Construction Method
for Orthogonal Latin Hypercube Designs. <em>Biometrika</em> 93 (2): 27988.
</div>
<div id="ref-sun2009construction" class="csl-entry" role="listitem">
Sun, Fasheng, Min-Qian Liu, and Dennis K. J. Lin. 2009. Construction of
Orthogonal Latin Hypercube Designs. <em>Biometrika</em> 96 (4): 97174.
</div>
<div id="ref-sun2010construction" class="csl-entry" role="listitem">
Sun, Fasheng, Min-Qian Liu, and Dennis K. J. Lin. 2010. Construction of
Orthogonal Latin Hypercube Designs with Flexible Run Sizes. <em>Journal of
Statistical Planning and Inference</em> 140 (11): 323642.
</div>
<div id="ref-sun2017general" class="csl-entry" role="listitem">
Sun, Fasheng, and Boxin Tang. 2017. A General Rotation Method for
Orthogonal Latin Hypercubes. <em>Biometrika</em> 104 (2): 46572.
</div>
<div id="ref-tang1993orthogonal" class="csl-entry" role="listitem">
Tang, Boxin. 1993. Orthogonal Array-Based Latin Hypercubes. <em>Journal
of the American Statistical Association</em> 88 (424): 139297.
</div>
<div id="ref-wang2018optimal" class="csl-entry" role="listitem">
Wang, Lin, Qian Xiao, and Hongquan Xu. 2018. Optimal Maximin
<span class="math inline">\({L}_{1}\)</span>-Distance Latin Hypercube Designs Based on Good Lattice Point
Designs. <em>The Annals of Statistics</em> 46 (6B): 374166.
</div>
<div id="ref-williams1949experimental" class="csl-entry" role="listitem">
Williams, EJ. 1949. Experimental Designs Balanced for the Estimation of
Residual Effects of Treatments. <em>Australian Journal of Chemistry</em> 2
(2): 14968.
</div>
<div id="ref-xiao2017construction" class="csl-entry" role="listitem">
Xiao, Qian, and Hongquan Xu. 2017. Construction of Maximin Distance
Latin Squares and Related Latin Hypercube Designs. <em>Biometrika</em> 104
(2): 45564.
</div>
<div id="ref-xiao2018construction" class="csl-entry" role="listitem">
Xiao, Qian, and Hongquan Xu. 2018. Construction of Maximin Distance
Designs via Level Permutation and Expansion. <em>Statistica Sinica</em> 28
(3): 1395414.
</div>
<div id="ref-yang2012construction" class="csl-entry" role="listitem">
Yang, Jinyu, and Min-Qian Liu. 2012. Construction of Orthogonal and
Nearly Orthogonal Latin Hypercube Designs from Orthogonal Designs.
<em>Statistica Sinica</em>, 43342.
</div>
<div id="ref-ye1998orthogonal" class="csl-entry" role="listitem">
Ye, K. Qian. 1998. Orthogonal Column Latin Hypercubes and Their
Application in Computer Experiments. <em>Journal of the American
Statistical Association</em> 93 (444): 143039.
</div>
<div id="ref-kenny2000algorithmic" class="csl-entry" role="listitem">
Ye, K. Qian, William Li, and Agus Sudjianto. 2000. Algorithmic
Construction of Optimal Symmetric Latin Hypercube Designs. <em>Journal of
Statistical Planning and Inference</em> 90 (1): 14559.
</div>
<div id="ref-zhou2015space" class="csl-entry" role="listitem">
Zhou, Yongdao, and Hongquan Xu. 2015. Space-Filling Properties of Good
Lattice Point Sets. <em>Biometrika</em> 102 (4): 95966.
</div>
</div>
<h3 class="appendix" data-number="7" id="supplementary-materials"><span class="header-section-number">7</span> Supplementary materials</h3>
<p>Supplementary materials are available in addition to this article. It can be downloaded at
<a href="RJ-2025-033.zip">RJ-2025-033.zip</a></p>
<h3 class="appendix" data-number="8" id="note"><span class="header-section-number">8</span> Note</h3>
<p>This article is converted from a Legacy LaTeX article using the
<a href="https://cran.r-project.org/package=texor">texor</a> package.
The pdf version is the official version. To report a problem with the html,
refer to CONTRIBUTE on the R Journal homepage.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Package link on CRAN:
<a href="https://cran.r-project.org/web/packages/LHD/index.html" class="uri">https://cran.r-project.org/web/packages/LHD/index.html</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r distill-force-highlighting-css"><code class="sourceCode r"></code></pre></div>
<a href="#fnref1" class="footnote-back" role="doc-backlink"></a></li>
</ol>
</section>
<!--radix_placeholder_article_footer-->
<!--/radix_placeholder_article_footer-->
</div>

<div class="d-appendix">
</div>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<!--radix_placeholder_site_after_body-->
<!--/radix_placeholder_site_after_body-->
<!--radix_placeholder_appendices-->
<div class="appendix-bottom">
<h3 id="references">References</h3>
<div id="references-listing"></div>
<h3 id="reuse">Reuse</h3>
<p>Text and figures are licensed under Creative Commons Attribution <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>. The figures that have been reused from other sources don't fall under this license and can be recognized by a note in their caption: "Figure from ...".</p>
<h3 id="citation">Citation</h3>
<p>For attribution, please cite this work as</p>
<pre class="citation-appendix short">Wang, et al., "LHD: An All-encompassing R Package for Constructing Optimal Latin Hypercube Designs", The R Journal, 2026</pre>
<p>BibTeX citation</p>
<pre class="citation-appendix long">@article{RJ-2025-033,
  author = {Wang, Hongzhi and Xiao, Qian and Mandal, Abhyuday},
  title = {LHD: An All-encompassing R Package for Constructing Optimal Latin Hypercube Designs},
  journal = {The R Journal},
  year = {2026},
  note = {https://doi.org/10.32614/RJ-2025-033},
  doi = {10.32614/RJ-2025-033},
  volume = {17},
  issue = {4},
  issn = {2073-4859},
  pages = {1}
}</pre>
</div>
<!--/radix_placeholder_appendices-->
<!--radix_placeholder_navigation_after_body-->
<!--/radix_placeholder_navigation_after_body-->

</body>

</html>
